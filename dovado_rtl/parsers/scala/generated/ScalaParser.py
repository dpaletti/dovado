# Generated from Scala.g4 by ANTLR 4.11.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,79,1445,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
        91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,
        98,7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,
        2,104,7,104,2,105,7,105,1,0,3,0,214,8,0,1,0,1,0,3,0,218,8,0,1,0,
        1,0,1,0,1,0,1,0,1,0,3,0,226,8,0,1,1,1,1,1,1,5,1,231,8,1,10,1,12,
        1,234,9,1,1,2,1,2,1,2,5,2,239,8,2,10,2,12,2,242,9,2,1,3,1,3,1,3,
        1,3,3,3,248,8,3,1,3,1,3,1,3,3,3,253,8,3,1,3,1,3,3,3,257,8,3,3,3,
        259,8,3,1,3,1,3,1,3,5,3,264,8,3,10,3,12,3,267,9,3,1,4,1,4,1,4,1,
        4,1,5,1,5,1,5,1,5,1,5,1,5,3,5,279,8,5,3,5,281,8,5,1,6,1,6,1,6,1,
        6,1,6,5,6,288,8,6,10,6,12,6,291,9,6,3,6,293,8,6,1,6,3,6,296,8,6,
        1,7,1,7,1,7,4,7,301,8,7,11,7,12,7,302,1,7,1,7,1,8,1,8,1,8,1,8,3,
        8,311,8,8,1,9,1,9,1,9,5,9,316,8,9,10,9,12,9,319,9,9,1,10,1,10,1,
        10,5,10,324,8,10,10,10,12,10,327,9,10,1,10,3,10,330,8,10,1,10,3,
        10,333,8,10,1,11,1,11,5,11,337,8,11,10,11,12,11,340,9,11,1,12,1,
        12,1,12,1,12,3,12,346,8,12,1,12,1,12,1,12,1,12,3,12,352,8,12,1,12,
        1,12,1,12,1,12,1,12,5,12,359,8,12,10,12,12,12,362,9,12,1,13,1,13,
        1,13,1,13,1,14,1,14,1,14,5,14,371,8,14,10,14,12,14,374,9,14,1,15,
        3,15,377,8,15,1,15,1,15,4,15,381,8,15,11,15,12,15,382,1,15,1,15,
        1,16,1,16,1,16,3,16,390,8,16,1,17,1,17,1,18,1,18,1,18,1,18,4,18,
        398,8,18,11,18,12,18,399,1,18,1,18,1,18,3,18,405,8,18,1,19,1,19,
        3,19,409,8,19,1,19,1,19,3,19,413,8,19,1,19,1,19,1,19,3,19,418,8,
        19,1,20,1,20,1,20,1,20,1,20,5,20,425,8,20,10,20,12,20,428,9,20,1,
        20,1,20,1,20,3,20,433,8,20,1,20,1,20,1,20,1,20,1,20,5,20,440,8,20,
        10,20,12,20,443,9,20,1,20,1,20,1,20,1,20,1,20,1,20,3,20,451,8,20,
        1,20,1,20,3,20,455,8,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,
        1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,3,20,473,8,20,1,20,3,20,
        476,8,20,1,20,1,20,1,20,1,20,1,20,1,20,3,20,484,8,20,1,20,1,20,1,
        20,3,20,489,8,20,3,20,491,8,20,1,20,1,20,3,20,495,8,20,1,20,1,20,
        1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,3,20,507,8,20,1,20,1,20,
        1,20,1,20,1,20,1,20,3,20,515,8,20,1,21,1,21,1,22,1,22,3,22,521,8,
        22,1,22,1,22,1,22,5,22,526,8,22,10,22,12,22,529,9,22,1,22,3,22,532,
        8,22,1,23,1,23,1,23,1,23,1,23,1,23,3,23,540,8,23,1,23,5,23,543,8,
        23,10,23,12,23,546,9,23,1,24,3,24,549,8,24,1,24,1,24,1,24,3,24,554,
        8,24,3,24,556,8,24,1,25,1,25,1,25,3,25,561,8,25,1,25,3,25,564,8,
        25,1,26,1,26,1,26,1,26,1,26,1,26,3,26,572,8,26,1,26,1,26,1,26,1,
        26,1,26,1,26,1,26,1,26,3,26,582,8,26,1,26,1,26,3,26,586,8,26,1,26,
        1,26,1,26,1,26,3,26,592,8,26,1,26,1,26,1,26,5,26,597,8,26,10,26,
        12,26,600,9,26,1,27,1,27,1,27,5,27,605,8,27,10,27,12,27,608,9,27,
        1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,3,28,619,8,28,1,28,
        3,28,622,8,28,1,29,3,29,625,8,29,1,29,1,29,1,29,3,29,630,8,29,1,
        29,1,29,3,29,634,8,29,3,29,636,8,29,1,30,1,30,1,30,1,30,1,30,1,30,
        1,30,1,30,3,30,646,8,30,1,31,4,31,649,8,31,11,31,12,31,650,1,31,
        3,31,654,8,31,1,32,1,32,5,32,658,8,32,10,32,12,32,661,9,32,1,32,
        3,32,664,8,32,1,32,1,32,5,32,668,8,32,10,32,12,32,671,9,32,1,32,
        5,32,674,8,32,10,32,12,32,677,9,32,1,32,1,32,3,32,681,8,32,1,33,
        1,33,1,33,3,33,686,8,33,1,33,1,33,3,33,690,8,33,1,33,1,33,3,33,694,
        8,33,1,33,1,33,1,33,3,33,699,8,33,1,34,4,34,702,8,34,11,34,12,34,
        703,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,5,35,714,8,35,10,35,
        12,35,717,9,35,1,36,4,36,720,8,36,11,36,12,36,721,1,37,1,37,1,37,
        3,37,727,8,37,1,37,1,37,1,37,1,38,1,38,1,38,1,39,1,39,1,39,5,39,
        738,8,39,10,39,12,39,741,9,39,1,40,1,40,1,40,1,40,3,40,747,8,40,
        1,41,1,41,1,41,3,41,752,8,41,1,41,3,41,755,8,41,1,42,1,42,1,42,1,
        42,3,42,761,8,42,1,42,5,42,764,8,42,10,42,12,42,767,9,42,3,42,769,
        8,42,1,43,1,43,1,43,1,43,1,43,1,43,3,43,777,8,43,1,43,3,43,780,8,
        43,1,43,1,43,1,43,1,43,1,43,3,43,787,8,43,1,43,1,43,3,43,791,8,43,
        1,43,1,43,1,43,1,43,1,43,1,43,3,43,799,8,43,1,43,3,43,802,8,43,1,
        44,1,44,1,44,3,44,807,8,44,1,44,1,44,3,44,811,8,44,1,45,1,45,1,45,
        1,45,5,45,817,8,45,10,45,12,45,820,9,45,1,45,1,45,1,46,1,46,1,46,
        1,46,5,46,828,8,46,10,46,12,46,831,9,46,1,46,1,46,1,47,5,47,836,
        8,47,10,47,12,47,839,9,47,1,47,3,47,842,8,47,1,47,1,47,1,48,1,48,
        3,48,848,8,48,1,48,1,48,3,48,852,8,48,1,48,1,48,3,48,856,8,48,1,
        48,1,48,5,48,860,8,48,10,48,12,48,863,9,48,1,48,1,48,5,48,867,8,
        48,10,48,12,48,870,9,48,1,49,5,49,873,8,49,10,49,12,49,876,9,49,
        1,49,3,49,879,8,49,1,49,1,49,1,49,1,49,1,49,3,49,886,8,49,1,50,3,
        50,889,8,50,1,50,1,50,3,50,893,8,50,1,50,1,50,1,51,1,51,1,51,5,51,
        900,8,51,10,51,12,51,903,9,51,1,52,5,52,906,8,52,10,52,12,52,909,
        9,52,1,52,1,52,1,52,3,52,914,8,52,1,52,1,52,3,52,918,8,52,1,53,1,
        53,1,53,1,53,1,53,1,53,3,53,926,8,53,1,54,5,54,929,8,54,10,54,12,
        54,932,9,54,1,54,3,54,935,8,54,1,54,1,54,1,54,1,54,1,54,3,54,942,
        8,54,1,55,3,55,945,8,55,1,55,1,55,3,55,949,8,55,1,55,1,55,1,56,1,
        56,1,56,5,56,956,8,56,10,56,12,56,959,9,56,1,57,5,57,962,8,57,10,
        57,12,57,965,9,57,1,57,5,57,968,8,57,10,57,12,57,971,9,57,1,57,3,
        57,974,8,57,1,57,1,57,1,57,1,57,1,57,3,57,981,8,57,1,58,1,58,1,58,
        1,58,5,58,987,8,58,10,58,12,58,990,9,58,1,58,1,58,1,59,1,59,1,59,
        3,59,997,8,59,1,60,1,60,1,60,3,60,1002,8,60,1,61,1,61,1,62,1,62,
        3,62,1008,8,62,1,63,1,63,1,63,1,63,1,64,1,64,1,64,5,64,1017,8,64,
        10,64,12,64,1020,9,64,1,65,1,65,1,65,1,65,1,66,3,66,1027,8,66,1,
        66,1,66,3,66,1031,8,66,1,66,4,66,1034,8,66,11,66,12,66,1035,1,66,
        1,66,1,67,1,67,1,67,3,67,1043,8,67,5,67,1045,8,67,10,67,12,67,1048,
        9,67,1,67,5,67,1051,8,67,10,67,12,67,1054,9,67,1,67,1,67,1,67,3,
        67,1059,8,67,5,67,1061,8,67,10,67,12,67,1064,9,67,1,67,5,67,1067,
        8,67,10,67,12,67,1070,9,67,1,67,1,67,3,67,1074,8,67,1,68,1,68,1,
        68,3,68,1079,8,68,1,68,1,68,1,68,1,68,1,68,1,68,3,68,1087,8,68,1,
        69,1,69,1,69,1,69,5,69,1093,8,69,10,69,12,69,1096,9,69,1,70,1,70,
        1,70,1,70,1,70,3,70,1103,8,70,3,70,1105,8,70,1,71,1,71,1,71,1,71,
        5,71,1111,8,71,10,71,12,71,1114,9,71,1,71,1,71,3,71,1118,8,71,1,
        71,1,71,1,72,1,72,1,72,3,72,1125,8,72,1,73,1,73,1,73,1,73,1,73,1,
        73,1,73,1,73,5,73,1135,8,73,10,73,12,73,1138,9,73,1,73,3,73,1141,
        8,73,1,74,1,74,1,74,1,74,1,75,1,75,1,75,1,75,1,76,1,76,1,76,3,76,
        1154,8,76,1,77,1,77,3,77,1158,8,77,1,77,1,77,1,78,1,78,3,78,1164,
        8,78,1,78,1,78,3,78,1168,8,78,1,78,1,78,3,78,1172,8,78,1,79,1,79,
        1,79,1,79,3,79,1178,8,79,1,80,1,80,1,80,1,80,1,80,5,80,1185,8,80,
        10,80,12,80,1188,9,80,1,80,1,80,3,80,1192,8,80,1,81,1,81,1,81,5,
        81,1197,8,81,10,81,12,81,1200,9,81,1,81,1,81,3,81,1204,8,81,1,81,
        1,81,1,81,1,82,1,82,1,82,1,82,1,82,1,82,1,82,3,82,1216,8,82,1,83,
        1,83,1,83,3,83,1221,8,83,1,83,1,83,1,83,1,83,1,83,3,83,1228,8,83,
        1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,3,83,1240,8,83,
        1,83,3,83,1243,8,83,3,83,1245,8,83,1,84,1,84,3,84,1249,8,84,1,84,
        1,84,1,84,1,85,3,85,1255,8,85,1,85,1,85,1,85,3,85,1260,8,85,1,85,
        1,85,1,85,1,85,3,85,1266,8,85,1,86,1,86,3,86,1270,8,86,1,86,5,86,
        1273,8,86,10,86,12,86,1276,9,86,1,86,3,86,1279,8,86,1,86,1,86,1,
        86,1,87,1,87,3,87,1286,8,87,1,87,1,87,1,88,1,88,1,88,1,89,1,89,1,
        89,3,89,1296,8,89,1,89,3,89,1299,8,89,3,89,1301,8,89,1,90,1,90,1,
        90,3,90,1306,8,90,1,90,3,90,1309,8,90,3,90,1311,8,90,1,91,3,91,1314,
        8,91,1,91,1,91,3,91,1318,8,91,1,92,3,92,1321,8,92,1,92,1,92,3,92,
        1325,8,92,1,93,1,93,1,93,5,93,1330,8,93,10,93,12,93,1333,9,93,1,
        94,1,94,1,94,5,94,1338,8,94,10,94,12,94,1341,9,94,1,95,1,95,5,95,
        1345,8,95,10,95,12,95,1348,9,95,1,96,1,96,4,96,1352,8,96,11,96,12,
        96,1353,1,96,1,96,1,96,1,97,1,97,3,97,1361,8,97,5,97,1363,8,97,10,
        97,12,97,1366,9,97,1,97,5,97,1369,8,97,10,97,12,97,1372,9,97,1,97,
        1,97,1,98,1,98,3,98,1378,8,98,1,99,1,99,1,99,5,99,1383,8,99,10,99,
        12,99,1386,9,99,1,99,1,99,1,100,1,100,4,100,1392,8,100,11,100,12,
        100,1393,1,101,4,101,1397,8,101,11,101,12,101,1398,1,102,1,102,3,
        102,1403,8,102,5,102,1405,8,102,10,102,12,102,1408,9,102,1,102,5,
        102,1411,8,102,10,102,12,102,1414,9,102,1,102,1,102,1,102,1,102,
        3,102,1420,8,102,1,103,1,103,1,103,3,103,1425,8,103,1,103,1,103,
        1,103,1,103,1,104,1,104,1,104,1,104,1,105,1,105,5,105,1437,8,105,
        10,105,12,105,1440,9,105,1,105,1,105,1,105,1,105,0,4,6,24,46,52,
        106,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,
        44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,
        88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,
        124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,
        156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,
        188,190,192,194,196,198,200,202,204,206,208,210,0,10,2,0,1,1,36,
        38,1,0,19,21,2,0,22,22,40,40,3,0,20,20,62,62,70,70,2,0,1,1,36,36,
        2,0,20,20,62,62,2,0,16,16,48,48,3,0,22,22,40,40,50,52,1,0,53,54,
        2,0,5,5,62,62,1587,0,225,1,0,0,0,2,227,1,0,0,0,4,235,1,0,0,0,6,258,
        1,0,0,0,8,268,1,0,0,0,10,280,1,0,0,0,12,295,1,0,0,0,14,297,1,0,0,
        0,16,310,1,0,0,0,18,312,1,0,0,0,20,332,1,0,0,0,22,334,1,0,0,0,24,
        351,1,0,0,0,26,363,1,0,0,0,28,367,1,0,0,0,30,376,1,0,0,0,32,389,
        1,0,0,0,34,391,1,0,0,0,36,404,1,0,0,0,38,417,1,0,0,0,40,514,1,0,
        0,0,42,516,1,0,0,0,44,518,1,0,0,0,46,533,1,0,0,0,48,548,1,0,0,0,
        50,563,1,0,0,0,52,581,1,0,0,0,54,601,1,0,0,0,56,621,1,0,0,0,58,635,
        1,0,0,0,60,645,1,0,0,0,62,648,1,0,0,0,64,680,1,0,0,0,66,698,1,0,
        0,0,68,701,1,0,0,0,70,705,1,0,0,0,72,719,1,0,0,0,74,723,1,0,0,0,
        76,731,1,0,0,0,78,734,1,0,0,0,80,746,1,0,0,0,82,754,1,0,0,0,84,768,
        1,0,0,0,86,801,1,0,0,0,88,810,1,0,0,0,90,812,1,0,0,0,92,823,1,0,
        0,0,94,837,1,0,0,0,96,845,1,0,0,0,98,874,1,0,0,0,100,888,1,0,0,0,
        102,896,1,0,0,0,104,907,1,0,0,0,106,925,1,0,0,0,108,930,1,0,0,0,
        110,944,1,0,0,0,112,952,1,0,0,0,114,963,1,0,0,0,116,982,1,0,0,0,
        118,993,1,0,0,0,120,1001,1,0,0,0,122,1003,1,0,0,0,124,1005,1,0,0,
        0,126,1009,1,0,0,0,128,1013,1,0,0,0,130,1021,1,0,0,0,132,1026,1,
        0,0,0,134,1073,1,0,0,0,136,1086,1,0,0,0,138,1088,1,0,0,0,140,1097,
        1,0,0,0,142,1106,1,0,0,0,144,1121,1,0,0,0,146,1140,1,0,0,0,148,1142,
        1,0,0,0,150,1146,1,0,0,0,152,1150,1,0,0,0,154,1155,1,0,0,0,156,1161,
        1,0,0,0,158,1177,1,0,0,0,160,1191,1,0,0,0,162,1193,1,0,0,0,164,1215,
        1,0,0,0,166,1244,1,0,0,0,168,1246,1,0,0,0,170,1265,1,0,0,0,172,1267,
        1,0,0,0,174,1283,1,0,0,0,176,1289,1,0,0,0,178,1300,1,0,0,0,180,1310,
        1,0,0,0,182,1313,1,0,0,0,184,1320,1,0,0,0,186,1326,1,0,0,0,188,1334,
        1,0,0,0,190,1342,1,0,0,0,192,1349,1,0,0,0,194,1364,1,0,0,0,196,1377,
        1,0,0,0,198,1379,1,0,0,0,200,1389,1,0,0,0,202,1396,1,0,0,0,204,1419,
        1,0,0,0,206,1421,1,0,0,0,208,1430,1,0,0,0,210,1438,1,0,0,0,212,214,
        5,1,0,0,213,212,1,0,0,0,213,214,1,0,0,0,214,215,1,0,0,0,215,226,
        5,66,0,0,216,218,5,1,0,0,217,216,1,0,0,0,217,218,1,0,0,0,218,219,
        1,0,0,0,219,226,5,68,0,0,220,226,5,63,0,0,221,226,5,64,0,0,222,226,
        5,67,0,0,223,226,5,65,0,0,224,226,5,2,0,0,225,213,1,0,0,0,225,217,
        1,0,0,0,225,220,1,0,0,0,225,221,1,0,0,0,225,222,1,0,0,0,225,223,
        1,0,0,0,225,224,1,0,0,0,226,1,1,0,0,0,227,232,5,62,0,0,228,229,5,
        3,0,0,229,231,5,62,0,0,230,228,1,0,0,0,231,234,1,0,0,0,232,230,1,
        0,0,0,232,233,1,0,0,0,233,3,1,0,0,0,234,232,1,0,0,0,235,240,5,62,
        0,0,236,237,5,4,0,0,237,239,5,62,0,0,238,236,1,0,0,0,239,242,1,0,
        0,0,240,238,1,0,0,0,240,241,1,0,0,0,241,5,1,0,0,0,242,240,1,0,0,
        0,243,244,6,3,-1,0,244,259,5,62,0,0,245,246,5,62,0,0,246,248,5,3,
        0,0,247,245,1,0,0,0,247,248,1,0,0,0,248,256,1,0,0,0,249,257,5,5,
        0,0,250,252,5,6,0,0,251,253,3,8,4,0,252,251,1,0,0,0,252,253,1,0,
        0,0,253,254,1,0,0,0,254,255,5,3,0,0,255,257,5,62,0,0,256,249,1,0,
        0,0,256,250,1,0,0,0,257,259,1,0,0,0,258,243,1,0,0,0,258,247,1,0,
        0,0,259,265,1,0,0,0,260,261,10,2,0,0,261,262,5,3,0,0,262,264,5,62,
        0,0,263,260,1,0,0,0,264,267,1,0,0,0,265,263,1,0,0,0,265,266,1,0,
        0,0,266,7,1,0,0,0,267,265,1,0,0,0,268,269,5,7,0,0,269,270,5,62,0,
        0,270,271,5,8,0,0,271,9,1,0,0,0,272,273,3,12,6,0,273,274,5,9,0,0,
        274,275,3,10,5,0,275,281,1,0,0,0,276,278,3,18,9,0,277,279,3,14,7,
        0,278,277,1,0,0,0,278,279,1,0,0,0,279,281,1,0,0,0,280,272,1,0,0,
        0,280,276,1,0,0,0,281,11,1,0,0,0,282,296,3,18,9,0,283,292,5,10,0,
        0,284,289,3,106,53,0,285,286,5,4,0,0,286,288,3,106,53,0,287,285,
        1,0,0,0,288,291,1,0,0,0,289,287,1,0,0,0,289,290,1,0,0,0,290,293,
        1,0,0,0,291,289,1,0,0,0,292,284,1,0,0,0,292,293,1,0,0,0,293,294,
        1,0,0,0,294,296,5,11,0,0,295,282,1,0,0,0,295,283,1,0,0,0,296,13,
        1,0,0,0,297,298,5,12,0,0,298,300,5,13,0,0,299,301,3,16,8,0,300,299,
        1,0,0,0,301,302,1,0,0,0,302,300,1,0,0,0,302,303,1,0,0,0,303,304,
        1,0,0,0,304,305,5,14,0,0,305,15,1,0,0,0,306,307,5,15,0,0,307,311,
        3,156,78,0,308,309,5,16,0,0,309,311,3,148,74,0,310,306,1,0,0,0,310,
        308,1,0,0,0,311,17,1,0,0,0,312,317,3,20,10,0,313,314,5,62,0,0,314,
        316,3,20,10,0,315,313,1,0,0,0,316,319,1,0,0,0,317,315,1,0,0,0,317,
        318,1,0,0,0,318,19,1,0,0,0,319,317,1,0,0,0,320,325,3,22,11,0,321,
        322,5,17,0,0,322,324,3,22,11,0,323,321,1,0,0,0,324,327,1,0,0,0,325,
        323,1,0,0,0,325,326,1,0,0,0,326,329,1,0,0,0,327,325,1,0,0,0,328,
        330,3,30,15,0,329,328,1,0,0,0,329,330,1,0,0,0,330,333,1,0,0,0,331,
        333,3,30,15,0,332,320,1,0,0,0,332,331,1,0,0,0,333,21,1,0,0,0,334,
        338,3,24,12,0,335,337,3,128,64,0,336,335,1,0,0,0,337,340,1,0,0,0,
        338,336,1,0,0,0,338,339,1,0,0,0,339,23,1,0,0,0,340,338,1,0,0,0,341,
        342,6,12,-1,0,342,345,3,6,3,0,343,344,5,3,0,0,344,346,5,15,0,0,345,
        343,1,0,0,0,345,346,1,0,0,0,346,352,1,0,0,0,347,348,5,10,0,0,348,
        349,3,28,14,0,349,350,5,11,0,0,350,352,1,0,0,0,351,341,1,0,0,0,351,
        347,1,0,0,0,352,360,1,0,0,0,353,354,10,4,0,0,354,359,3,26,13,0,355,
        356,10,3,0,0,356,357,5,18,0,0,357,359,5,62,0,0,358,353,1,0,0,0,358,
        355,1,0,0,0,359,362,1,0,0,0,360,358,1,0,0,0,360,361,1,0,0,0,361,
        25,1,0,0,0,362,360,1,0,0,0,363,364,5,7,0,0,364,365,3,28,14,0,365,
        366,5,8,0,0,366,27,1,0,0,0,367,372,3,10,5,0,368,369,5,4,0,0,369,
        371,3,10,5,0,370,368,1,0,0,0,371,374,1,0,0,0,372,370,1,0,0,0,372,
        373,1,0,0,0,373,29,1,0,0,0,374,372,1,0,0,0,375,377,5,74,0,0,376,
        375,1,0,0,0,376,377,1,0,0,0,377,378,1,0,0,0,378,380,5,13,0,0,379,
        381,3,32,16,0,380,379,1,0,0,0,381,382,1,0,0,0,382,380,1,0,0,0,382,
        383,1,0,0,0,383,384,1,0,0,0,384,385,5,14,0,0,385,31,1,0,0,0,386,
        390,3,146,73,0,387,388,5,15,0,0,388,390,3,168,84,0,389,386,1,0,0,
        0,389,387,1,0,0,0,390,33,1,0,0,0,391,392,3,10,5,0,392,35,1,0,0,0,
        393,394,5,19,0,0,394,405,3,18,9,0,395,397,5,19,0,0,396,398,3,128,
        64,0,397,396,1,0,0,0,398,399,1,0,0,0,399,397,1,0,0,0,399,400,1,0,
        0,0,400,405,1,0,0,0,401,402,5,19,0,0,402,403,5,20,0,0,403,405,5,
        21,0,0,404,393,1,0,0,0,404,395,1,0,0,0,404,401,1,0,0,0,405,37,1,
        0,0,0,406,413,3,116,58,0,407,409,5,22,0,0,408,407,1,0,0,0,408,409,
        1,0,0,0,409,410,1,0,0,0,410,413,5,62,0,0,411,413,5,20,0,0,412,406,
        1,0,0,0,412,408,1,0,0,0,412,411,1,0,0,0,413,414,1,0,0,0,414,415,
        5,9,0,0,415,418,3,38,19,0,416,418,3,40,20,0,417,412,1,0,0,0,417,
        416,1,0,0,0,418,39,1,0,0,0,419,420,5,23,0,0,420,421,5,10,0,0,421,
        422,3,38,19,0,422,426,5,11,0,0,423,425,5,74,0,0,424,423,1,0,0,0,
        425,428,1,0,0,0,426,424,1,0,0,0,426,427,1,0,0,0,427,429,1,0,0,0,
        428,426,1,0,0,0,429,432,3,38,19,0,430,431,5,24,0,0,431,433,3,38,
        19,0,432,430,1,0,0,0,432,433,1,0,0,0,433,515,1,0,0,0,434,435,5,25,
        0,0,435,436,5,10,0,0,436,437,3,38,19,0,437,441,5,11,0,0,438,440,
        5,74,0,0,439,438,1,0,0,0,440,443,1,0,0,0,441,439,1,0,0,0,441,442,
        1,0,0,0,442,444,1,0,0,0,443,441,1,0,0,0,444,445,3,38,19,0,445,515,
        1,0,0,0,446,447,5,26,0,0,447,450,3,38,19,0,448,449,5,27,0,0,449,
        451,3,38,19,0,450,448,1,0,0,0,450,451,1,0,0,0,451,454,1,0,0,0,452,
        453,5,28,0,0,453,455,3,38,19,0,454,452,1,0,0,0,454,455,1,0,0,0,455,
        515,1,0,0,0,456,457,5,29,0,0,457,458,3,38,19,0,458,459,5,25,0,0,
        459,460,5,10,0,0,460,461,3,38,19,0,461,462,5,11,0,0,462,515,1,0,
        0,0,463,472,5,30,0,0,464,465,5,10,0,0,465,466,3,68,34,0,466,467,
        5,11,0,0,467,473,1,0,0,0,468,469,5,13,0,0,469,470,3,68,34,0,470,
        471,5,14,0,0,471,473,1,0,0,0,472,464,1,0,0,0,472,468,1,0,0,0,473,
        475,1,0,0,0,474,476,5,31,0,0,475,474,1,0,0,0,475,476,1,0,0,0,476,
        477,1,0,0,0,477,478,3,38,19,0,478,515,1,0,0,0,479,480,5,32,0,0,480,
        515,3,38,19,0,481,483,5,33,0,0,482,484,3,38,19,0,483,482,1,0,0,0,
        483,484,1,0,0,0,484,515,1,0,0,0,485,491,3,50,25,0,486,488,3,52,26,
        0,487,489,5,20,0,0,488,487,1,0,0,0,488,489,1,0,0,0,489,491,1,0,0,
        0,490,485,1,0,0,0,490,486,1,0,0,0,491,492,1,0,0,0,492,493,5,3,0,
        0,493,495,1,0,0,0,494,490,1,0,0,0,494,495,1,0,0,0,495,496,1,0,0,
        0,496,497,5,62,0,0,497,498,5,34,0,0,498,515,3,38,19,0,499,500,3,
        52,26,0,500,501,3,56,28,0,501,502,5,34,0,0,502,503,3,38,19,0,503,
        515,1,0,0,0,504,506,3,44,22,0,505,507,3,36,18,0,506,505,1,0,0,0,
        506,507,1,0,0,0,507,515,1,0,0,0,508,509,3,44,22,0,509,510,5,35,0,
        0,510,511,5,13,0,0,511,512,3,72,36,0,512,513,5,14,0,0,513,515,1,
        0,0,0,514,419,1,0,0,0,514,434,1,0,0,0,514,446,1,0,0,0,514,456,1,
        0,0,0,514,463,1,0,0,0,514,479,1,0,0,0,514,481,1,0,0,0,514,494,1,
        0,0,0,514,499,1,0,0,0,514,504,1,0,0,0,514,508,1,0,0,0,515,41,1,0,
        0,0,516,517,7,0,0,0,517,43,1,0,0,0,518,520,3,46,23,0,519,521,5,62,
        0,0,520,519,1,0,0,0,520,521,1,0,0,0,521,527,1,0,0,0,522,523,3,42,
        21,0,523,524,3,52,26,0,524,526,1,0,0,0,525,522,1,0,0,0,526,529,1,
        0,0,0,527,525,1,0,0,0,527,528,1,0,0,0,528,531,1,0,0,0,529,527,1,
        0,0,0,530,532,5,74,0,0,531,530,1,0,0,0,531,532,1,0,0,0,532,45,1,
        0,0,0,533,534,6,23,-1,0,534,535,3,48,24,0,535,544,1,0,0,0,536,537,
        10,1,0,0,537,539,5,62,0,0,538,540,5,74,0,0,539,538,1,0,0,0,539,540,
        1,0,0,0,540,541,1,0,0,0,541,543,3,46,23,2,542,536,1,0,0,0,543,546,
        1,0,0,0,544,542,1,0,0,0,544,545,1,0,0,0,545,47,1,0,0,0,546,544,1,
        0,0,0,547,549,3,42,21,0,548,547,1,0,0,0,548,549,1,0,0,0,549,555,
        1,0,0,0,550,556,3,50,25,0,551,553,3,52,26,0,552,554,5,20,0,0,553,
        552,1,0,0,0,553,554,1,0,0,0,554,556,1,0,0,0,555,550,1,0,0,0,555,
        551,1,0,0,0,556,49,1,0,0,0,557,560,5,39,0,0,558,561,3,182,91,0,559,
        561,3,132,66,0,560,558,1,0,0,0,560,559,1,0,0,0,561,564,1,0,0,0,562,
        564,3,60,30,0,563,557,1,0,0,0,563,562,1,0,0,0,564,51,1,0,0,0,565,
        566,6,26,-1,0,566,582,3,0,0,0,567,582,3,6,3,0,568,582,5,20,0,0,569,
        571,5,10,0,0,570,572,3,54,27,0,571,570,1,0,0,0,571,572,1,0,0,0,572,
        573,1,0,0,0,573,582,5,11,0,0,574,575,3,50,25,0,575,576,5,3,0,0,576,
        577,5,62,0,0,577,582,1,0,0,0,578,579,3,50,25,0,579,580,3,26,13,0,
        580,582,1,0,0,0,581,565,1,0,0,0,581,567,1,0,0,0,581,568,1,0,0,0,
        581,569,1,0,0,0,581,574,1,0,0,0,581,578,1,0,0,0,582,598,1,0,0,0,
        583,585,10,4,0,0,584,586,5,20,0,0,585,584,1,0,0,0,585,586,1,0,0,
        0,586,587,1,0,0,0,587,588,5,3,0,0,588,597,5,62,0,0,589,591,10,2,
        0,0,590,592,5,20,0,0,591,590,1,0,0,0,591,592,1,0,0,0,592,593,1,0,
        0,0,593,597,3,26,13,0,594,595,10,1,0,0,595,597,3,56,28,0,596,583,
        1,0,0,0,596,589,1,0,0,0,596,594,1,0,0,0,597,600,1,0,0,0,598,596,
        1,0,0,0,598,599,1,0,0,0,599,53,1,0,0,0,600,598,1,0,0,0,601,606,3,
        38,19,0,602,603,5,4,0,0,603,605,3,38,19,0,604,602,1,0,0,0,605,608,
        1,0,0,0,606,604,1,0,0,0,606,607,1,0,0,0,607,55,1,0,0,0,608,606,1,
        0,0,0,609,610,5,10,0,0,610,611,3,58,29,0,611,612,5,11,0,0,612,622,
        1,0,0,0,613,614,5,13,0,0,614,615,3,58,29,0,615,616,5,14,0,0,616,
        622,1,0,0,0,617,619,5,74,0,0,618,617,1,0,0,0,618,619,1,0,0,0,619,
        620,1,0,0,0,620,622,3,60,30,0,621,609,1,0,0,0,621,613,1,0,0,0,621,
        618,1,0,0,0,622,57,1,0,0,0,623,625,3,54,27,0,624,623,1,0,0,0,624,
        625,1,0,0,0,625,636,1,0,0,0,626,627,3,54,27,0,627,628,5,4,0,0,628,
        630,1,0,0,0,629,626,1,0,0,0,629,630,1,0,0,0,630,631,1,0,0,0,631,
        633,3,44,22,0,632,634,7,1,0,0,633,632,1,0,0,0,633,634,1,0,0,0,634,
        636,1,0,0,0,635,624,1,0,0,0,635,629,1,0,0,0,636,59,1,0,0,0,637,638,
        5,13,0,0,638,639,3,72,36,0,639,640,5,14,0,0,640,646,1,0,0,0,641,
        642,5,13,0,0,642,643,3,62,31,0,643,644,5,14,0,0,644,646,1,0,0,0,
        645,637,1,0,0,0,645,641,1,0,0,0,646,61,1,0,0,0,647,649,3,64,32,0,
        648,647,1,0,0,0,649,650,1,0,0,0,650,648,1,0,0,0,650,651,1,0,0,0,
        651,653,1,0,0,0,652,654,3,66,33,0,653,652,1,0,0,0,653,654,1,0,0,
        0,654,63,1,0,0,0,655,681,3,138,69,0,656,658,3,128,64,0,657,656,1,
        0,0,0,658,661,1,0,0,0,659,657,1,0,0,0,659,660,1,0,0,0,660,663,1,
        0,0,0,661,659,1,0,0,0,662,664,7,2,0,0,663,662,1,0,0,0,663,664,1,
        0,0,0,664,665,1,0,0,0,665,681,3,160,80,0,666,668,3,128,64,0,667,
        666,1,0,0,0,668,671,1,0,0,0,669,667,1,0,0,0,669,670,1,0,0,0,670,
        675,1,0,0,0,671,669,1,0,0,0,672,674,3,122,61,0,673,672,1,0,0,0,674,
        677,1,0,0,0,675,673,1,0,0,0,675,676,1,0,0,0,676,678,1,0,0,0,677,
        675,1,0,0,0,678,681,3,170,85,0,679,681,3,40,20,0,680,655,1,0,0,0,
        680,659,1,0,0,0,680,669,1,0,0,0,680,679,1,0,0,0,681,65,1,0,0,0,682,
        699,3,40,20,0,683,694,3,116,58,0,684,686,5,22,0,0,685,684,1,0,0,
        0,685,686,1,0,0,0,686,687,1,0,0,0,687,690,5,62,0,0,688,690,5,20,
        0,0,689,685,1,0,0,0,689,688,1,0,0,0,690,691,1,0,0,0,691,692,5,19,
        0,0,692,694,3,20,10,0,693,683,1,0,0,0,693,689,1,0,0,0,694,695,1,
        0,0,0,695,696,5,9,0,0,696,697,3,62,31,0,697,699,1,0,0,0,698,682,
        1,0,0,0,698,693,1,0,0,0,699,67,1,0,0,0,700,702,3,70,35,0,701,700,
        1,0,0,0,702,703,1,0,0,0,703,701,1,0,0,0,703,704,1,0,0,0,704,69,1,
        0,0,0,705,706,3,80,40,0,706,707,5,41,0,0,707,715,3,38,19,0,708,714,
        3,76,38,0,709,710,3,80,40,0,710,711,5,34,0,0,711,712,3,38,19,0,712,
        714,1,0,0,0,713,708,1,0,0,0,713,709,1,0,0,0,714,717,1,0,0,0,715,
        713,1,0,0,0,715,716,1,0,0,0,716,71,1,0,0,0,717,715,1,0,0,0,718,720,
        3,74,37,0,719,718,1,0,0,0,720,721,1,0,0,0,721,719,1,0,0,0,721,722,
        1,0,0,0,722,73,1,0,0,0,723,724,5,42,0,0,724,726,3,78,39,0,725,727,
        3,76,38,0,726,725,1,0,0,0,726,727,1,0,0,0,727,728,1,0,0,0,728,729,
        5,9,0,0,729,730,3,62,31,0,730,75,1,0,0,0,731,732,5,23,0,0,732,733,
        3,44,22,0,733,77,1,0,0,0,734,739,3,80,40,0,735,736,5,43,0,0,736,
        738,3,80,40,0,737,735,1,0,0,0,738,741,1,0,0,0,739,737,1,0,0,0,739,
        740,1,0,0,0,740,79,1,0,0,0,741,739,1,0,0,0,742,743,7,3,0,0,743,744,
        5,19,0,0,744,747,3,34,17,0,745,747,3,82,41,0,746,742,1,0,0,0,746,
        745,1,0,0,0,747,81,1,0,0,0,748,751,5,62,0,0,749,750,5,44,0,0,750,
        752,3,84,42,0,751,749,1,0,0,0,751,752,1,0,0,0,752,755,1,0,0,0,753,
        755,3,84,42,0,754,748,1,0,0,0,754,753,1,0,0,0,755,83,1,0,0,0,756,
        769,3,86,43,0,757,765,3,86,43,0,758,760,5,62,0,0,759,761,5,74,0,
        0,760,759,1,0,0,0,760,761,1,0,0,0,761,762,1,0,0,0,762,764,3,86,43,
        0,763,758,1,0,0,0,764,767,1,0,0,0,765,763,1,0,0,0,765,766,1,0,0,
        0,766,769,1,0,0,0,767,765,1,0,0,0,768,756,1,0,0,0,768,757,1,0,0,
        0,769,85,1,0,0,0,770,802,5,20,0,0,771,802,5,69,0,0,772,802,3,0,0,
        0,773,779,3,6,3,0,774,776,5,10,0,0,775,777,3,88,44,0,776,775,1,0,
        0,0,776,777,1,0,0,0,777,778,1,0,0,0,778,780,5,11,0,0,779,774,1,0,
        0,0,779,780,1,0,0,0,780,802,1,0,0,0,781,782,3,6,3,0,782,786,5,10,
        0,0,783,784,3,88,44,0,784,785,5,4,0,0,785,787,1,0,0,0,786,783,1,
        0,0,0,786,787,1,0,0,0,787,790,1,0,0,0,788,789,5,62,0,0,789,791,5,
        44,0,0,790,788,1,0,0,0,790,791,1,0,0,0,791,792,1,0,0,0,792,793,5,
        20,0,0,793,794,5,21,0,0,794,795,5,11,0,0,795,802,1,0,0,0,796,798,
        5,10,0,0,797,799,3,88,44,0,798,797,1,0,0,0,798,799,1,0,0,0,799,800,
        1,0,0,0,800,802,5,11,0,0,801,770,1,0,0,0,801,771,1,0,0,0,801,772,
        1,0,0,0,801,773,1,0,0,0,801,781,1,0,0,0,801,796,1,0,0,0,802,87,1,
        0,0,0,803,806,3,78,39,0,804,805,5,4,0,0,805,807,3,88,44,0,806,804,
        1,0,0,0,806,807,1,0,0,0,807,811,1,0,0,0,808,809,5,20,0,0,809,811,
        5,21,0,0,810,803,1,0,0,0,810,808,1,0,0,0,811,89,1,0,0,0,812,813,
        5,7,0,0,813,818,3,94,47,0,814,815,5,4,0,0,815,817,3,94,47,0,816,
        814,1,0,0,0,817,820,1,0,0,0,818,816,1,0,0,0,818,819,1,0,0,0,819,
        821,1,0,0,0,820,818,1,0,0,0,821,822,5,8,0,0,822,91,1,0,0,0,823,824,
        5,7,0,0,824,829,3,96,48,0,825,826,5,4,0,0,826,828,3,96,48,0,827,
        825,1,0,0,0,828,831,1,0,0,0,829,827,1,0,0,0,829,830,1,0,0,0,830,
        832,1,0,0,0,831,829,1,0,0,0,832,833,5,8,0,0,833,93,1,0,0,0,834,836,
        3,128,64,0,835,834,1,0,0,0,836,839,1,0,0,0,837,835,1,0,0,0,837,838,
        1,0,0,0,838,841,1,0,0,0,839,837,1,0,0,0,840,842,7,4,0,0,841,840,
        1,0,0,0,841,842,1,0,0,0,842,843,1,0,0,0,843,844,3,96,48,0,844,95,
        1,0,0,0,845,847,7,5,0,0,846,848,3,90,45,0,847,846,1,0,0,0,847,848,
        1,0,0,0,848,851,1,0,0,0,849,850,5,45,0,0,850,852,3,10,5,0,851,849,
        1,0,0,0,851,852,1,0,0,0,852,855,1,0,0,0,853,854,5,46,0,0,854,856,
        3,10,5,0,855,853,1,0,0,0,855,856,1,0,0,0,856,861,1,0,0,0,857,858,
        5,47,0,0,858,860,3,10,5,0,859,857,1,0,0,0,860,863,1,0,0,0,861,859,
        1,0,0,0,861,862,1,0,0,0,862,868,1,0,0,0,863,861,1,0,0,0,864,865,
        5,19,0,0,865,867,3,10,5,0,866,864,1,0,0,0,867,870,1,0,0,0,868,866,
        1,0,0,0,868,869,1,0,0,0,869,97,1,0,0,0,870,868,1,0,0,0,871,873,3,
        100,50,0,872,871,1,0,0,0,873,876,1,0,0,0,874,872,1,0,0,0,874,875,
        1,0,0,0,875,885,1,0,0,0,876,874,1,0,0,0,877,879,5,74,0,0,878,877,
        1,0,0,0,878,879,1,0,0,0,879,880,1,0,0,0,880,881,5,10,0,0,881,882,
        5,22,0,0,882,883,3,102,51,0,883,884,5,11,0,0,884,886,1,0,0,0,885,
        878,1,0,0,0,885,886,1,0,0,0,886,99,1,0,0,0,887,889,5,74,0,0,888,
        887,1,0,0,0,888,889,1,0,0,0,889,890,1,0,0,0,890,892,5,10,0,0,891,
        893,3,102,51,0,892,891,1,0,0,0,892,893,1,0,0,0,893,894,1,0,0,0,894,
        895,5,11,0,0,895,101,1,0,0,0,896,901,3,104,52,0,897,898,5,4,0,0,
        898,900,3,104,52,0,899,897,1,0,0,0,900,903,1,0,0,0,901,899,1,0,0,
        0,901,902,1,0,0,0,902,103,1,0,0,0,903,901,1,0,0,0,904,906,3,128,
        64,0,905,904,1,0,0,0,906,909,1,0,0,0,907,905,1,0,0,0,907,908,1,0,
        0,0,908,910,1,0,0,0,909,907,1,0,0,0,910,913,5,62,0,0,911,912,5,19,
        0,0,912,914,3,106,53,0,913,911,1,0,0,0,913,914,1,0,0,0,914,917,1,
        0,0,0,915,916,5,34,0,0,916,918,3,38,19,0,917,915,1,0,0,0,917,918,
        1,0,0,0,918,105,1,0,0,0,919,926,3,10,5,0,920,921,5,9,0,0,921,926,
        3,10,5,0,922,923,3,10,5,0,923,924,5,21,0,0,924,926,1,0,0,0,925,919,
        1,0,0,0,925,920,1,0,0,0,925,922,1,0,0,0,926,107,1,0,0,0,927,929,
        3,110,55,0,928,927,1,0,0,0,929,932,1,0,0,0,930,928,1,0,0,0,930,931,
        1,0,0,0,931,941,1,0,0,0,932,930,1,0,0,0,933,935,5,74,0,0,934,933,
        1,0,0,0,934,935,1,0,0,0,935,936,1,0,0,0,936,937,5,10,0,0,937,938,
        5,22,0,0,938,939,3,112,56,0,939,940,5,11,0,0,940,942,1,0,0,0,941,
        934,1,0,0,0,941,942,1,0,0,0,942,109,1,0,0,0,943,945,5,74,0,0,944,
        943,1,0,0,0,944,945,1,0,0,0,945,946,1,0,0,0,946,948,5,10,0,0,947,
        949,3,112,56,0,948,947,1,0,0,0,948,949,1,0,0,0,949,950,1,0,0,0,950,
        951,5,11,0,0,951,111,1,0,0,0,952,957,3,114,57,0,953,954,5,4,0,0,
        954,956,3,114,57,0,955,953,1,0,0,0,956,959,1,0,0,0,957,955,1,0,0,
        0,957,958,1,0,0,0,958,113,1,0,0,0,959,957,1,0,0,0,960,962,3,128,
        64,0,961,960,1,0,0,0,962,965,1,0,0,0,963,961,1,0,0,0,963,964,1,0,
        0,0,964,969,1,0,0,0,965,963,1,0,0,0,966,968,3,120,60,0,967,966,1,
        0,0,0,968,971,1,0,0,0,969,967,1,0,0,0,969,970,1,0,0,0,970,973,1,
        0,0,0,971,969,1,0,0,0,972,974,7,6,0,0,973,972,1,0,0,0,973,974,1,
        0,0,0,974,975,1,0,0,0,975,976,5,62,0,0,976,977,5,19,0,0,977,980,
        3,106,53,0,978,979,5,34,0,0,979,981,3,38,19,0,980,978,1,0,0,0,980,
        981,1,0,0,0,981,115,1,0,0,0,982,983,5,10,0,0,983,988,3,118,59,0,
        984,985,5,4,0,0,985,987,3,118,59,0,986,984,1,0,0,0,987,990,1,0,0,
        0,988,986,1,0,0,0,988,989,1,0,0,0,989,991,1,0,0,0,990,988,1,0,0,
        0,991,992,5,11,0,0,992,117,1,0,0,0,993,996,7,5,0,0,994,995,5,19,
        0,0,995,997,3,10,5,0,996,994,1,0,0,0,996,997,1,0,0,0,997,119,1,0,
        0,0,998,1002,3,122,61,0,999,1002,3,124,62,0,1000,1002,5,49,0,0,1001,
        998,1,0,0,0,1001,999,1,0,0,0,1001,1000,1,0,0,0,1002,121,1,0,0,0,
        1003,1004,7,7,0,0,1004,123,1,0,0,0,1005,1007,7,8,0,0,1006,1008,3,
        126,63,0,1007,1006,1,0,0,0,1007,1008,1,0,0,0,1008,125,1,0,0,0,1009,
        1010,5,7,0,0,1010,1011,7,9,0,0,1011,1012,5,8,0,0,1012,127,1,0,0,
        0,1013,1014,5,44,0,0,1014,1018,3,24,12,0,1015,1017,3,56,28,0,1016,
        1015,1,0,0,0,1017,1020,1,0,0,0,1018,1016,1,0,0,0,1018,1019,1,0,0,
        0,1019,129,1,0,0,0,1020,1018,1,0,0,0,1021,1022,5,44,0,0,1022,1023,
        3,24,12,0,1023,1024,3,56,28,0,1024,131,1,0,0,0,1025,1027,5,74,0,
        0,1026,1025,1,0,0,0,1026,1027,1,0,0,0,1027,1028,1,0,0,0,1028,1030,
        5,13,0,0,1029,1031,3,136,68,0,1030,1029,1,0,0,0,1030,1031,1,0,0,
        0,1031,1033,1,0,0,0,1032,1034,3,134,67,0,1033,1032,1,0,0,0,1034,
        1035,1,0,0,0,1035,1033,1,0,0,0,1035,1036,1,0,0,0,1036,1037,1,0,0,
        0,1037,1038,5,14,0,0,1038,133,1,0,0,0,1039,1074,3,138,69,0,1040,
        1042,3,128,64,0,1041,1043,5,74,0,0,1042,1041,1,0,0,0,1042,1043,1,
        0,0,0,1043,1045,1,0,0,0,1044,1040,1,0,0,0,1045,1048,1,0,0,0,1046,
        1044,1,0,0,0,1046,1047,1,0,0,0,1047,1052,1,0,0,0,1048,1046,1,0,0,
        0,1049,1051,3,120,60,0,1050,1049,1,0,0,0,1051,1054,1,0,0,0,1052,
        1050,1,0,0,0,1052,1053,1,0,0,0,1053,1055,1,0,0,0,1054,1052,1,0,0,
        0,1055,1074,3,160,80,0,1056,1058,3,128,64,0,1057,1059,5,74,0,0,1058,
        1057,1,0,0,0,1058,1059,1,0,0,0,1059,1061,1,0,0,0,1060,1056,1,0,0,
        0,1061,1064,1,0,0,0,1062,1060,1,0,0,0,1062,1063,1,0,0,0,1063,1068,
        1,0,0,0,1064,1062,1,0,0,0,1065,1067,3,120,60,0,1066,1065,1,0,0,0,
        1067,1070,1,0,0,0,1068,1066,1,0,0,0,1068,1069,1,0,0,0,1069,1071,
        1,0,0,0,1070,1068,1,0,0,0,1071,1074,3,146,73,0,1072,1074,3,38,19,
        0,1073,1039,1,0,0,0,1073,1046,1,0,0,0,1073,1062,1,0,0,0,1073,1072,
        1,0,0,0,1074,135,1,0,0,0,1075,1078,5,62,0,0,1076,1077,5,19,0,0,1077,
        1079,3,10,5,0,1078,1076,1,0,0,0,1078,1079,1,0,0,0,1079,1080,1,0,
        0,0,1080,1087,5,9,0,0,1081,1082,5,5,0,0,1082,1083,5,19,0,0,1083,
        1084,3,10,5,0,1084,1085,5,9,0,0,1085,1087,1,0,0,0,1086,1075,1,0,
        0,0,1086,1081,1,0,0,0,1087,137,1,0,0,0,1088,1089,5,55,0,0,1089,1094,
        3,140,70,0,1090,1091,5,4,0,0,1091,1093,3,140,70,0,1092,1090,1,0,
        0,0,1093,1096,1,0,0,0,1094,1092,1,0,0,0,1094,1095,1,0,0,0,1095,139,
        1,0,0,0,1096,1094,1,0,0,0,1097,1104,3,6,3,0,1098,1102,5,3,0,0,1099,
        1103,5,62,0,0,1100,1103,5,20,0,0,1101,1103,3,142,71,0,1102,1099,
        1,0,0,0,1102,1100,1,0,0,0,1102,1101,1,0,0,0,1103,1105,1,0,0,0,1104,
        1098,1,0,0,0,1104,1105,1,0,0,0,1105,141,1,0,0,0,1106,1112,5,13,0,
        0,1107,1108,3,144,72,0,1108,1109,5,4,0,0,1109,1111,1,0,0,0,1110,
        1107,1,0,0,0,1111,1114,1,0,0,0,1112,1110,1,0,0,0,1112,1113,1,0,0,
        0,1113,1117,1,0,0,0,1114,1112,1,0,0,0,1115,1118,3,144,72,0,1116,
        1118,5,20,0,0,1117,1115,1,0,0,0,1117,1116,1,0,0,0,1118,1119,1,0,
        0,0,1119,1120,5,14,0,0,1120,143,1,0,0,0,1121,1124,5,62,0,0,1122,
        1123,5,9,0,0,1123,1125,7,5,0,0,1124,1122,1,0,0,0,1124,1125,1,0,0,
        0,1125,145,1,0,0,0,1126,1127,5,16,0,0,1127,1141,3,148,74,0,1128,
        1129,5,48,0,0,1129,1141,3,150,75,0,1130,1131,5,56,0,0,1131,1141,
        3,152,76,0,1132,1136,5,15,0,0,1133,1135,5,74,0,0,1134,1133,1,0,0,
        0,1135,1138,1,0,0,0,1136,1134,1,0,0,0,1136,1137,1,0,0,0,1137,1139,
        1,0,0,0,1138,1136,1,0,0,0,1139,1141,3,156,78,0,1140,1126,1,0,0,0,
        1140,1128,1,0,0,0,1140,1130,1,0,0,0,1140,1132,1,0,0,0,1141,147,1,
        0,0,0,1142,1143,3,4,2,0,1143,1144,5,19,0,0,1144,1145,3,10,5,0,1145,
        149,1,0,0,0,1146,1147,3,4,2,0,1147,1148,5,19,0,0,1148,1149,3,10,
        5,0,1149,151,1,0,0,0,1150,1153,3,154,77,0,1151,1152,5,19,0,0,1152,
        1154,3,10,5,0,1153,1151,1,0,0,0,1153,1154,1,0,0,0,1154,153,1,0,0,
        0,1155,1157,5,62,0,0,1156,1158,3,92,46,0,1157,1156,1,0,0,0,1157,
        1158,1,0,0,0,1158,1159,1,0,0,0,1159,1160,3,98,49,0,1160,155,1,0,
        0,0,1161,1163,5,62,0,0,1162,1164,3,90,45,0,1163,1162,1,0,0,0,1163,
        1164,1,0,0,0,1164,1167,1,0,0,0,1165,1166,5,45,0,0,1166,1168,3,10,
        5,0,1167,1165,1,0,0,0,1167,1168,1,0,0,0,1168,1171,1,0,0,0,1169,1170,
        5,46,0,0,1170,1172,3,10,5,0,1171,1169,1,0,0,0,1171,1172,1,0,0,0,
        1172,157,1,0,0,0,1173,1174,5,16,0,0,1174,1178,3,162,81,0,1175,1176,
        5,48,0,0,1176,1178,3,164,82,0,1177,1173,1,0,0,0,1177,1175,1,0,0,
        0,1178,159,1,0,0,0,1179,1192,3,158,79,0,1180,1181,5,56,0,0,1181,
        1192,3,166,83,0,1182,1186,5,15,0,0,1183,1185,5,74,0,0,1184,1183,
        1,0,0,0,1185,1188,1,0,0,0,1186,1184,1,0,0,0,1186,1187,1,0,0,0,1187,
        1189,1,0,0,0,1188,1186,1,0,0,0,1189,1192,3,168,84,0,1190,1192,3,
        170,85,0,1191,1179,1,0,0,0,1191,1180,1,0,0,0,1191,1182,1,0,0,0,1191,
        1190,1,0,0,0,1192,161,1,0,0,0,1193,1198,3,82,41,0,1194,1195,5,4,
        0,0,1195,1197,3,82,41,0,1196,1194,1,0,0,0,1197,1200,1,0,0,0,1198,
        1196,1,0,0,0,1198,1199,1,0,0,0,1199,1203,1,0,0,0,1200,1198,1,0,0,
        0,1201,1202,5,19,0,0,1202,1204,3,10,5,0,1203,1201,1,0,0,0,1203,1204,
        1,0,0,0,1204,1205,1,0,0,0,1205,1206,5,34,0,0,1206,1207,3,38,19,0,
        1207,163,1,0,0,0,1208,1216,3,162,81,0,1209,1210,3,4,2,0,1210,1211,
        5,19,0,0,1211,1212,3,10,5,0,1212,1213,5,34,0,0,1213,1214,5,20,0,
        0,1214,1216,1,0,0,0,1215,1208,1,0,0,0,1215,1209,1,0,0,0,1216,165,
        1,0,0,0,1217,1220,3,154,77,0,1218,1219,5,19,0,0,1219,1221,3,10,5,
        0,1220,1218,1,0,0,0,1220,1221,1,0,0,0,1221,1222,1,0,0,0,1222,1223,
        5,34,0,0,1223,1224,3,38,19,0,1224,1245,1,0,0,0,1225,1227,3,154,77,
        0,1226,1228,5,74,0,0,1227,1226,1,0,0,0,1227,1228,1,0,0,0,1228,1229,
        1,0,0,0,1229,1230,5,13,0,0,1230,1231,3,62,31,0,1231,1232,5,14,0,
        0,1232,1245,1,0,0,0,1233,1234,5,5,0,0,1234,1235,3,100,50,0,1235,
        1242,3,98,49,0,1236,1237,5,34,0,0,1237,1243,3,196,98,0,1238,1240,
        5,74,0,0,1239,1238,1,0,0,0,1239,1240,1,0,0,0,1240,1241,1,0,0,0,1241,
        1243,3,198,99,0,1242,1236,1,0,0,0,1242,1239,1,0,0,0,1243,1245,1,
        0,0,0,1244,1217,1,0,0,0,1244,1225,1,0,0,0,1244,1233,1,0,0,0,1245,
        167,1,0,0,0,1246,1248,5,62,0,0,1247,1249,3,90,45,0,1248,1247,1,0,
        0,0,1248,1249,1,0,0,0,1249,1250,1,0,0,0,1250,1251,5,34,0,0,1251,
        1252,3,10,5,0,1252,169,1,0,0,0,1253,1255,5,42,0,0,1254,1253,1,0,
        0,0,1254,1255,1,0,0,0,1255,1256,1,0,0,0,1256,1257,5,57,0,0,1257,
        1266,3,172,86,0,1258,1260,5,42,0,0,1259,1258,1,0,0,0,1259,1260,1,
        0,0,0,1260,1261,1,0,0,0,1261,1262,5,58,0,0,1262,1266,3,176,88,0,
        1263,1264,5,59,0,0,1264,1266,3,174,87,0,1265,1254,1,0,0,0,1265,1259,
        1,0,0,0,1265,1263,1,0,0,0,1266,171,1,0,0,0,1267,1269,5,62,0,0,1268,
        1270,3,90,45,0,1269,1268,1,0,0,0,1269,1270,1,0,0,0,1270,1274,1,0,
        0,0,1271,1273,3,130,65,0,1272,1271,1,0,0,0,1273,1276,1,0,0,0,1274,
        1272,1,0,0,0,1274,1275,1,0,0,0,1275,1278,1,0,0,0,1276,1274,1,0,0,
        0,1277,1279,3,124,62,0,1278,1277,1,0,0,0,1278,1279,1,0,0,0,1279,
        1280,1,0,0,0,1280,1281,3,108,54,0,1281,1282,3,178,89,0,1282,173,
        1,0,0,0,1283,1285,5,62,0,0,1284,1286,3,90,45,0,1285,1284,1,0,0,0,
        1285,1286,1,0,0,0,1286,1287,1,0,0,0,1287,1288,3,180,90,0,1288,175,
        1,0,0,0,1289,1290,5,62,0,0,1290,1291,3,178,89,0,1291,177,1,0,0,0,
        1292,1293,5,60,0,0,1293,1301,3,182,91,0,1294,1296,5,60,0,0,1295,
        1294,1,0,0,0,1295,1296,1,0,0,0,1296,1297,1,0,0,0,1297,1299,3,132,
        66,0,1298,1295,1,0,0,0,1298,1299,1,0,0,0,1299,1301,1,0,0,0,1300,
        1292,1,0,0,0,1300,1298,1,0,0,0,1301,179,1,0,0,0,1302,1303,5,60,0,
        0,1303,1311,3,184,92,0,1304,1306,5,60,0,0,1305,1304,1,0,0,0,1305,
        1306,1,0,0,0,1306,1307,1,0,0,0,1307,1309,3,132,66,0,1308,1305,1,
        0,0,0,1308,1309,1,0,0,0,1309,1311,1,0,0,0,1310,1302,1,0,0,0,1310,
        1308,1,0,0,0,1311,181,1,0,0,0,1312,1314,3,192,96,0,1313,1312,1,0,
        0,0,1313,1314,1,0,0,0,1314,1315,1,0,0,0,1315,1317,3,186,93,0,1316,
        1318,3,132,66,0,1317,1316,1,0,0,0,1317,1318,1,0,0,0,1318,183,1,0,
        0,0,1319,1321,3,192,96,0,1320,1319,1,0,0,0,1320,1321,1,0,0,0,1321,
        1322,1,0,0,0,1322,1324,3,188,94,0,1323,1325,3,132,66,0,1324,1323,
        1,0,0,0,1324,1325,1,0,0,0,1325,185,1,0,0,0,1326,1331,3,190,95,0,
        1327,1328,5,17,0,0,1328,1330,3,22,11,0,1329,1327,1,0,0,0,1330,1333,
        1,0,0,0,1331,1329,1,0,0,0,1331,1332,1,0,0,0,1332,187,1,0,0,0,1333,
        1331,1,0,0,0,1334,1339,3,22,11,0,1335,1336,5,17,0,0,1336,1338,3,
        22,11,0,1337,1335,1,0,0,0,1338,1341,1,0,0,0,1339,1337,1,0,0,0,1339,
        1340,1,0,0,0,1340,189,1,0,0,0,1341,1339,1,0,0,0,1342,1346,3,22,11,
        0,1343,1345,3,56,28,0,1344,1343,1,0,0,0,1345,1348,1,0,0,0,1346,1344,
        1,0,0,0,1346,1347,1,0,0,0,1347,191,1,0,0,0,1348,1346,1,0,0,0,1349,
        1351,5,13,0,0,1350,1352,3,194,97,0,1351,1350,1,0,0,0,1352,1353,1,
        0,0,0,1353,1351,1,0,0,0,1353,1354,1,0,0,0,1354,1355,1,0,0,0,1355,
        1356,5,14,0,0,1356,1357,5,17,0,0,1357,193,1,0,0,0,1358,1360,3,128,
        64,0,1359,1361,5,74,0,0,1360,1359,1,0,0,0,1360,1361,1,0,0,0,1361,
        1363,1,0,0,0,1362,1358,1,0,0,0,1363,1366,1,0,0,0,1364,1362,1,0,0,
        0,1364,1365,1,0,0,0,1365,1370,1,0,0,0,1366,1364,1,0,0,0,1367,1369,
        3,120,60,0,1368,1367,1,0,0,0,1369,1372,1,0,0,0,1370,1368,1,0,0,0,
        1370,1371,1,0,0,0,1371,1373,1,0,0,0,1372,1370,1,0,0,0,1373,1374,
        3,158,79,0,1374,195,1,0,0,0,1375,1378,3,200,100,0,1376,1378,3,198,
        99,0,1377,1375,1,0,0,0,1377,1376,1,0,0,0,1378,197,1,0,0,0,1379,1380,
        5,13,0,0,1380,1384,3,200,100,0,1381,1383,3,64,32,0,1382,1381,1,0,
        0,0,1383,1386,1,0,0,0,1384,1382,1,0,0,0,1384,1385,1,0,0,0,1385,1387,
        1,0,0,0,1386,1384,1,0,0,0,1387,1388,5,14,0,0,1388,199,1,0,0,0,1389,
        1391,5,5,0,0,1390,1392,3,56,28,0,1391,1390,1,0,0,0,1392,1393,1,0,
        0,0,1393,1391,1,0,0,0,1393,1394,1,0,0,0,1394,201,1,0,0,0,1395,1397,
        3,204,102,0,1396,1395,1,0,0,0,1397,1398,1,0,0,0,1398,1396,1,0,0,
        0,1398,1399,1,0,0,0,1399,203,1,0,0,0,1400,1402,3,128,64,0,1401,1403,
        5,74,0,0,1402,1401,1,0,0,0,1402,1403,1,0,0,0,1403,1405,1,0,0,0,1404,
        1400,1,0,0,0,1405,1408,1,0,0,0,1406,1404,1,0,0,0,1406,1407,1,0,0,
        0,1407,1412,1,0,0,0,1408,1406,1,0,0,0,1409,1411,3,120,60,0,1410,
        1409,1,0,0,0,1411,1414,1,0,0,0,1412,1410,1,0,0,0,1412,1413,1,0,0,
        0,1413,1415,1,0,0,0,1414,1412,1,0,0,0,1415,1420,3,170,85,0,1416,
        1420,3,138,69,0,1417,1420,3,206,103,0,1418,1420,3,208,104,0,1419,
        1406,1,0,0,0,1419,1416,1,0,0,0,1419,1417,1,0,0,0,1419,1418,1,0,0,
        0,1420,205,1,0,0,0,1421,1422,5,61,0,0,1422,1424,3,2,1,0,1423,1425,
        5,74,0,0,1424,1423,1,0,0,0,1424,1425,1,0,0,0,1425,1426,1,0,0,0,1426,
        1427,5,13,0,0,1427,1428,3,202,101,0,1428,1429,5,14,0,0,1429,207,
        1,0,0,0,1430,1431,5,61,0,0,1431,1432,5,58,0,0,1432,1433,3,176,88,
        0,1433,209,1,0,0,0,1434,1435,5,61,0,0,1435,1437,3,2,1,0,1436,1434,
        1,0,0,0,1437,1440,1,0,0,0,1438,1436,1,0,0,0,1438,1439,1,0,0,0,1439,
        1441,1,0,0,0,1440,1438,1,0,0,0,1441,1442,3,202,101,0,1442,1443,5,
        0,0,1,1443,211,1,0,0,0,208,213,217,225,232,240,247,252,256,258,265,
        278,280,289,292,295,302,310,317,325,329,332,338,345,351,358,360,
        372,376,382,389,399,404,408,412,417,426,432,441,450,454,472,475,
        483,488,490,494,506,514,520,527,531,539,544,548,553,555,560,563,
        571,581,585,591,596,598,606,618,621,624,629,633,635,645,650,653,
        659,663,669,675,680,685,689,693,698,703,713,715,721,726,739,746,
        751,754,760,765,768,776,779,786,790,798,801,806,810,818,829,837,
        841,847,851,855,861,868,874,878,885,888,892,901,907,913,917,925,
        930,934,941,944,948,957,963,969,973,980,988,996,1001,1007,1018,1026,
        1030,1035,1042,1046,1052,1058,1062,1068,1073,1078,1086,1094,1102,
        1104,1112,1117,1124,1136,1140,1153,1157,1163,1167,1171,1177,1186,
        1191,1198,1203,1215,1220,1227,1239,1242,1244,1248,1254,1259,1265,
        1269,1274,1278,1285,1295,1298,1300,1305,1308,1310,1313,1317,1320,
        1324,1331,1339,1346,1353,1360,1364,1370,1377,1384,1393,1398,1402,
        1406,1412,1419,1424,1438
    ]

class ScalaParser ( Parser ):

    grammarFileName = "Scala.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'-'", "'null'", "'.'", "','", "'this'", 
                     "'super'", "'['", "']'", "'=>'", "'('", "')'", "'forSome'", 
                     "'{'", "'}'", "'type'", "'val'", "'with'", "'#'", "':'", 
                     "'_'", "'*'", "'implicit'", "'if'", "'else'", "'while'", 
                     "'try'", "'catch'", "'finally'", "'do'", "'for'", "'yield'", 
                     "'throw'", "'return'", "'='", "'match'", "'+'", "'~'", 
                     "'!'", "'new'", "'lazy'", "'<-'", "'case'", "'|'", 
                     "'@'", "'>:'", "'<:'", "'<%'", "'var'", "'override'", 
                     "'abstract'", "'final'", "'sealed'", "'private'", "'protected'", 
                     "'import'", "'def'", "'class'", "'object'", "'trait'", 
                     "'extends'", "'package'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "Id", "BooleanLiteral", 
                      "CharacterLiteral", "SymbolLiteral", "IntegerLiteral", 
                      "StringLiteral", "FloatingPointLiteral", "Varid", 
                      "BoundVarid", "Paren", "Delim", "Semi", "NL", "NEWLINE", 
                      "WS", "COMMENT", "LINE_COMMENT", "ANY" ]

    RULE_literal = 0
    RULE_qualId = 1
    RULE_ids = 2
    RULE_stableId = 3
    RULE_classQualifier = 4
    RULE_type_ = 5
    RULE_functionArgTypes = 6
    RULE_existentialClause = 7
    RULE_existentialDcl = 8
    RULE_infixType = 9
    RULE_compoundType = 10
    RULE_annotType = 11
    RULE_simpleType = 12
    RULE_typeArgs = 13
    RULE_types = 14
    RULE_refinement = 15
    RULE_refineStat = 16
    RULE_typePat = 17
    RULE_ascription = 18
    RULE_expr = 19
    RULE_expr1 = 20
    RULE_prefixDef = 21
    RULE_postfixExpr = 22
    RULE_infixExpr = 23
    RULE_prefixExpr = 24
    RULE_simpleExpr = 25
    RULE_simpleExpr1 = 26
    RULE_exprs = 27
    RULE_argumentExprs = 28
    RULE_args = 29
    RULE_blockExpr = 30
    RULE_block = 31
    RULE_blockStat = 32
    RULE_resultExpr = 33
    RULE_enumerators = 34
    RULE_generator = 35
    RULE_caseClauses = 36
    RULE_caseClause = 37
    RULE_guard_ = 38
    RULE_pattern = 39
    RULE_pattern1 = 40
    RULE_pattern2 = 41
    RULE_pattern3 = 42
    RULE_simplePattern = 43
    RULE_patterns = 44
    RULE_typeParamClause = 45
    RULE_funTypeParamClause = 46
    RULE_variantTypeParam = 47
    RULE_typeParam = 48
    RULE_paramClauses = 49
    RULE_paramClause = 50
    RULE_params = 51
    RULE_param = 52
    RULE_paramType = 53
    RULE_classParamClauses = 54
    RULE_classParamClause = 55
    RULE_classParams = 56
    RULE_classParam = 57
    RULE_bindings = 58
    RULE_binding = 59
    RULE_modifier = 60
    RULE_localModifier = 61
    RULE_accessModifier = 62
    RULE_accessQualifier = 63
    RULE_annotation = 64
    RULE_constrAnnotation = 65
    RULE_templateBody = 66
    RULE_templateStat = 67
    RULE_selfType = 68
    RULE_import_ = 69
    RULE_importExpr = 70
    RULE_importSelectors = 71
    RULE_importSelector = 72
    RULE_dcl = 73
    RULE_valDcl = 74
    RULE_varDcl = 75
    RULE_funDcl = 76
    RULE_funSig = 77
    RULE_typeDcl = 78
    RULE_patVarDef = 79
    RULE_def_ = 80
    RULE_patDef = 81
    RULE_varDef = 82
    RULE_funDef = 83
    RULE_typeDef = 84
    RULE_tmplDef = 85
    RULE_classDef = 86
    RULE_traitDef = 87
    RULE_objectDef = 88
    RULE_classTemplateOpt = 89
    RULE_traitTemplateOpt = 90
    RULE_classTemplate = 91
    RULE_traitTemplate = 92
    RULE_classParents = 93
    RULE_traitParents = 94
    RULE_constr = 95
    RULE_earlyDefs = 96
    RULE_earlyDef = 97
    RULE_constrExpr = 98
    RULE_constrBlock = 99
    RULE_selfInvocation = 100
    RULE_topStatSeq = 101
    RULE_topStat = 102
    RULE_packaging = 103
    RULE_packageObject = 104
    RULE_compilationUnit = 105

    ruleNames =  [ "literal", "qualId", "ids", "stableId", "classQualifier", 
                   "type_", "functionArgTypes", "existentialClause", "existentialDcl", 
                   "infixType", "compoundType", "annotType", "simpleType", 
                   "typeArgs", "types", "refinement", "refineStat", "typePat", 
                   "ascription", "expr", "expr1", "prefixDef", "postfixExpr", 
                   "infixExpr", "prefixExpr", "simpleExpr", "simpleExpr1", 
                   "exprs", "argumentExprs", "args", "blockExpr", "block", 
                   "blockStat", "resultExpr", "enumerators", "generator", 
                   "caseClauses", "caseClause", "guard_", "pattern", "pattern1", 
                   "pattern2", "pattern3", "simplePattern", "patterns", 
                   "typeParamClause", "funTypeParamClause", "variantTypeParam", 
                   "typeParam", "paramClauses", "paramClause", "params", 
                   "param", "paramType", "classParamClauses", "classParamClause", 
                   "classParams", "classParam", "bindings", "binding", "modifier", 
                   "localModifier", "accessModifier", "accessQualifier", 
                   "annotation", "constrAnnotation", "templateBody", "templateStat", 
                   "selfType", "import_", "importExpr", "importSelectors", 
                   "importSelector", "dcl", "valDcl", "varDcl", "funDcl", 
                   "funSig", "typeDcl", "patVarDef", "def_", "patDef", "varDef", 
                   "funDef", "typeDef", "tmplDef", "classDef", "traitDef", 
                   "objectDef", "classTemplateOpt", "traitTemplateOpt", 
                   "classTemplate", "traitTemplate", "classParents", "traitParents", 
                   "constr", "earlyDefs", "earlyDef", "constrExpr", "constrBlock", 
                   "selfInvocation", "topStatSeq", "topStat", "packaging", 
                   "packageObject", "compilationUnit" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    Id=62
    BooleanLiteral=63
    CharacterLiteral=64
    SymbolLiteral=65
    IntegerLiteral=66
    StringLiteral=67
    FloatingPointLiteral=68
    Varid=69
    BoundVarid=70
    Paren=71
    Delim=72
    Semi=73
    NL=74
    NEWLINE=75
    WS=76
    COMMENT=77
    LINE_COMMENT=78
    ANY=79

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.11.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IntegerLiteral(self):
            return self.getToken(ScalaParser.IntegerLiteral, 0)

        def FloatingPointLiteral(self):
            return self.getToken(ScalaParser.FloatingPointLiteral, 0)

        def BooleanLiteral(self):
            return self.getToken(ScalaParser.BooleanLiteral, 0)

        def CharacterLiteral(self):
            return self.getToken(ScalaParser.CharacterLiteral, 0)

        def StringLiteral(self):
            return self.getToken(ScalaParser.StringLiteral, 0)

        def SymbolLiteral(self):
            return self.getToken(ScalaParser.SymbolLiteral, 0)

        def getRuleIndex(self):
            return ScalaParser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteral" ):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)




    def literal(self):

        localctx = ScalaParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_literal)
        self._la = 0 # Token type
        try:
            self.state = 225
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 213
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==1:
                    self.state = 212
                    self.match(ScalaParser.T__0)


                self.state = 215
                self.match(ScalaParser.IntegerLiteral)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 217
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==1:
                    self.state = 216
                    self.match(ScalaParser.T__0)


                self.state = 219
                self.match(ScalaParser.FloatingPointLiteral)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 220
                self.match(ScalaParser.BooleanLiteral)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 221
                self.match(ScalaParser.CharacterLiteral)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 222
                self.match(ScalaParser.StringLiteral)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 223
                self.match(ScalaParser.SymbolLiteral)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 224
                self.match(ScalaParser.T__1)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QualIdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self, i:int=None):
            if i is None:
                return self.getTokens(ScalaParser.Id)
            else:
                return self.getToken(ScalaParser.Id, i)

        def getRuleIndex(self):
            return ScalaParser.RULE_qualId

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQualId" ):
                listener.enterQualId(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQualId" ):
                listener.exitQualId(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQualId" ):
                return visitor.visitQualId(self)
            else:
                return visitor.visitChildren(self)




    def qualId(self):

        localctx = ScalaParser.QualIdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_qualId)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 227
            self.match(ScalaParser.Id)
            self.state = 232
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==3:
                self.state = 228
                self.match(ScalaParser.T__2)
                self.state = 229
                self.match(ScalaParser.Id)
                self.state = 234
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self, i:int=None):
            if i is None:
                return self.getTokens(ScalaParser.Id)
            else:
                return self.getToken(ScalaParser.Id, i)

        def getRuleIndex(self):
            return ScalaParser.RULE_ids

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIds" ):
                listener.enterIds(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIds" ):
                listener.exitIds(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIds" ):
                return visitor.visitIds(self)
            else:
                return visitor.visitChildren(self)




    def ids(self):

        localctx = ScalaParser.IdsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_ids)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 235
            self.match(ScalaParser.Id)
            self.state = 240
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 236
                self.match(ScalaParser.T__3)
                self.state = 237
                self.match(ScalaParser.Id)
                self.state = 242
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StableIdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self, i:int=None):
            if i is None:
                return self.getTokens(ScalaParser.Id)
            else:
                return self.getToken(ScalaParser.Id, i)

        def classQualifier(self):
            return self.getTypedRuleContext(ScalaParser.ClassQualifierContext,0)


        def stableId(self):
            return self.getTypedRuleContext(ScalaParser.StableIdContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_stableId

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStableId" ):
                listener.enterStableId(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStableId" ):
                listener.exitStableId(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStableId" ):
                return visitor.visitStableId(self)
            else:
                return visitor.visitChildren(self)



    def stableId(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = ScalaParser.StableIdContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 6
        self.enterRecursionRule(localctx, 6, self.RULE_stableId, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 258
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.state = 244
                self.match(ScalaParser.Id)
                pass

            elif la_ == 2:
                self.state = 247
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==62:
                    self.state = 245
                    self.match(ScalaParser.Id)
                    self.state = 246
                    self.match(ScalaParser.T__2)


                self.state = 256
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [5]:
                    self.state = 249
                    self.match(ScalaParser.T__4)
                    pass
                elif token in [6]:
                    self.state = 250
                    self.match(ScalaParser.T__5)
                    self.state = 252
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==7:
                        self.state = 251
                        self.classQualifier()


                    self.state = 254
                    self.match(ScalaParser.T__2)
                    self.state = 255
                    self.match(ScalaParser.Id)
                    pass
                else:
                    raise NoViableAltException(self)

                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 265
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = ScalaParser.StableIdContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_stableId)
                    self.state = 260
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 261
                    self.match(ScalaParser.T__2)
                    self.state = 262
                    self.match(ScalaParser.Id) 
                self.state = 267
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ClassQualifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def getRuleIndex(self):
            return ScalaParser.RULE_classQualifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassQualifier" ):
                listener.enterClassQualifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassQualifier" ):
                listener.exitClassQualifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassQualifier" ):
                return visitor.visitClassQualifier(self)
            else:
                return visitor.visitChildren(self)




    def classQualifier(self):

        localctx = ScalaParser.ClassQualifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_classQualifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 268
            self.match(ScalaParser.T__6)
            self.state = 269
            self.match(ScalaParser.Id)
            self.state = 270
            self.match(ScalaParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionArgTypes(self):
            return self.getTypedRuleContext(ScalaParser.FunctionArgTypesContext,0)


        def type_(self):
            return self.getTypedRuleContext(ScalaParser.Type_Context,0)


        def infixType(self):
            return self.getTypedRuleContext(ScalaParser.InfixTypeContext,0)


        def existentialClause(self):
            return self.getTypedRuleContext(ScalaParser.ExistentialClauseContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_type_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_" ):
                listener.enterType_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_" ):
                listener.exitType_(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_" ):
                return visitor.visitType_(self)
            else:
                return visitor.visitChildren(self)




    def type_(self):

        localctx = ScalaParser.Type_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_type_)
        self._la = 0 # Token type
        try:
            self.state = 280
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 272
                self.functionArgTypes()
                self.state = 273
                self.match(ScalaParser.T__8)
                self.state = 274
                self.type_()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 276
                self.infixType()
                self.state = 278
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==12:
                    self.state = 277
                    self.existentialClause()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionArgTypesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def infixType(self):
            return self.getTypedRuleContext(ScalaParser.InfixTypeContext,0)


        def paramType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.ParamTypeContext)
            else:
                return self.getTypedRuleContext(ScalaParser.ParamTypeContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_functionArgTypes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionArgTypes" ):
                listener.enterFunctionArgTypes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionArgTypes" ):
                listener.exitFunctionArgTypes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionArgTypes" ):
                return visitor.visitFunctionArgTypes(self)
            else:
                return visitor.visitChildren(self)




    def functionArgTypes(self):

        localctx = ScalaParser.FunctionArgTypesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_functionArgTypes)
        self._la = 0 # Token type
        try:
            self.state = 295
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 282
                self.infixType()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 283
                self.match(ScalaParser.T__9)
                self.state = 292
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((_la) & ~0x3f) == 0 and ((1 << _la) & 4611686018427397728) != 0 or _la==74:
                    self.state = 284
                    self.paramType()
                    self.state = 289
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==4:
                        self.state = 285
                        self.match(ScalaParser.T__3)
                        self.state = 286
                        self.paramType()
                        self.state = 291
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 294
                self.match(ScalaParser.T__10)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExistentialClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def existentialDcl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.ExistentialDclContext)
            else:
                return self.getTypedRuleContext(ScalaParser.ExistentialDclContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_existentialClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExistentialClause" ):
                listener.enterExistentialClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExistentialClause" ):
                listener.exitExistentialClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExistentialClause" ):
                return visitor.visitExistentialClause(self)
            else:
                return visitor.visitChildren(self)




    def existentialClause(self):

        localctx = ScalaParser.ExistentialClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_existentialClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 297
            self.match(ScalaParser.T__11)
            self.state = 298
            self.match(ScalaParser.T__12)
            self.state = 300 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 299
                self.existentialDcl()
                self.state = 302 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==15 or _la==16):
                    break

            self.state = 304
            self.match(ScalaParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExistentialDclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeDcl(self):
            return self.getTypedRuleContext(ScalaParser.TypeDclContext,0)


        def valDcl(self):
            return self.getTypedRuleContext(ScalaParser.ValDclContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_existentialDcl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExistentialDcl" ):
                listener.enterExistentialDcl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExistentialDcl" ):
                listener.exitExistentialDcl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExistentialDcl" ):
                return visitor.visitExistentialDcl(self)
            else:
                return visitor.visitChildren(self)




    def existentialDcl(self):

        localctx = ScalaParser.ExistentialDclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_existentialDcl)
        try:
            self.state = 310
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [15]:
                self.enterOuterAlt(localctx, 1)
                self.state = 306
                self.match(ScalaParser.T__14)
                self.state = 307
                self.typeDcl()
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 2)
                self.state = 308
                self.match(ScalaParser.T__15)
                self.state = 309
                self.valDcl()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InfixTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def compoundType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.CompoundTypeContext)
            else:
                return self.getTypedRuleContext(ScalaParser.CompoundTypeContext,i)


        def Id(self, i:int=None):
            if i is None:
                return self.getTokens(ScalaParser.Id)
            else:
                return self.getToken(ScalaParser.Id, i)

        def getRuleIndex(self):
            return ScalaParser.RULE_infixType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInfixType" ):
                listener.enterInfixType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInfixType" ):
                listener.exitInfixType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInfixType" ):
                return visitor.visitInfixType(self)
            else:
                return visitor.visitChildren(self)




    def infixType(self):

        localctx = ScalaParser.InfixTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_infixType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 312
            self.compoundType()
            self.state = 317
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,17,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 313
                    self.match(ScalaParser.Id)
                    self.state = 314
                    self.compoundType() 
                self.state = 319
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,17,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompoundTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.AnnotTypeContext)
            else:
                return self.getTypedRuleContext(ScalaParser.AnnotTypeContext,i)


        def refinement(self):
            return self.getTypedRuleContext(ScalaParser.RefinementContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_compoundType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompoundType" ):
                listener.enterCompoundType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompoundType" ):
                listener.exitCompoundType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompoundType" ):
                return visitor.visitCompoundType(self)
            else:
                return visitor.visitChildren(self)




    def compoundType(self):

        localctx = ScalaParser.CompoundTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_compoundType)
        self._la = 0 # Token type
        try:
            self.state = 332
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5, 6, 10, 62]:
                self.enterOuterAlt(localctx, 1)
                self.state = 320
                self.annotType()
                self.state = 325
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==17:
                    self.state = 321
                    self.match(ScalaParser.T__16)
                    self.state = 322
                    self.annotType()
                    self.state = 327
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 329
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
                if la_ == 1:
                    self.state = 328
                    self.refinement()


                pass
            elif token in [13, 74]:
                self.enterOuterAlt(localctx, 2)
                self.state = 331
                self.refinement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnnotTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleType(self):
            return self.getTypedRuleContext(ScalaParser.SimpleTypeContext,0)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ScalaParser.AnnotationContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_annotType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotType" ):
                listener.enterAnnotType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotType" ):
                listener.exitAnnotType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnnotType" ):
                return visitor.visitAnnotType(self)
            else:
                return visitor.visitChildren(self)




    def annotType(self):

        localctx = ScalaParser.AnnotTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_annotType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 334
            self.simpleType(0)
            self.state = 338
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,21,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 335
                    self.annotation() 
                self.state = 340
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,21,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stableId(self):
            return self.getTypedRuleContext(ScalaParser.StableIdContext,0)


        def types(self):
            return self.getTypedRuleContext(ScalaParser.TypesContext,0)


        def simpleType(self):
            return self.getTypedRuleContext(ScalaParser.SimpleTypeContext,0)


        def typeArgs(self):
            return self.getTypedRuleContext(ScalaParser.TypeArgsContext,0)


        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def getRuleIndex(self):
            return ScalaParser.RULE_simpleType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleType" ):
                listener.enterSimpleType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleType" ):
                listener.exitSimpleType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleType" ):
                return visitor.visitSimpleType(self)
            else:
                return visitor.visitChildren(self)



    def simpleType(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = ScalaParser.SimpleTypeContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 24
        self.enterRecursionRule(localctx, 24, self.RULE_simpleType, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 351
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5, 6, 62]:
                self.state = 342
                self.stableId(0)
                self.state = 345
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
                if la_ == 1:
                    self.state = 343
                    self.match(ScalaParser.T__2)
                    self.state = 344
                    self.match(ScalaParser.T__14)


                pass
            elif token in [10]:
                self.state = 347
                self.match(ScalaParser.T__9)
                self.state = 348
                self.types()
                self.state = 349
                self.match(ScalaParser.T__10)
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 360
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,25,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 358
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
                    if la_ == 1:
                        localctx = ScalaParser.SimpleTypeContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_simpleType)
                        self.state = 353
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 354
                        self.typeArgs()
                        pass

                    elif la_ == 2:
                        localctx = ScalaParser.SimpleTypeContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_simpleType)
                        self.state = 355
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 356
                        self.match(ScalaParser.T__17)
                        self.state = 357
                        self.match(ScalaParser.Id)
                        pass

             
                self.state = 362
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,25,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class TypeArgsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def types(self):
            return self.getTypedRuleContext(ScalaParser.TypesContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_typeArgs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeArgs" ):
                listener.enterTypeArgs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeArgs" ):
                listener.exitTypeArgs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeArgs" ):
                return visitor.visitTypeArgs(self)
            else:
                return visitor.visitChildren(self)




    def typeArgs(self):

        localctx = ScalaParser.TypeArgsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_typeArgs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 363
            self.match(ScalaParser.T__6)
            self.state = 364
            self.types()
            self.state = 365
            self.match(ScalaParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.Type_Context)
            else:
                return self.getTypedRuleContext(ScalaParser.Type_Context,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_types

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypes" ):
                listener.enterTypes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypes" ):
                listener.exitTypes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypes" ):
                return visitor.visitTypes(self)
            else:
                return visitor.visitChildren(self)




    def types(self):

        localctx = ScalaParser.TypesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_types)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 367
            self.type_()
            self.state = 372
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 368
                self.match(ScalaParser.T__3)
                self.state = 369
                self.type_()
                self.state = 374
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RefinementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NL(self):
            return self.getToken(ScalaParser.NL, 0)

        def refineStat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.RefineStatContext)
            else:
                return self.getTypedRuleContext(ScalaParser.RefineStatContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_refinement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRefinement" ):
                listener.enterRefinement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRefinement" ):
                listener.exitRefinement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRefinement" ):
                return visitor.visitRefinement(self)
            else:
                return visitor.visitChildren(self)




    def refinement(self):

        localctx = ScalaParser.RefinementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_refinement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 376
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==74:
                self.state = 375
                self.match(ScalaParser.NL)


            self.state = 378
            self.match(ScalaParser.T__12)
            self.state = 380 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 379
                self.refineStat()
                self.state = 382 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((_la) & ~0x3f) == 0 and ((1 << _la) & 72339069014736896) != 0):
                    break

            self.state = 384
            self.match(ScalaParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RefineStatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dcl(self):
            return self.getTypedRuleContext(ScalaParser.DclContext,0)


        def typeDef(self):
            return self.getTypedRuleContext(ScalaParser.TypeDefContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_refineStat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRefineStat" ):
                listener.enterRefineStat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRefineStat" ):
                listener.exitRefineStat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRefineStat" ):
                return visitor.visitRefineStat(self)
            else:
                return visitor.visitChildren(self)




    def refineStat(self):

        localctx = ScalaParser.RefineStatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_refineStat)
        try:
            self.state = 389
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 386
                self.dcl()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 387
                self.match(ScalaParser.T__14)
                self.state = 388
                self.typeDef()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypePatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(ScalaParser.Type_Context,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_typePat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypePat" ):
                listener.enterTypePat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypePat" ):
                listener.exitTypePat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypePat" ):
                return visitor.visitTypePat(self)
            else:
                return visitor.visitChildren(self)




    def typePat(self):

        localctx = ScalaParser.TypePatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_typePat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 391
            self.type_()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AscriptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def infixType(self):
            return self.getTypedRuleContext(ScalaParser.InfixTypeContext,0)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ScalaParser.AnnotationContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_ascription

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAscription" ):
                listener.enterAscription(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAscription" ):
                listener.exitAscription(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAscription" ):
                return visitor.visitAscription(self)
            else:
                return visitor.visitChildren(self)




    def ascription(self):

        localctx = ScalaParser.AscriptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_ascription)
        try:
            self.state = 404
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 393
                self.match(ScalaParser.T__18)
                self.state = 394
                self.infixType()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 395
                self.match(ScalaParser.T__18)
                self.state = 397 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 396
                        self.annotation()

                    else:
                        raise NoViableAltException(self)
                    self.state = 399 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,30,self._ctx)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 401
                self.match(ScalaParser.T__18)
                self.state = 402
                self.match(ScalaParser.T__19)
                self.state = 403
                self.match(ScalaParser.T__20)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(ScalaParser.ExprContext,0)


        def bindings(self):
            return self.getTypedRuleContext(ScalaParser.BindingsContext,0)


        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def expr1(self):
            return self.getTypedRuleContext(ScalaParser.Expr1Context,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr" ):
                listener.enterExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr" ):
                listener.exitExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr" ):
                return visitor.visitExpr(self)
            else:
                return visitor.visitChildren(self)




    def expr(self):

        localctx = ScalaParser.ExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_expr)
        self._la = 0 # Token type
        try:
            self.state = 417
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 412
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [10]:
                    self.state = 406
                    self.bindings()
                    pass
                elif token in [22, 62]:
                    self.state = 408
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==22:
                        self.state = 407
                        self.match(ScalaParser.T__21)


                    self.state = 410
                    self.match(ScalaParser.Id)
                    pass
                elif token in [20]:
                    self.state = 411
                    self.match(ScalaParser.T__19)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 414
                self.match(ScalaParser.T__8)
                self.state = 415
                self.expr()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 416
                self.expr1()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Expr1Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.ExprContext)
            else:
                return self.getTypedRuleContext(ScalaParser.ExprContext,i)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(ScalaParser.NL)
            else:
                return self.getToken(ScalaParser.NL, i)

        def enumerators(self):
            return self.getTypedRuleContext(ScalaParser.EnumeratorsContext,0)


        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def simpleExpr(self):
            return self.getTypedRuleContext(ScalaParser.SimpleExprContext,0)


        def simpleExpr1(self):
            return self.getTypedRuleContext(ScalaParser.SimpleExpr1Context,0)


        def argumentExprs(self):
            return self.getTypedRuleContext(ScalaParser.ArgumentExprsContext,0)


        def postfixExpr(self):
            return self.getTypedRuleContext(ScalaParser.PostfixExprContext,0)


        def ascription(self):
            return self.getTypedRuleContext(ScalaParser.AscriptionContext,0)


        def caseClauses(self):
            return self.getTypedRuleContext(ScalaParser.CaseClausesContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_expr1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr1" ):
                listener.enterExpr1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr1" ):
                listener.exitExpr1(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr1" ):
                return visitor.visitExpr1(self)
            else:
                return visitor.visitChildren(self)




    def expr1(self):

        localctx = ScalaParser.Expr1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_expr1)
        self._la = 0 # Token type
        try:
            self.state = 514
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 419
                self.match(ScalaParser.T__22)
                self.state = 420
                self.match(ScalaParser.T__9)
                self.state = 421
                self.expr()
                self.state = 422
                self.match(ScalaParser.T__10)
                self.state = 426
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==74:
                    self.state = 423
                    self.match(ScalaParser.NL)
                    self.state = 428
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 429
                self.expr()
                self.state = 432
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
                if la_ == 1:
                    self.state = 430
                    self.match(ScalaParser.T__23)
                    self.state = 431
                    self.expr()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 434
                self.match(ScalaParser.T__24)
                self.state = 435
                self.match(ScalaParser.T__9)
                self.state = 436
                self.expr()
                self.state = 437
                self.match(ScalaParser.T__10)
                self.state = 441
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==74:
                    self.state = 438
                    self.match(ScalaParser.NL)
                    self.state = 443
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 444
                self.expr()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 446
                self.match(ScalaParser.T__25)
                self.state = 447
                self.expr()
                self.state = 450
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
                if la_ == 1:
                    self.state = 448
                    self.match(ScalaParser.T__26)
                    self.state = 449
                    self.expr()


                self.state = 454
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
                if la_ == 1:
                    self.state = 452
                    self.match(ScalaParser.T__27)
                    self.state = 453
                    self.expr()


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 456
                self.match(ScalaParser.T__28)
                self.state = 457
                self.expr()
                self.state = 458
                self.match(ScalaParser.T__24)
                self.state = 459
                self.match(ScalaParser.T__9)
                self.state = 460
                self.expr()
                self.state = 461
                self.match(ScalaParser.T__10)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 463
                self.match(ScalaParser.T__29)
                self.state = 472
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [10]:
                    self.state = 464
                    self.match(ScalaParser.T__9)
                    self.state = 465
                    self.enumerators()
                    self.state = 466
                    self.match(ScalaParser.T__10)
                    pass
                elif token in [13]:
                    self.state = 468
                    self.match(ScalaParser.T__12)
                    self.state = 469
                    self.enumerators()
                    self.state = 470
                    self.match(ScalaParser.T__13)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 475
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 474
                    self.match(ScalaParser.T__30)


                self.state = 477
                self.expr()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 479
                self.match(ScalaParser.T__31)
                self.state = 480
                self.expr()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 481
                self.match(ScalaParser.T__32)
                self.state = 483
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
                if la_ == 1:
                    self.state = 482
                    self.expr()


                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 494
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
                if la_ == 1:
                    self.state = 490
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
                    if la_ == 1:
                        self.state = 485
                        self.simpleExpr()
                        pass

                    elif la_ == 2:
                        self.state = 486
                        self.simpleExpr1(0)
                        self.state = 488
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==20:
                            self.state = 487
                            self.match(ScalaParser.T__19)


                        pass


                    self.state = 492
                    self.match(ScalaParser.T__2)


                self.state = 496
                self.match(ScalaParser.Id)
                self.state = 497
                self.match(ScalaParser.T__33)
                self.state = 498
                self.expr()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 499
                self.simpleExpr1(0)
                self.state = 500
                self.argumentExprs()
                self.state = 501
                self.match(ScalaParser.T__33)
                self.state = 502
                self.expr()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 504
                self.postfixExpr()
                self.state = 506
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==19:
                    self.state = 505
                    self.ascription()


                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 508
                self.postfixExpr()
                self.state = 509
                self.match(ScalaParser.T__34)
                self.state = 510
                self.match(ScalaParser.T__12)
                self.state = 511
                self.caseClauses()
                self.state = 512
                self.match(ScalaParser.T__13)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrefixDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ScalaParser.RULE_prefixDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrefixDef" ):
                listener.enterPrefixDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrefixDef" ):
                listener.exitPrefixDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrefixDef" ):
                return visitor.visitPrefixDef(self)
            else:
                return visitor.visitChildren(self)




    def prefixDef(self):

        localctx = ScalaParser.PrefixDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_prefixDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 516
            _la = self._input.LA(1)
            if not(((_la) & ~0x3f) == 0 and ((1 << _la) & 481036337154) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PostfixExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def infixExpr(self):
            return self.getTypedRuleContext(ScalaParser.InfixExprContext,0)


        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def prefixDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.PrefixDefContext)
            else:
                return self.getTypedRuleContext(ScalaParser.PrefixDefContext,i)


        def simpleExpr1(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.SimpleExpr1Context)
            else:
                return self.getTypedRuleContext(ScalaParser.SimpleExpr1Context,i)


        def NL(self):
            return self.getToken(ScalaParser.NL, 0)

        def getRuleIndex(self):
            return ScalaParser.RULE_postfixExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPostfixExpr" ):
                listener.enterPostfixExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPostfixExpr" ):
                listener.exitPostfixExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPostfixExpr" ):
                return visitor.visitPostfixExpr(self)
            else:
                return visitor.visitChildren(self)




    def postfixExpr(self):

        localctx = ScalaParser.PostfixExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_postfixExpr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 518
            self.infixExpr(0)
            self.state = 520
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,48,self._ctx)
            if la_ == 1:
                self.state = 519
                self.match(ScalaParser.Id)


            self.state = 527
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,49,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 522
                    self.prefixDef()
                    self.state = 523
                    self.simpleExpr1(0) 
                self.state = 529
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,49,self._ctx)

            self.state = 531
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==74:
                self.state = 530
                self.match(ScalaParser.NL)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InfixExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def prefixExpr(self):
            return self.getTypedRuleContext(ScalaParser.PrefixExprContext,0)


        def infixExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.InfixExprContext)
            else:
                return self.getTypedRuleContext(ScalaParser.InfixExprContext,i)


        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def NL(self):
            return self.getToken(ScalaParser.NL, 0)

        def getRuleIndex(self):
            return ScalaParser.RULE_infixExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInfixExpr" ):
                listener.enterInfixExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInfixExpr" ):
                listener.exitInfixExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInfixExpr" ):
                return visitor.visitInfixExpr(self)
            else:
                return visitor.visitChildren(self)



    def infixExpr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = ScalaParser.InfixExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 46
        self.enterRecursionRule(localctx, 46, self.RULE_infixExpr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 534
            self.prefixExpr()
            self._ctx.stop = self._input.LT(-1)
            self.state = 544
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,52,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = ScalaParser.InfixExprContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_infixExpr)
                    self.state = 536
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 537
                    self.match(ScalaParser.Id)
                    self.state = 539
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==74:
                        self.state = 538
                        self.match(ScalaParser.NL)


                    self.state = 541
                    self.infixExpr(2) 
                self.state = 546
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,52,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class PrefixExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleExpr(self):
            return self.getTypedRuleContext(ScalaParser.SimpleExprContext,0)


        def simpleExpr1(self):
            return self.getTypedRuleContext(ScalaParser.SimpleExpr1Context,0)


        def prefixDef(self):
            return self.getTypedRuleContext(ScalaParser.PrefixDefContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_prefixExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrefixExpr" ):
                listener.enterPrefixExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrefixExpr" ):
                listener.exitPrefixExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrefixExpr" ):
                return visitor.visitPrefixExpr(self)
            else:
                return visitor.visitChildren(self)




    def prefixExpr(self):

        localctx = ScalaParser.PrefixExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_prefixExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 548
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,53,self._ctx)
            if la_ == 1:
                self.state = 547
                self.prefixDef()


            self.state = 555
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,55,self._ctx)
            if la_ == 1:
                self.state = 550
                self.simpleExpr()
                pass

            elif la_ == 2:
                self.state = 551
                self.simpleExpr1(0)
                self.state = 553
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
                if la_ == 1:
                    self.state = 552
                    self.match(ScalaParser.T__19)


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classTemplate(self):
            return self.getTypedRuleContext(ScalaParser.ClassTemplateContext,0)


        def templateBody(self):
            return self.getTypedRuleContext(ScalaParser.TemplateBodyContext,0)


        def blockExpr(self):
            return self.getTypedRuleContext(ScalaParser.BlockExprContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_simpleExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExpr" ):
                listener.enterSimpleExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExpr" ):
                listener.exitSimpleExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExpr" ):
                return visitor.visitSimpleExpr(self)
            else:
                return visitor.visitChildren(self)




    def simpleExpr(self):

        localctx = ScalaParser.SimpleExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_simpleExpr)
        try:
            self.state = 563
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [39]:
                self.enterOuterAlt(localctx, 1)
                self.state = 557
                self.match(ScalaParser.T__38)
                self.state = 560
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,56,self._ctx)
                if la_ == 1:
                    self.state = 558
                    self.classTemplate()
                    pass

                elif la_ == 2:
                    self.state = 559
                    self.templateBody()
                    pass


                pass
            elif token in [13]:
                self.enterOuterAlt(localctx, 2)
                self.state = 562
                self.blockExpr()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleExpr1Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal(self):
            return self.getTypedRuleContext(ScalaParser.LiteralContext,0)


        def stableId(self):
            return self.getTypedRuleContext(ScalaParser.StableIdContext,0)


        def exprs(self):
            return self.getTypedRuleContext(ScalaParser.ExprsContext,0)


        def simpleExpr(self):
            return self.getTypedRuleContext(ScalaParser.SimpleExprContext,0)


        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def typeArgs(self):
            return self.getTypedRuleContext(ScalaParser.TypeArgsContext,0)


        def simpleExpr1(self):
            return self.getTypedRuleContext(ScalaParser.SimpleExpr1Context,0)


        def argumentExprs(self):
            return self.getTypedRuleContext(ScalaParser.ArgumentExprsContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_simpleExpr1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExpr1" ):
                listener.enterSimpleExpr1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExpr1" ):
                listener.exitSimpleExpr1(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExpr1" ):
                return visitor.visitSimpleExpr1(self)
            else:
                return visitor.visitChildren(self)



    def simpleExpr1(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = ScalaParser.SimpleExpr1Context(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 52
        self.enterRecursionRule(localctx, 52, self.RULE_simpleExpr1, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 581
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,59,self._ctx)
            if la_ == 1:
                self.state = 566
                self.literal()
                pass

            elif la_ == 2:
                self.state = 567
                self.stableId(0)
                pass

            elif la_ == 3:
                self.state = 568
                self.match(ScalaParser.T__19)
                pass

            elif la_ == 4:
                self.state = 569
                self.match(ScalaParser.T__9)
                self.state = 571
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((_la) & ~0x3f) == 0 and ((1 << _la) & -4611684973025418138) != 0 or (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 31) != 0:
                    self.state = 570
                    self.exprs()


                self.state = 573
                self.match(ScalaParser.T__10)
                pass

            elif la_ == 5:
                self.state = 574
                self.simpleExpr()
                self.state = 575
                self.match(ScalaParser.T__2)
                self.state = 576
                self.match(ScalaParser.Id)
                pass

            elif la_ == 6:
                self.state = 578
                self.simpleExpr()
                self.state = 579
                self.typeArgs()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 598
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,63,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 596
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
                    if la_ == 1:
                        localctx = ScalaParser.SimpleExpr1Context(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_simpleExpr1)
                        self.state = 583
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 585
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==20:
                            self.state = 584
                            self.match(ScalaParser.T__19)


                        self.state = 587
                        self.match(ScalaParser.T__2)
                        self.state = 588
                        self.match(ScalaParser.Id)
                        pass

                    elif la_ == 2:
                        localctx = ScalaParser.SimpleExpr1Context(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_simpleExpr1)
                        self.state = 589
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 591
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==20:
                            self.state = 590
                            self.match(ScalaParser.T__19)


                        self.state = 593
                        self.typeArgs()
                        pass

                    elif la_ == 3:
                        localctx = ScalaParser.SimpleExpr1Context(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_simpleExpr1)
                        self.state = 594
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 595
                        self.argumentExprs()
                        pass

             
                self.state = 600
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,63,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ExprsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.ExprContext)
            else:
                return self.getTypedRuleContext(ScalaParser.ExprContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_exprs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprs" ):
                listener.enterExprs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprs" ):
                listener.exitExprs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprs" ):
                return visitor.visitExprs(self)
            else:
                return visitor.visitChildren(self)




    def exprs(self):

        localctx = ScalaParser.ExprsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_exprs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 601
            self.expr()
            self.state = 606
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,64,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 602
                    self.match(ScalaParser.T__3)
                    self.state = 603
                    self.expr() 
                self.state = 608
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,64,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentExprsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def args(self):
            return self.getTypedRuleContext(ScalaParser.ArgsContext,0)


        def blockExpr(self):
            return self.getTypedRuleContext(ScalaParser.BlockExprContext,0)


        def NL(self):
            return self.getToken(ScalaParser.NL, 0)

        def getRuleIndex(self):
            return ScalaParser.RULE_argumentExprs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgumentExprs" ):
                listener.enterArgumentExprs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgumentExprs" ):
                listener.exitArgumentExprs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgumentExprs" ):
                return visitor.visitArgumentExprs(self)
            else:
                return visitor.visitChildren(self)




    def argumentExprs(self):

        localctx = ScalaParser.ArgumentExprsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_argumentExprs)
        self._la = 0 # Token type
        try:
            self.state = 621
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 609
                self.match(ScalaParser.T__9)
                self.state = 610
                self.args()
                self.state = 611
                self.match(ScalaParser.T__10)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 613
                self.match(ScalaParser.T__12)
                self.state = 614
                self.args()
                self.state = 615
                self.match(ScalaParser.T__13)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 618
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==74:
                    self.state = 617
                    self.match(ScalaParser.NL)


                self.state = 620
                self.blockExpr()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def exprs(self):
            return self.getTypedRuleContext(ScalaParser.ExprsContext,0)


        def postfixExpr(self):
            return self.getTypedRuleContext(ScalaParser.PostfixExprContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_args

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgs" ):
                listener.enterArgs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgs" ):
                listener.exitArgs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgs" ):
                return visitor.visitArgs(self)
            else:
                return visitor.visitChildren(self)




    def args(self):

        localctx = ScalaParser.ArgsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_args)
        self._la = 0 # Token type
        try:
            self.state = 635
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 624
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((_la) & ~0x3f) == 0 and ((1 << _la) & -4611684973025418138) != 0 or (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 31) != 0:
                    self.state = 623
                    self.exprs()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 629
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,68,self._ctx)
                if la_ == 1:
                    self.state = 626
                    self.exprs()
                    self.state = 627
                    self.match(ScalaParser.T__3)


                self.state = 631
                self.postfixExpr()
                self.state = 633
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((_la) & ~0x3f) == 0 and ((1 << _la) & 3670016) != 0:
                    self.state = 632
                    _la = self._input.LA(1)
                    if not(((_la) & ~0x3f) == 0 and ((1 << _la) & 3670016) != 0):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def caseClauses(self):
            return self.getTypedRuleContext(ScalaParser.CaseClausesContext,0)


        def block(self):
            return self.getTypedRuleContext(ScalaParser.BlockContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_blockExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlockExpr" ):
                listener.enterBlockExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlockExpr" ):
                listener.exitBlockExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlockExpr" ):
                return visitor.visitBlockExpr(self)
            else:
                return visitor.visitChildren(self)




    def blockExpr(self):

        localctx = ScalaParser.BlockExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_blockExpr)
        try:
            self.state = 645
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,71,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 637
                self.match(ScalaParser.T__12)
                self.state = 638
                self.caseClauses()
                self.state = 639
                self.match(ScalaParser.T__13)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 641
                self.match(ScalaParser.T__12)
                self.state = 642
                self.block()
                self.state = 643
                self.match(ScalaParser.T__13)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def blockStat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.BlockStatContext)
            else:
                return self.getTypedRuleContext(ScalaParser.BlockStatContext,i)


        def resultExpr(self):
            return self.getTypedRuleContext(ScalaParser.ResultExprContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlock" ):
                listener.enterBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlock" ):
                listener.exitBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlock" ):
                return visitor.visitBlock(self)
            else:
                return visitor.visitChildren(self)




    def block(self):

        localctx = ScalaParser.BlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 648 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 647
                    self.blockStat()

                else:
                    raise NoViableAltException(self)
                self.state = 650 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,72,self._ctx)

            self.state = 653
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((_la) & ~0x3f) == 0 and ((1 << _la) & -4611684973025418138) != 0 or (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 31) != 0:
                self.state = 652
                self.resultExpr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockStatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def import_(self):
            return self.getTypedRuleContext(ScalaParser.Import_Context,0)


        def def_(self):
            return self.getTypedRuleContext(ScalaParser.Def_Context,0)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ScalaParser.AnnotationContext,i)


        def tmplDef(self):
            return self.getTypedRuleContext(ScalaParser.TmplDefContext,0)


        def localModifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.LocalModifierContext)
            else:
                return self.getTypedRuleContext(ScalaParser.LocalModifierContext,i)


        def expr1(self):
            return self.getTypedRuleContext(ScalaParser.Expr1Context,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_blockStat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlockStat" ):
                listener.enterBlockStat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlockStat" ):
                listener.exitBlockStat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlockStat" ):
                return visitor.visitBlockStat(self)
            else:
                return visitor.visitChildren(self)




    def blockStat(self):

        localctx = ScalaParser.BlockStatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_blockStat)
        self._la = 0 # Token type
        try:
            self.state = 680
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,78,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 655
                self.import_()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 659
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==44:
                    self.state = 656
                    self.annotation()
                    self.state = 661
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 663
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==22 or _la==40:
                    self.state = 662
                    _la = self._input.LA(1)
                    if not(_la==22 or _la==40):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 665
                self.def_()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 669
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==44:
                    self.state = 666
                    self.annotation()
                    self.state = 671
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 675
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((_la) & ~0x3f) == 0 and ((1 << _la) & 7882398863720448) != 0:
                    self.state = 672
                    self.localModifier()
                    self.state = 677
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 678
                self.tmplDef()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 679
                self.expr1()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResultExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr1(self):
            return self.getTypedRuleContext(ScalaParser.Expr1Context,0)


        def block(self):
            return self.getTypedRuleContext(ScalaParser.BlockContext,0)


        def bindings(self):
            return self.getTypedRuleContext(ScalaParser.BindingsContext,0)


        def compoundType(self):
            return self.getTypedRuleContext(ScalaParser.CompoundTypeContext,0)


        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def getRuleIndex(self):
            return ScalaParser.RULE_resultExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResultExpr" ):
                listener.enterResultExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResultExpr" ):
                listener.exitResultExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResultExpr" ):
                return visitor.visitResultExpr(self)
            else:
                return visitor.visitChildren(self)




    def resultExpr(self):

        localctx = ScalaParser.ResultExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_resultExpr)
        self._la = 0 # Token type
        try:
            self.state = 698
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,82,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 682
                self.expr1()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 693
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [10]:
                    self.state = 683
                    self.bindings()
                    pass
                elif token in [20, 22, 62]:
                    self.state = 689
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [22, 62]:
                        self.state = 685
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==22:
                            self.state = 684
                            self.match(ScalaParser.T__21)


                        self.state = 687
                        self.match(ScalaParser.Id)
                        pass
                    elif token in [20]:
                        self.state = 688
                        self.match(ScalaParser.T__19)
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 691
                    self.match(ScalaParser.T__18)
                    self.state = 692
                    self.compoundType()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 695
                self.match(ScalaParser.T__8)
                self.state = 696
                self.block()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumeratorsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def generator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.GeneratorContext)
            else:
                return self.getTypedRuleContext(ScalaParser.GeneratorContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_enumerators

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumerators" ):
                listener.enterEnumerators(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumerators" ):
                listener.exitEnumerators(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumerators" ):
                return visitor.visitEnumerators(self)
            else:
                return visitor.visitChildren(self)




    def enumerators(self):

        localctx = ScalaParser.EnumeratorsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_enumerators)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 701 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 700
                self.generator()
                self.state = 703 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((_la) & ~0x3f) == 0 and ((1 << _la) & -4611686018426338202) != 0 or (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 127) != 0):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GeneratorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pattern1(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.Pattern1Context)
            else:
                return self.getTypedRuleContext(ScalaParser.Pattern1Context,i)


        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.ExprContext)
            else:
                return self.getTypedRuleContext(ScalaParser.ExprContext,i)


        def guard_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.Guard_Context)
            else:
                return self.getTypedRuleContext(ScalaParser.Guard_Context,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_generator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenerator" ):
                listener.enterGenerator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenerator" ):
                listener.exitGenerator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenerator" ):
                return visitor.visitGenerator(self)
            else:
                return visitor.visitChildren(self)




    def generator(self):

        localctx = ScalaParser.GeneratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_generator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 705
            self.pattern1()
            self.state = 706
            self.match(ScalaParser.T__40)
            self.state = 707
            self.expr()
            self.state = 715
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,85,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 713
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [23]:
                        self.state = 708
                        self.guard_()
                        pass
                    elif token in [1, 2, 5, 6, 10, 20, 62, 63, 64, 65, 66, 67, 68, 69, 70]:
                        self.state = 709
                        self.pattern1()
                        self.state = 710
                        self.match(ScalaParser.T__33)
                        self.state = 711
                        self.expr()
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 717
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,85,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseClausesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def caseClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.CaseClauseContext)
            else:
                return self.getTypedRuleContext(ScalaParser.CaseClauseContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_caseClauses

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseClauses" ):
                listener.enterCaseClauses(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseClauses" ):
                listener.exitCaseClauses(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseClauses" ):
                return visitor.visitCaseClauses(self)
            else:
                return visitor.visitChildren(self)




    def caseClauses(self):

        localctx = ScalaParser.CaseClausesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_caseClauses)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 719 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 718
                self.caseClause()
                self.state = 721 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==42):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pattern(self):
            return self.getTypedRuleContext(ScalaParser.PatternContext,0)


        def block(self):
            return self.getTypedRuleContext(ScalaParser.BlockContext,0)


        def guard_(self):
            return self.getTypedRuleContext(ScalaParser.Guard_Context,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_caseClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseClause" ):
                listener.enterCaseClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseClause" ):
                listener.exitCaseClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseClause" ):
                return visitor.visitCaseClause(self)
            else:
                return visitor.visitChildren(self)




    def caseClause(self):

        localctx = ScalaParser.CaseClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_caseClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 723
            self.match(ScalaParser.T__41)
            self.state = 724
            self.pattern()
            self.state = 726
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==23:
                self.state = 725
                self.guard_()


            self.state = 728
            self.match(ScalaParser.T__8)
            self.state = 729
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Guard_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def postfixExpr(self):
            return self.getTypedRuleContext(ScalaParser.PostfixExprContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_guard_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGuard_" ):
                listener.enterGuard_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGuard_" ):
                listener.exitGuard_(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGuard_" ):
                return visitor.visitGuard_(self)
            else:
                return visitor.visitChildren(self)




    def guard_(self):

        localctx = ScalaParser.Guard_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_guard_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 731
            self.match(ScalaParser.T__22)
            self.state = 732
            self.postfixExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PatternContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pattern1(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.Pattern1Context)
            else:
                return self.getTypedRuleContext(ScalaParser.Pattern1Context,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_pattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPattern" ):
                listener.enterPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPattern" ):
                listener.exitPattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPattern" ):
                return visitor.visitPattern(self)
            else:
                return visitor.visitChildren(self)




    def pattern(self):

        localctx = ScalaParser.PatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_pattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 734
            self.pattern1()
            self.state = 739
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==43:
                self.state = 735
                self.match(ScalaParser.T__42)
                self.state = 736
                self.pattern1()
                self.state = 741
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pattern1Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typePat(self):
            return self.getTypedRuleContext(ScalaParser.TypePatContext,0)


        def BoundVarid(self):
            return self.getToken(ScalaParser.BoundVarid, 0)

        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def pattern2(self):
            return self.getTypedRuleContext(ScalaParser.Pattern2Context,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_pattern1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPattern1" ):
                listener.enterPattern1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPattern1" ):
                listener.exitPattern1(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPattern1" ):
                return visitor.visitPattern1(self)
            else:
                return visitor.visitChildren(self)




    def pattern1(self):

        localctx = ScalaParser.Pattern1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_pattern1)
        self._la = 0 # Token type
        try:
            self.state = 746
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,89,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 742
                _la = self._input.LA(1)
                if not((((_la - 20)) & ~0x3f) == 0 and ((1 << (_la - 20)) & 1130297953353729) != 0):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 743
                self.match(ScalaParser.T__18)
                self.state = 744
                self.typePat()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 745
                self.pattern2()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pattern2Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def pattern3(self):
            return self.getTypedRuleContext(ScalaParser.Pattern3Context,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_pattern2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPattern2" ):
                listener.enterPattern2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPattern2" ):
                listener.exitPattern2(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPattern2" ):
                return visitor.visitPattern2(self)
            else:
                return visitor.visitChildren(self)




    def pattern2(self):

        localctx = ScalaParser.Pattern2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_pattern2)
        self._la = 0 # Token type
        try:
            self.state = 754
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 748
                self.match(ScalaParser.Id)
                self.state = 751
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==44:
                    self.state = 749
                    self.match(ScalaParser.T__43)
                    self.state = 750
                    self.pattern3()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 753
                self.pattern3()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pattern3Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simplePattern(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.SimplePatternContext)
            else:
                return self.getTypedRuleContext(ScalaParser.SimplePatternContext,i)


        def Id(self, i:int=None):
            if i is None:
                return self.getTokens(ScalaParser.Id)
            else:
                return self.getToken(ScalaParser.Id, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(ScalaParser.NL)
            else:
                return self.getToken(ScalaParser.NL, i)

        def getRuleIndex(self):
            return ScalaParser.RULE_pattern3

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPattern3" ):
                listener.enterPattern3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPattern3" ):
                listener.exitPattern3(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPattern3" ):
                return visitor.visitPattern3(self)
            else:
                return visitor.visitChildren(self)




    def pattern3(self):

        localctx = ScalaParser.Pattern3Context(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_pattern3)
        self._la = 0 # Token type
        try:
            self.state = 768
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,94,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 756
                self.simplePattern()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 757
                self.simplePattern()
                self.state = 765
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==62:
                    self.state = 758
                    self.match(ScalaParser.Id)
                    self.state = 760
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==74:
                        self.state = 759
                        self.match(ScalaParser.NL)


                    self.state = 762
                    self.simplePattern()
                    self.state = 767
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimplePatternContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Varid(self):
            return self.getToken(ScalaParser.Varid, 0)

        def literal(self):
            return self.getTypedRuleContext(ScalaParser.LiteralContext,0)


        def stableId(self):
            return self.getTypedRuleContext(ScalaParser.StableIdContext,0)


        def patterns(self):
            return self.getTypedRuleContext(ScalaParser.PatternsContext,0)


        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def getRuleIndex(self):
            return ScalaParser.RULE_simplePattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimplePattern" ):
                listener.enterSimplePattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimplePattern" ):
                listener.exitSimplePattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimplePattern" ):
                return visitor.visitSimplePattern(self)
            else:
                return visitor.visitChildren(self)




    def simplePattern(self):

        localctx = ScalaParser.SimplePatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_simplePattern)
        self._la = 0 # Token type
        try:
            self.state = 801
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,100,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 770
                self.match(ScalaParser.T__19)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 771
                self.match(ScalaParser.Varid)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 772
                self.literal()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 773
                self.stableId(0)
                self.state = 779
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==10:
                    self.state = 774
                    self.match(ScalaParser.T__9)
                    self.state = 776
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if ((_la) & ~0x3f) == 0 and ((1 << _la) & -4611686018426338202) != 0 or (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 127) != 0:
                        self.state = 775
                        self.patterns()


                    self.state = 778
                    self.match(ScalaParser.T__10)


                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 781
                self.stableId(0)
                self.state = 782
                self.match(ScalaParser.T__9)
                self.state = 786
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,97,self._ctx)
                if la_ == 1:
                    self.state = 783
                    self.patterns()
                    self.state = 784
                    self.match(ScalaParser.T__3)


                self.state = 790
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==62:
                    self.state = 788
                    self.match(ScalaParser.Id)
                    self.state = 789
                    self.match(ScalaParser.T__43)


                self.state = 792
                self.match(ScalaParser.T__19)
                self.state = 793
                self.match(ScalaParser.T__20)
                self.state = 794
                self.match(ScalaParser.T__10)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 796
                self.match(ScalaParser.T__9)
                self.state = 798
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((_la) & ~0x3f) == 0 and ((1 << _la) & -4611686018426338202) != 0 or (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 127) != 0:
                    self.state = 797
                    self.patterns()


                self.state = 800
                self.match(ScalaParser.T__10)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PatternsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pattern(self):
            return self.getTypedRuleContext(ScalaParser.PatternContext,0)


        def patterns(self):
            return self.getTypedRuleContext(ScalaParser.PatternsContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_patterns

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPatterns" ):
                listener.enterPatterns(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPatterns" ):
                listener.exitPatterns(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPatterns" ):
                return visitor.visitPatterns(self)
            else:
                return visitor.visitChildren(self)




    def patterns(self):

        localctx = ScalaParser.PatternsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_patterns)
        try:
            self.state = 810
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,102,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 803
                self.pattern()
                self.state = 806
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,101,self._ctx)
                if la_ == 1:
                    self.state = 804
                    self.match(ScalaParser.T__3)
                    self.state = 805
                    self.patterns()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 808
                self.match(ScalaParser.T__19)
                self.state = 809
                self.match(ScalaParser.T__20)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeParamClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variantTypeParam(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.VariantTypeParamContext)
            else:
                return self.getTypedRuleContext(ScalaParser.VariantTypeParamContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_typeParamClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeParamClause" ):
                listener.enterTypeParamClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeParamClause" ):
                listener.exitTypeParamClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeParamClause" ):
                return visitor.visitTypeParamClause(self)
            else:
                return visitor.visitChildren(self)




    def typeParamClause(self):

        localctx = ScalaParser.TypeParamClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_typeParamClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 812
            self.match(ScalaParser.T__6)
            self.state = 813
            self.variantTypeParam()
            self.state = 818
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 814
                self.match(ScalaParser.T__3)
                self.state = 815
                self.variantTypeParam()
                self.state = 820
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 821
            self.match(ScalaParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunTypeParamClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeParam(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.TypeParamContext)
            else:
                return self.getTypedRuleContext(ScalaParser.TypeParamContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_funTypeParamClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunTypeParamClause" ):
                listener.enterFunTypeParamClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunTypeParamClause" ):
                listener.exitFunTypeParamClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunTypeParamClause" ):
                return visitor.visitFunTypeParamClause(self)
            else:
                return visitor.visitChildren(self)




    def funTypeParamClause(self):

        localctx = ScalaParser.FunTypeParamClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_funTypeParamClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 823
            self.match(ScalaParser.T__6)
            self.state = 824
            self.typeParam()
            self.state = 829
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 825
                self.match(ScalaParser.T__3)
                self.state = 826
                self.typeParam()
                self.state = 831
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 832
            self.match(ScalaParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariantTypeParamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeParam(self):
            return self.getTypedRuleContext(ScalaParser.TypeParamContext,0)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ScalaParser.AnnotationContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_variantTypeParam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariantTypeParam" ):
                listener.enterVariantTypeParam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariantTypeParam" ):
                listener.exitVariantTypeParam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariantTypeParam" ):
                return visitor.visitVariantTypeParam(self)
            else:
                return visitor.visitChildren(self)




    def variantTypeParam(self):

        localctx = ScalaParser.VariantTypeParamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_variantTypeParam)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 837
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==44:
                self.state = 834
                self.annotation()
                self.state = 839
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 841
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1 or _la==36:
                self.state = 840
                _la = self._input.LA(1)
                if not(_la==1 or _la==36):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 843
            self.typeParam()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeParamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def typeParamClause(self):
            return self.getTypedRuleContext(ScalaParser.TypeParamClauseContext,0)


        def type_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.Type_Context)
            else:
                return self.getTypedRuleContext(ScalaParser.Type_Context,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_typeParam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeParam" ):
                listener.enterTypeParam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeParam" ):
                listener.exitTypeParam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeParam" ):
                return visitor.visitTypeParam(self)
            else:
                return visitor.visitChildren(self)




    def typeParam(self):

        localctx = ScalaParser.TypeParamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_typeParam)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 845
            _la = self._input.LA(1)
            if not(_la==20 or _la==62):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 847
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==7:
                self.state = 846
                self.typeParamClause()


            self.state = 851
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==45:
                self.state = 849
                self.match(ScalaParser.T__44)
                self.state = 850
                self.type_()


            self.state = 855
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==46:
                self.state = 853
                self.match(ScalaParser.T__45)
                self.state = 854
                self.type_()


            self.state = 861
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==47:
                self.state = 857
                self.match(ScalaParser.T__46)
                self.state = 858
                self.type_()
                self.state = 863
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 868
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==19:
                self.state = 864
                self.match(ScalaParser.T__18)
                self.state = 865
                self.type_()
                self.state = 870
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParamClausesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def paramClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.ParamClauseContext)
            else:
                return self.getTypedRuleContext(ScalaParser.ParamClauseContext,i)


        def params(self):
            return self.getTypedRuleContext(ScalaParser.ParamsContext,0)


        def NL(self):
            return self.getToken(ScalaParser.NL, 0)

        def getRuleIndex(self):
            return ScalaParser.RULE_paramClauses

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParamClauses" ):
                listener.enterParamClauses(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParamClauses" ):
                listener.exitParamClauses(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParamClauses" ):
                return visitor.visitParamClauses(self)
            else:
                return visitor.visitChildren(self)




    def paramClauses(self):

        localctx = ScalaParser.ParamClausesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_paramClauses)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 874
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,112,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 871
                    self.paramClause() 
                self.state = 876
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,112,self._ctx)

            self.state = 885
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,114,self._ctx)
            if la_ == 1:
                self.state = 878
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==74:
                    self.state = 877
                    self.match(ScalaParser.NL)


                self.state = 880
                self.match(ScalaParser.T__9)
                self.state = 881
                self.match(ScalaParser.T__21)
                self.state = 882
                self.params()
                self.state = 883
                self.match(ScalaParser.T__10)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParamClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NL(self):
            return self.getToken(ScalaParser.NL, 0)

        def params(self):
            return self.getTypedRuleContext(ScalaParser.ParamsContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_paramClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParamClause" ):
                listener.enterParamClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParamClause" ):
                listener.exitParamClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParamClause" ):
                return visitor.visitParamClause(self)
            else:
                return visitor.visitChildren(self)




    def paramClause(self):

        localctx = ScalaParser.ParamClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_paramClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 888
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==74:
                self.state = 887
                self.match(ScalaParser.NL)


            self.state = 890
            self.match(ScalaParser.T__9)
            self.state = 892
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==44 or _la==62:
                self.state = 891
                self.params()


            self.state = 894
            self.match(ScalaParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParamsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def param(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.ParamContext)
            else:
                return self.getTypedRuleContext(ScalaParser.ParamContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_params

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParams" ):
                listener.enterParams(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParams" ):
                listener.exitParams(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParams" ):
                return visitor.visitParams(self)
            else:
                return visitor.visitChildren(self)




    def params(self):

        localctx = ScalaParser.ParamsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_params)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 896
            self.param()
            self.state = 901
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 897
                self.match(ScalaParser.T__3)
                self.state = 898
                self.param()
                self.state = 903
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ScalaParser.AnnotationContext,i)


        def paramType(self):
            return self.getTypedRuleContext(ScalaParser.ParamTypeContext,0)


        def expr(self):
            return self.getTypedRuleContext(ScalaParser.ExprContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_param

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParam" ):
                listener.enterParam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParam" ):
                listener.exitParam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParam" ):
                return visitor.visitParam(self)
            else:
                return visitor.visitChildren(self)




    def param(self):

        localctx = ScalaParser.ParamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_param)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 907
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==44:
                self.state = 904
                self.annotation()
                self.state = 909
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 910
            self.match(ScalaParser.Id)
            self.state = 913
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==19:
                self.state = 911
                self.match(ScalaParser.T__18)
                self.state = 912
                self.paramType()


            self.state = 917
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==34:
                self.state = 915
                self.match(ScalaParser.T__33)
                self.state = 916
                self.expr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParamTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(ScalaParser.Type_Context,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_paramType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParamType" ):
                listener.enterParamType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParamType" ):
                listener.exitParamType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParamType" ):
                return visitor.visitParamType(self)
            else:
                return visitor.visitChildren(self)




    def paramType(self):

        localctx = ScalaParser.ParamTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_paramType)
        try:
            self.state = 925
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,121,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 919
                self.type_()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 920
                self.match(ScalaParser.T__8)
                self.state = 921
                self.type_()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 922
                self.type_()
                self.state = 923
                self.match(ScalaParser.T__20)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassParamClausesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classParamClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.ClassParamClauseContext)
            else:
                return self.getTypedRuleContext(ScalaParser.ClassParamClauseContext,i)


        def classParams(self):
            return self.getTypedRuleContext(ScalaParser.ClassParamsContext,0)


        def NL(self):
            return self.getToken(ScalaParser.NL, 0)

        def getRuleIndex(self):
            return ScalaParser.RULE_classParamClauses

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassParamClauses" ):
                listener.enterClassParamClauses(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassParamClauses" ):
                listener.exitClassParamClauses(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassParamClauses" ):
                return visitor.visitClassParamClauses(self)
            else:
                return visitor.visitChildren(self)




    def classParamClauses(self):

        localctx = ScalaParser.ClassParamClausesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_classParamClauses)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 930
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,122,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 927
                    self.classParamClause() 
                self.state = 932
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,122,self._ctx)

            self.state = 941
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,124,self._ctx)
            if la_ == 1:
                self.state = 934
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==74:
                    self.state = 933
                    self.match(ScalaParser.NL)


                self.state = 936
                self.match(ScalaParser.T__9)
                self.state = 937
                self.match(ScalaParser.T__21)
                self.state = 938
                self.classParams()
                self.state = 939
                self.match(ScalaParser.T__10)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassParamClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NL(self):
            return self.getToken(ScalaParser.NL, 0)

        def classParams(self):
            return self.getTypedRuleContext(ScalaParser.ClassParamsContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_classParamClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassParamClause" ):
                listener.enterClassParamClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassParamClause" ):
                listener.exitClassParamClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassParamClause" ):
                return visitor.visitClassParamClause(self)
            else:
                return visitor.visitChildren(self)




    def classParamClause(self):

        localctx = ScalaParser.ClassParamClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_classParamClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 944
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==74:
                self.state = 943
                self.match(ScalaParser.NL)


            self.state = 946
            self.match(ScalaParser.T__9)
            self.state = 948
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((_la) & ~0x3f) == 0 and ((1 << _la) & 4647452032171573248) != 0:
                self.state = 947
                self.classParams()


            self.state = 950
            self.match(ScalaParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassParamsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classParam(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.ClassParamContext)
            else:
                return self.getTypedRuleContext(ScalaParser.ClassParamContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_classParams

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassParams" ):
                listener.enterClassParams(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassParams" ):
                listener.exitClassParams(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassParams" ):
                return visitor.visitClassParams(self)
            else:
                return visitor.visitChildren(self)




    def classParams(self):

        localctx = ScalaParser.ClassParamsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_classParams)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 952
            self.classParam()
            self.state = 957
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 953
                self.match(ScalaParser.T__3)
                self.state = 954
                self.classParam()
                self.state = 959
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassParamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def paramType(self):
            return self.getTypedRuleContext(ScalaParser.ParamTypeContext,0)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ScalaParser.AnnotationContext,i)


        def modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.ModifierContext)
            else:
                return self.getTypedRuleContext(ScalaParser.ModifierContext,i)


        def expr(self):
            return self.getTypedRuleContext(ScalaParser.ExprContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_classParam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassParam" ):
                listener.enterClassParam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassParam" ):
                listener.exitClassParam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassParam" ):
                return visitor.visitClassParam(self)
            else:
                return visitor.visitChildren(self)




    def classParam(self):

        localctx = ScalaParser.ClassParamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_classParam)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 963
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==44:
                self.state = 960
                self.annotation()
                self.state = 965
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 969
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & 35466946581364736) != 0:
                self.state = 966
                self.modifier()
                self.state = 971
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 973
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==16 or _la==48:
                self.state = 972
                _la = self._input.LA(1)
                if not(_la==16 or _la==48):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 975
            self.match(ScalaParser.Id)
            self.state = 976
            self.match(ScalaParser.T__18)
            self.state = 977
            self.paramType()
            self.state = 980
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==34:
                self.state = 978
                self.match(ScalaParser.T__33)
                self.state = 979
                self.expr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BindingsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def binding(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.BindingContext)
            else:
                return self.getTypedRuleContext(ScalaParser.BindingContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_bindings

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBindings" ):
                listener.enterBindings(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBindings" ):
                listener.exitBindings(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBindings" ):
                return visitor.visitBindings(self)
            else:
                return visitor.visitChildren(self)




    def bindings(self):

        localctx = ScalaParser.BindingsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_bindings)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 982
            self.match(ScalaParser.T__9)
            self.state = 983
            self.binding()
            self.state = 988
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 984
                self.match(ScalaParser.T__3)
                self.state = 985
                self.binding()
                self.state = 990
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 991
            self.match(ScalaParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BindingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def type_(self):
            return self.getTypedRuleContext(ScalaParser.Type_Context,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_binding

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinding" ):
                listener.enterBinding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinding" ):
                listener.exitBinding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinding" ):
                return visitor.visitBinding(self)
            else:
                return visitor.visitChildren(self)




    def binding(self):

        localctx = ScalaParser.BindingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_binding)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 993
            _la = self._input.LA(1)
            if not(_la==20 or _la==62):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 996
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==19:
                self.state = 994
                self.match(ScalaParser.T__18)
                self.state = 995
                self.type_()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def localModifier(self):
            return self.getTypedRuleContext(ScalaParser.LocalModifierContext,0)


        def accessModifier(self):
            return self.getTypedRuleContext(ScalaParser.AccessModifierContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_modifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModifier" ):
                listener.enterModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModifier" ):
                listener.exitModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModifier" ):
                return visitor.visitModifier(self)
            else:
                return visitor.visitChildren(self)




    def modifier(self):

        localctx = ScalaParser.ModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_modifier)
        try:
            self.state = 1001
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [22, 40, 50, 51, 52]:
                self.enterOuterAlt(localctx, 1)
                self.state = 998
                self.localModifier()
                pass
            elif token in [53, 54]:
                self.enterOuterAlt(localctx, 2)
                self.state = 999
                self.accessModifier()
                pass
            elif token in [49]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1000
                self.match(ScalaParser.T__48)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocalModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ScalaParser.RULE_localModifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocalModifier" ):
                listener.enterLocalModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocalModifier" ):
                listener.exitLocalModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLocalModifier" ):
                return visitor.visitLocalModifier(self)
            else:
                return visitor.visitChildren(self)




    def localModifier(self):

        localctx = ScalaParser.LocalModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_localModifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1003
            _la = self._input.LA(1)
            if not(((_la) & ~0x3f) == 0 and ((1 << _la) & 7882398863720448) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AccessModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def accessQualifier(self):
            return self.getTypedRuleContext(ScalaParser.AccessQualifierContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_accessModifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAccessModifier" ):
                listener.enterAccessModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAccessModifier" ):
                listener.exitAccessModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAccessModifier" ):
                return visitor.visitAccessModifier(self)
            else:
                return visitor.visitChildren(self)




    def accessModifier(self):

        localctx = ScalaParser.AccessModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_accessModifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1005
            _la = self._input.LA(1)
            if not(_la==53 or _la==54):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1007
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==7:
                self.state = 1006
                self.accessQualifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AccessQualifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def getRuleIndex(self):
            return ScalaParser.RULE_accessQualifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAccessQualifier" ):
                listener.enterAccessQualifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAccessQualifier" ):
                listener.exitAccessQualifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAccessQualifier" ):
                return visitor.visitAccessQualifier(self)
            else:
                return visitor.visitChildren(self)




    def accessQualifier(self):

        localctx = ScalaParser.AccessQualifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_accessQualifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1009
            self.match(ScalaParser.T__6)
            self.state = 1010
            _la = self._input.LA(1)
            if not(_la==5 or _la==62):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1011
            self.match(ScalaParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnnotationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleType(self):
            return self.getTypedRuleContext(ScalaParser.SimpleTypeContext,0)


        def argumentExprs(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.ArgumentExprsContext)
            else:
                return self.getTypedRuleContext(ScalaParser.ArgumentExprsContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_annotation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotation" ):
                listener.enterAnnotation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotation" ):
                listener.exitAnnotation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnnotation" ):
                return visitor.visitAnnotation(self)
            else:
                return visitor.visitChildren(self)




    def annotation(self):

        localctx = ScalaParser.AnnotationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_annotation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1013
            self.match(ScalaParser.T__43)
            self.state = 1014
            self.simpleType(0)
            self.state = 1018
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,136,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1015
                    self.argumentExprs() 
                self.state = 1020
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,136,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstrAnnotationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleType(self):
            return self.getTypedRuleContext(ScalaParser.SimpleTypeContext,0)


        def argumentExprs(self):
            return self.getTypedRuleContext(ScalaParser.ArgumentExprsContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_constrAnnotation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstrAnnotation" ):
                listener.enterConstrAnnotation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstrAnnotation" ):
                listener.exitConstrAnnotation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstrAnnotation" ):
                return visitor.visitConstrAnnotation(self)
            else:
                return visitor.visitChildren(self)




    def constrAnnotation(self):

        localctx = ScalaParser.ConstrAnnotationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_constrAnnotation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1021
            self.match(ScalaParser.T__43)
            self.state = 1022
            self.simpleType(0)
            self.state = 1023
            self.argumentExprs()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TemplateBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NL(self):
            return self.getToken(ScalaParser.NL, 0)

        def selfType(self):
            return self.getTypedRuleContext(ScalaParser.SelfTypeContext,0)


        def templateStat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.TemplateStatContext)
            else:
                return self.getTypedRuleContext(ScalaParser.TemplateStatContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_templateBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemplateBody" ):
                listener.enterTemplateBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemplateBody" ):
                listener.exitTemplateBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTemplateBody" ):
                return visitor.visitTemplateBody(self)
            else:
                return visitor.visitChildren(self)




    def templateBody(self):

        localctx = ScalaParser.TemplateBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_templateBody)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1026
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==74:
                self.state = 1025
                self.match(ScalaParser.NL)


            self.state = 1028
            self.match(ScalaParser.T__12)
            self.state = 1030
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,138,self._ctx)
            if la_ == 1:
                self.state = 1029
                self.selfType()


            self.state = 1033 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1032
                self.templateStat()
                self.state = 1035 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((_la) & ~0x3f) == 0 and ((1 << _la) & -3459021853651000218) != 0 or (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 31) != 0):
                    break

            self.state = 1037
            self.match(ScalaParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TemplateStatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def import_(self):
            return self.getTypedRuleContext(ScalaParser.Import_Context,0)


        def def_(self):
            return self.getTypedRuleContext(ScalaParser.Def_Context,0)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ScalaParser.AnnotationContext,i)


        def modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.ModifierContext)
            else:
                return self.getTypedRuleContext(ScalaParser.ModifierContext,i)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(ScalaParser.NL)
            else:
                return self.getToken(ScalaParser.NL, i)

        def dcl(self):
            return self.getTypedRuleContext(ScalaParser.DclContext,0)


        def expr(self):
            return self.getTypedRuleContext(ScalaParser.ExprContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_templateStat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemplateStat" ):
                listener.enterTemplateStat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemplateStat" ):
                listener.exitTemplateStat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTemplateStat" ):
                return visitor.visitTemplateStat(self)
            else:
                return visitor.visitChildren(self)




    def templateStat(self):

        localctx = ScalaParser.TemplateStatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_templateStat)
        self._la = 0 # Token type
        try:
            self.state = 1073
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,146,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1039
                self.import_()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1046
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==44:
                    self.state = 1040
                    self.annotation()
                    self.state = 1042
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==74:
                        self.state = 1041
                        self.match(ScalaParser.NL)


                    self.state = 1048
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1052
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((_la) & ~0x3f) == 0 and ((1 << _la) & 35466946581364736) != 0:
                    self.state = 1049
                    self.modifier()
                    self.state = 1054
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1055
                self.def_()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1062
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==44:
                    self.state = 1056
                    self.annotation()
                    self.state = 1058
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==74:
                        self.state = 1057
                        self.match(ScalaParser.NL)


                    self.state = 1064
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1068
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((_la) & ~0x3f) == 0 and ((1 << _la) & 35466946581364736) != 0:
                    self.state = 1065
                    self.modifier()
                    self.state = 1070
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1071
                self.dcl()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1072
                self.expr()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelfTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def type_(self):
            return self.getTypedRuleContext(ScalaParser.Type_Context,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_selfType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelfType" ):
                listener.enterSelfType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelfType" ):
                listener.exitSelfType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelfType" ):
                return visitor.visitSelfType(self)
            else:
                return visitor.visitChildren(self)




    def selfType(self):

        localctx = ScalaParser.SelfTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_selfType)
        self._la = 0 # Token type
        try:
            self.state = 1086
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [62]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1075
                self.match(ScalaParser.Id)
                self.state = 1078
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==19:
                    self.state = 1076
                    self.match(ScalaParser.T__18)
                    self.state = 1077
                    self.type_()


                self.state = 1080
                self.match(ScalaParser.T__8)
                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1081
                self.match(ScalaParser.T__4)
                self.state = 1082
                self.match(ScalaParser.T__18)
                self.state = 1083
                self.type_()
                self.state = 1084
                self.match(ScalaParser.T__8)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Import_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def importExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.ImportExprContext)
            else:
                return self.getTypedRuleContext(ScalaParser.ImportExprContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_import_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImport_" ):
                listener.enterImport_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImport_" ):
                listener.exitImport_(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImport_" ):
                return visitor.visitImport_(self)
            else:
                return visitor.visitChildren(self)




    def import_(self):

        localctx = ScalaParser.Import_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_import_)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1088
            self.match(ScalaParser.T__54)
            self.state = 1089
            self.importExpr()
            self.state = 1094
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 1090
                self.match(ScalaParser.T__3)
                self.state = 1091
                self.importExpr()
                self.state = 1096
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stableId(self):
            return self.getTypedRuleContext(ScalaParser.StableIdContext,0)


        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def importSelectors(self):
            return self.getTypedRuleContext(ScalaParser.ImportSelectorsContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_importExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportExpr" ):
                listener.enterImportExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportExpr" ):
                listener.exitImportExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImportExpr" ):
                return visitor.visitImportExpr(self)
            else:
                return visitor.visitChildren(self)




    def importExpr(self):

        localctx = ScalaParser.ImportExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_importExpr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1097
            self.stableId(0)
            self.state = 1104
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==3:
                self.state = 1098
                self.match(ScalaParser.T__2)
                self.state = 1102
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [62]:
                    self.state = 1099
                    self.match(ScalaParser.Id)
                    pass
                elif token in [20]:
                    self.state = 1100
                    self.match(ScalaParser.T__19)
                    pass
                elif token in [13]:
                    self.state = 1101
                    self.importSelectors()
                    pass
                else:
                    raise NoViableAltException(self)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportSelectorsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def importSelector(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.ImportSelectorContext)
            else:
                return self.getTypedRuleContext(ScalaParser.ImportSelectorContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_importSelectors

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportSelectors" ):
                listener.enterImportSelectors(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportSelectors" ):
                listener.exitImportSelectors(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImportSelectors" ):
                return visitor.visitImportSelectors(self)
            else:
                return visitor.visitChildren(self)




    def importSelectors(self):

        localctx = ScalaParser.ImportSelectorsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_importSelectors)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1106
            self.match(ScalaParser.T__12)
            self.state = 1112
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,152,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1107
                    self.importSelector()
                    self.state = 1108
                    self.match(ScalaParser.T__3) 
                self.state = 1114
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,152,self._ctx)

            self.state = 1117
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [62]:
                self.state = 1115
                self.importSelector()
                pass
            elif token in [20]:
                self.state = 1116
                self.match(ScalaParser.T__19)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1119
            self.match(ScalaParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportSelectorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self, i:int=None):
            if i is None:
                return self.getTokens(ScalaParser.Id)
            else:
                return self.getToken(ScalaParser.Id, i)

        def getRuleIndex(self):
            return ScalaParser.RULE_importSelector

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportSelector" ):
                listener.enterImportSelector(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportSelector" ):
                listener.exitImportSelector(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImportSelector" ):
                return visitor.visitImportSelector(self)
            else:
                return visitor.visitChildren(self)




    def importSelector(self):

        localctx = ScalaParser.ImportSelectorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_importSelector)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1121
            self.match(ScalaParser.Id)
            self.state = 1124
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==9:
                self.state = 1122
                self.match(ScalaParser.T__8)
                self.state = 1123
                _la = self._input.LA(1)
                if not(_la==20 or _la==62):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valDcl(self):
            return self.getTypedRuleContext(ScalaParser.ValDclContext,0)


        def varDcl(self):
            return self.getTypedRuleContext(ScalaParser.VarDclContext,0)


        def funDcl(self):
            return self.getTypedRuleContext(ScalaParser.FunDclContext,0)


        def typeDcl(self):
            return self.getTypedRuleContext(ScalaParser.TypeDclContext,0)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(ScalaParser.NL)
            else:
                return self.getToken(ScalaParser.NL, i)

        def getRuleIndex(self):
            return ScalaParser.RULE_dcl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDcl" ):
                listener.enterDcl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDcl" ):
                listener.exitDcl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDcl" ):
                return visitor.visitDcl(self)
            else:
                return visitor.visitChildren(self)




    def dcl(self):

        localctx = ScalaParser.DclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_dcl)
        self._la = 0 # Token type
        try:
            self.state = 1140
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [16]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1126
                self.match(ScalaParser.T__15)
                self.state = 1127
                self.valDcl()
                pass
            elif token in [48]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1128
                self.match(ScalaParser.T__47)
                self.state = 1129
                self.varDcl()
                pass
            elif token in [56]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1130
                self.match(ScalaParser.T__55)
                self.state = 1131
                self.funDcl()
                pass
            elif token in [15]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1132
                self.match(ScalaParser.T__14)
                self.state = 1136
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==74:
                    self.state = 1133
                    self.match(ScalaParser.NL)
                    self.state = 1138
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1139
                self.typeDcl()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValDclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ids(self):
            return self.getTypedRuleContext(ScalaParser.IdsContext,0)


        def type_(self):
            return self.getTypedRuleContext(ScalaParser.Type_Context,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_valDcl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValDcl" ):
                listener.enterValDcl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValDcl" ):
                listener.exitValDcl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValDcl" ):
                return visitor.visitValDcl(self)
            else:
                return visitor.visitChildren(self)




    def valDcl(self):

        localctx = ScalaParser.ValDclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_valDcl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1142
            self.ids()
            self.state = 1143
            self.match(ScalaParser.T__18)
            self.state = 1144
            self.type_()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarDclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ids(self):
            return self.getTypedRuleContext(ScalaParser.IdsContext,0)


        def type_(self):
            return self.getTypedRuleContext(ScalaParser.Type_Context,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_varDcl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarDcl" ):
                listener.enterVarDcl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarDcl" ):
                listener.exitVarDcl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarDcl" ):
                return visitor.visitVarDcl(self)
            else:
                return visitor.visitChildren(self)




    def varDcl(self):

        localctx = ScalaParser.VarDclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_varDcl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1146
            self.ids()
            self.state = 1147
            self.match(ScalaParser.T__18)
            self.state = 1148
            self.type_()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunDclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def funSig(self):
            return self.getTypedRuleContext(ScalaParser.FunSigContext,0)


        def type_(self):
            return self.getTypedRuleContext(ScalaParser.Type_Context,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_funDcl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunDcl" ):
                listener.enterFunDcl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunDcl" ):
                listener.exitFunDcl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunDcl" ):
                return visitor.visitFunDcl(self)
            else:
                return visitor.visitChildren(self)




    def funDcl(self):

        localctx = ScalaParser.FunDclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_funDcl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1150
            self.funSig()
            self.state = 1153
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==19:
                self.state = 1151
                self.match(ScalaParser.T__18)
                self.state = 1152
                self.type_()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunSigContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def paramClauses(self):
            return self.getTypedRuleContext(ScalaParser.ParamClausesContext,0)


        def funTypeParamClause(self):
            return self.getTypedRuleContext(ScalaParser.FunTypeParamClauseContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_funSig

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunSig" ):
                listener.enterFunSig(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunSig" ):
                listener.exitFunSig(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunSig" ):
                return visitor.visitFunSig(self)
            else:
                return visitor.visitChildren(self)




    def funSig(self):

        localctx = ScalaParser.FunSigContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_funSig)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1155
            self.match(ScalaParser.Id)
            self.state = 1157
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==7:
                self.state = 1156
                self.funTypeParamClause()


            self.state = 1159
            self.paramClauses()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeDclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def typeParamClause(self):
            return self.getTypedRuleContext(ScalaParser.TypeParamClauseContext,0)


        def type_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.Type_Context)
            else:
                return self.getTypedRuleContext(ScalaParser.Type_Context,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_typeDcl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeDcl" ):
                listener.enterTypeDcl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeDcl" ):
                listener.exitTypeDcl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeDcl" ):
                return visitor.visitTypeDcl(self)
            else:
                return visitor.visitChildren(self)




    def typeDcl(self):

        localctx = ScalaParser.TypeDclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_typeDcl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1161
            self.match(ScalaParser.Id)
            self.state = 1163
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==7:
                self.state = 1162
                self.typeParamClause()


            self.state = 1167
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==45:
                self.state = 1165
                self.match(ScalaParser.T__44)
                self.state = 1166
                self.type_()


            self.state = 1171
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==46:
                self.state = 1169
                self.match(ScalaParser.T__45)
                self.state = 1170
                self.type_()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PatVarDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def patDef(self):
            return self.getTypedRuleContext(ScalaParser.PatDefContext,0)


        def varDef(self):
            return self.getTypedRuleContext(ScalaParser.VarDefContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_patVarDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPatVarDef" ):
                listener.enterPatVarDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPatVarDef" ):
                listener.exitPatVarDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPatVarDef" ):
                return visitor.visitPatVarDef(self)
            else:
                return visitor.visitChildren(self)




    def patVarDef(self):

        localctx = ScalaParser.PatVarDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_patVarDef)
        try:
            self.state = 1177
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [16]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1173
                self.match(ScalaParser.T__15)
                self.state = 1174
                self.patDef()
                pass
            elif token in [48]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1175
                self.match(ScalaParser.T__47)
                self.state = 1176
                self.varDef()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Def_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def patVarDef(self):
            return self.getTypedRuleContext(ScalaParser.PatVarDefContext,0)


        def funDef(self):
            return self.getTypedRuleContext(ScalaParser.FunDefContext,0)


        def typeDef(self):
            return self.getTypedRuleContext(ScalaParser.TypeDefContext,0)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(ScalaParser.NL)
            else:
                return self.getToken(ScalaParser.NL, i)

        def tmplDef(self):
            return self.getTypedRuleContext(ScalaParser.TmplDefContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_def_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDef_" ):
                listener.enterDef_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDef_" ):
                listener.exitDef_(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDef_" ):
                return visitor.visitDef_(self)
            else:
                return visitor.visitChildren(self)




    def def_(self):

        localctx = ScalaParser.Def_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_def_)
        self._la = 0 # Token type
        try:
            self.state = 1191
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [16, 48]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1179
                self.patVarDef()
                pass
            elif token in [56]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1180
                self.match(ScalaParser.T__55)
                self.state = 1181
                self.funDef()
                pass
            elif token in [15]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1182
                self.match(ScalaParser.T__14)
                self.state = 1186
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==74:
                    self.state = 1183
                    self.match(ScalaParser.NL)
                    self.state = 1188
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1189
                self.typeDef()
                pass
            elif token in [42, 57, 58, 59]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1190
                self.tmplDef()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PatDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pattern2(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.Pattern2Context)
            else:
                return self.getTypedRuleContext(ScalaParser.Pattern2Context,i)


        def expr(self):
            return self.getTypedRuleContext(ScalaParser.ExprContext,0)


        def type_(self):
            return self.getTypedRuleContext(ScalaParser.Type_Context,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_patDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPatDef" ):
                listener.enterPatDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPatDef" ):
                listener.exitPatDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPatDef" ):
                return visitor.visitPatDef(self)
            else:
                return visitor.visitChildren(self)




    def patDef(self):

        localctx = ScalaParser.PatDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_patDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1193
            self.pattern2()
            self.state = 1198
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 1194
                self.match(ScalaParser.T__3)
                self.state = 1195
                self.pattern2()
                self.state = 1200
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1203
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==19:
                self.state = 1201
                self.match(ScalaParser.T__18)
                self.state = 1202
                self.type_()


            self.state = 1205
            self.match(ScalaParser.T__33)
            self.state = 1206
            self.expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def patDef(self):
            return self.getTypedRuleContext(ScalaParser.PatDefContext,0)


        def ids(self):
            return self.getTypedRuleContext(ScalaParser.IdsContext,0)


        def type_(self):
            return self.getTypedRuleContext(ScalaParser.Type_Context,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_varDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarDef" ):
                listener.enterVarDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarDef" ):
                listener.exitVarDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarDef" ):
                return visitor.visitVarDef(self)
            else:
                return visitor.visitChildren(self)




    def varDef(self):

        localctx = ScalaParser.VarDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_varDef)
        try:
            self.state = 1215
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,167,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1208
                self.patDef()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1209
                self.ids()
                self.state = 1210
                self.match(ScalaParser.T__18)
                self.state = 1211
                self.type_()
                self.state = 1212
                self.match(ScalaParser.T__33)
                self.state = 1213
                self.match(ScalaParser.T__19)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def funSig(self):
            return self.getTypedRuleContext(ScalaParser.FunSigContext,0)


        def expr(self):
            return self.getTypedRuleContext(ScalaParser.ExprContext,0)


        def type_(self):
            return self.getTypedRuleContext(ScalaParser.Type_Context,0)


        def block(self):
            return self.getTypedRuleContext(ScalaParser.BlockContext,0)


        def NL(self):
            return self.getToken(ScalaParser.NL, 0)

        def paramClause(self):
            return self.getTypedRuleContext(ScalaParser.ParamClauseContext,0)


        def paramClauses(self):
            return self.getTypedRuleContext(ScalaParser.ParamClausesContext,0)


        def constrExpr(self):
            return self.getTypedRuleContext(ScalaParser.ConstrExprContext,0)


        def constrBlock(self):
            return self.getTypedRuleContext(ScalaParser.ConstrBlockContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_funDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunDef" ):
                listener.enterFunDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunDef" ):
                listener.exitFunDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunDef" ):
                return visitor.visitFunDef(self)
            else:
                return visitor.visitChildren(self)




    def funDef(self):

        localctx = ScalaParser.FunDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_funDef)
        self._la = 0 # Token type
        try:
            self.state = 1244
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,172,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1217
                self.funSig()
                self.state = 1220
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==19:
                    self.state = 1218
                    self.match(ScalaParser.T__18)
                    self.state = 1219
                    self.type_()


                self.state = 1222
                self.match(ScalaParser.T__33)
                self.state = 1223
                self.expr()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1225
                self.funSig()
                self.state = 1227
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==74:
                    self.state = 1226
                    self.match(ScalaParser.NL)


                self.state = 1229
                self.match(ScalaParser.T__12)
                self.state = 1230
                self.block()
                self.state = 1231
                self.match(ScalaParser.T__13)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1233
                self.match(ScalaParser.T__4)
                self.state = 1234
                self.paramClause()
                self.state = 1235
                self.paramClauses()
                self.state = 1242
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [34]:
                    self.state = 1236
                    self.match(ScalaParser.T__33)
                    self.state = 1237
                    self.constrExpr()
                    pass
                elif token in [13, 74]:
                    self.state = 1239
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==74:
                        self.state = 1238
                        self.match(ScalaParser.NL)


                    self.state = 1241
                    self.constrBlock()
                    pass
                else:
                    raise NoViableAltException(self)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def type_(self):
            return self.getTypedRuleContext(ScalaParser.Type_Context,0)


        def typeParamClause(self):
            return self.getTypedRuleContext(ScalaParser.TypeParamClauseContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_typeDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeDef" ):
                listener.enterTypeDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeDef" ):
                listener.exitTypeDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeDef" ):
                return visitor.visitTypeDef(self)
            else:
                return visitor.visitChildren(self)




    def typeDef(self):

        localctx = ScalaParser.TypeDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_typeDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1246
            self.match(ScalaParser.Id)
            self.state = 1248
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==7:
                self.state = 1247
                self.typeParamClause()


            self.state = 1250
            self.match(ScalaParser.T__33)
            self.state = 1251
            self.type_()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TmplDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classDef(self):
            return self.getTypedRuleContext(ScalaParser.ClassDefContext,0)


        def objectDef(self):
            return self.getTypedRuleContext(ScalaParser.ObjectDefContext,0)


        def traitDef(self):
            return self.getTypedRuleContext(ScalaParser.TraitDefContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_tmplDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTmplDef" ):
                listener.enterTmplDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTmplDef" ):
                listener.exitTmplDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTmplDef" ):
                return visitor.visitTmplDef(self)
            else:
                return visitor.visitChildren(self)




    def tmplDef(self):

        localctx = ScalaParser.TmplDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_tmplDef)
        self._la = 0 # Token type
        try:
            self.state = 1265
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,176,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1254
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==42:
                    self.state = 1253
                    self.match(ScalaParser.T__41)


                self.state = 1256
                self.match(ScalaParser.T__56)
                self.state = 1257
                self.classDef()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1259
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==42:
                    self.state = 1258
                    self.match(ScalaParser.T__41)


                self.state = 1261
                self.match(ScalaParser.T__57)
                self.state = 1262
                self.objectDef()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1263
                self.match(ScalaParser.T__58)
                self.state = 1264
                self.traitDef()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def classParamClauses(self):
            return self.getTypedRuleContext(ScalaParser.ClassParamClausesContext,0)


        def classTemplateOpt(self):
            return self.getTypedRuleContext(ScalaParser.ClassTemplateOptContext,0)


        def typeParamClause(self):
            return self.getTypedRuleContext(ScalaParser.TypeParamClauseContext,0)


        def constrAnnotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.ConstrAnnotationContext)
            else:
                return self.getTypedRuleContext(ScalaParser.ConstrAnnotationContext,i)


        def accessModifier(self):
            return self.getTypedRuleContext(ScalaParser.AccessModifierContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_classDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassDef" ):
                listener.enterClassDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassDef" ):
                listener.exitClassDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassDef" ):
                return visitor.visitClassDef(self)
            else:
                return visitor.visitChildren(self)




    def classDef(self):

        localctx = ScalaParser.ClassDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_classDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1267
            self.match(ScalaParser.Id)
            self.state = 1269
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==7:
                self.state = 1268
                self.typeParamClause()


            self.state = 1274
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,178,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1271
                    self.constrAnnotation() 
                self.state = 1276
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,178,self._ctx)

            self.state = 1278
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,179,self._ctx)
            if la_ == 1:
                self.state = 1277
                self.accessModifier()


            self.state = 1280
            self.classParamClauses()
            self.state = 1281
            self.classTemplateOpt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraitDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def traitTemplateOpt(self):
            return self.getTypedRuleContext(ScalaParser.TraitTemplateOptContext,0)


        def typeParamClause(self):
            return self.getTypedRuleContext(ScalaParser.TypeParamClauseContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_traitDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraitDef" ):
                listener.enterTraitDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraitDef" ):
                listener.exitTraitDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraitDef" ):
                return visitor.visitTraitDef(self)
            else:
                return visitor.visitChildren(self)




    def traitDef(self):

        localctx = ScalaParser.TraitDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_traitDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1283
            self.match(ScalaParser.Id)
            self.state = 1285
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==7:
                self.state = 1284
                self.typeParamClause()


            self.state = 1287
            self.traitTemplateOpt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self):
            return self.getToken(ScalaParser.Id, 0)

        def classTemplateOpt(self):
            return self.getTypedRuleContext(ScalaParser.ClassTemplateOptContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_objectDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectDef" ):
                listener.enterObjectDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectDef" ):
                listener.exitObjectDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectDef" ):
                return visitor.visitObjectDef(self)
            else:
                return visitor.visitChildren(self)




    def objectDef(self):

        localctx = ScalaParser.ObjectDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_objectDef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1289
            self.match(ScalaParser.Id)
            self.state = 1290
            self.classTemplateOpt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassTemplateOptContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classTemplate(self):
            return self.getTypedRuleContext(ScalaParser.ClassTemplateContext,0)


        def templateBody(self):
            return self.getTypedRuleContext(ScalaParser.TemplateBodyContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_classTemplateOpt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassTemplateOpt" ):
                listener.enterClassTemplateOpt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassTemplateOpt" ):
                listener.exitClassTemplateOpt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassTemplateOpt" ):
                return visitor.visitClassTemplateOpt(self)
            else:
                return visitor.visitChildren(self)




    def classTemplateOpt(self):

        localctx = ScalaParser.ClassTemplateOptContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_classTemplateOpt)
        self._la = 0 # Token type
        try:
            self.state = 1300
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,183,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1292
                self.match(ScalaParser.T__59)
                self.state = 1293
                self.classTemplate()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1298
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,182,self._ctx)
                if la_ == 1:
                    self.state = 1295
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==60:
                        self.state = 1294
                        self.match(ScalaParser.T__59)


                    self.state = 1297
                    self.templateBody()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraitTemplateOptContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def traitTemplate(self):
            return self.getTypedRuleContext(ScalaParser.TraitTemplateContext,0)


        def templateBody(self):
            return self.getTypedRuleContext(ScalaParser.TemplateBodyContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_traitTemplateOpt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraitTemplateOpt" ):
                listener.enterTraitTemplateOpt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraitTemplateOpt" ):
                listener.exitTraitTemplateOpt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraitTemplateOpt" ):
                return visitor.visitTraitTemplateOpt(self)
            else:
                return visitor.visitChildren(self)




    def traitTemplateOpt(self):

        localctx = ScalaParser.TraitTemplateOptContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_traitTemplateOpt)
        self._la = 0 # Token type
        try:
            self.state = 1310
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,186,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1302
                self.match(ScalaParser.T__59)
                self.state = 1303
                self.traitTemplate()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1308
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,185,self._ctx)
                if la_ == 1:
                    self.state = 1305
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==60:
                        self.state = 1304
                        self.match(ScalaParser.T__59)


                    self.state = 1307
                    self.templateBody()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassTemplateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classParents(self):
            return self.getTypedRuleContext(ScalaParser.ClassParentsContext,0)


        def earlyDefs(self):
            return self.getTypedRuleContext(ScalaParser.EarlyDefsContext,0)


        def templateBody(self):
            return self.getTypedRuleContext(ScalaParser.TemplateBodyContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_classTemplate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassTemplate" ):
                listener.enterClassTemplate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassTemplate" ):
                listener.exitClassTemplate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassTemplate" ):
                return visitor.visitClassTemplate(self)
            else:
                return visitor.visitChildren(self)




    def classTemplate(self):

        localctx = ScalaParser.ClassTemplateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_classTemplate)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1313
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==13:
                self.state = 1312
                self.earlyDefs()


            self.state = 1315
            self.classParents()
            self.state = 1317
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,188,self._ctx)
            if la_ == 1:
                self.state = 1316
                self.templateBody()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraitTemplateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def traitParents(self):
            return self.getTypedRuleContext(ScalaParser.TraitParentsContext,0)


        def earlyDefs(self):
            return self.getTypedRuleContext(ScalaParser.EarlyDefsContext,0)


        def templateBody(self):
            return self.getTypedRuleContext(ScalaParser.TemplateBodyContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_traitTemplate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraitTemplate" ):
                listener.enterTraitTemplate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraitTemplate" ):
                listener.exitTraitTemplate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraitTemplate" ):
                return visitor.visitTraitTemplate(self)
            else:
                return visitor.visitChildren(self)




    def traitTemplate(self):

        localctx = ScalaParser.TraitTemplateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_traitTemplate)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1320
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==13:
                self.state = 1319
                self.earlyDefs()


            self.state = 1322
            self.traitParents()
            self.state = 1324
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,190,self._ctx)
            if la_ == 1:
                self.state = 1323
                self.templateBody()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassParentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constr(self):
            return self.getTypedRuleContext(ScalaParser.ConstrContext,0)


        def annotType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.AnnotTypeContext)
            else:
                return self.getTypedRuleContext(ScalaParser.AnnotTypeContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_classParents

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassParents" ):
                listener.enterClassParents(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassParents" ):
                listener.exitClassParents(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassParents" ):
                return visitor.visitClassParents(self)
            else:
                return visitor.visitChildren(self)




    def classParents(self):

        localctx = ScalaParser.ClassParentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_classParents)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1326
            self.constr()
            self.state = 1331
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,191,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1327
                    self.match(ScalaParser.T__16)
                    self.state = 1328
                    self.annotType() 
                self.state = 1333
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,191,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraitParentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.AnnotTypeContext)
            else:
                return self.getTypedRuleContext(ScalaParser.AnnotTypeContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_traitParents

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraitParents" ):
                listener.enterTraitParents(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraitParents" ):
                listener.exitTraitParents(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraitParents" ):
                return visitor.visitTraitParents(self)
            else:
                return visitor.visitChildren(self)




    def traitParents(self):

        localctx = ScalaParser.TraitParentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_traitParents)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1334
            self.annotType()
            self.state = 1339
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==17:
                self.state = 1335
                self.match(ScalaParser.T__16)
                self.state = 1336
                self.annotType()
                self.state = 1341
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstrContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotType(self):
            return self.getTypedRuleContext(ScalaParser.AnnotTypeContext,0)


        def argumentExprs(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.ArgumentExprsContext)
            else:
                return self.getTypedRuleContext(ScalaParser.ArgumentExprsContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_constr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstr" ):
                listener.enterConstr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstr" ):
                listener.exitConstr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstr" ):
                return visitor.visitConstr(self)
            else:
                return visitor.visitChildren(self)




    def constr(self):

        localctx = ScalaParser.ConstrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_constr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1342
            self.annotType()
            self.state = 1346
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,193,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1343
                    self.argumentExprs() 
                self.state = 1348
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,193,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EarlyDefsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def earlyDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.EarlyDefContext)
            else:
                return self.getTypedRuleContext(ScalaParser.EarlyDefContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_earlyDefs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEarlyDefs" ):
                listener.enterEarlyDefs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEarlyDefs" ):
                listener.exitEarlyDefs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEarlyDefs" ):
                return visitor.visitEarlyDefs(self)
            else:
                return visitor.visitChildren(self)




    def earlyDefs(self):

        localctx = ScalaParser.EarlyDefsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_earlyDefs)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1349
            self.match(ScalaParser.T__12)
            self.state = 1351 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1350
                self.earlyDef()
                self.state = 1353 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((_la) & ~0x3f) == 0 and ((1 << _la) & 35766013744185344) != 0):
                    break

            self.state = 1355
            self.match(ScalaParser.T__13)
            self.state = 1356
            self.match(ScalaParser.T__16)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EarlyDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def patVarDef(self):
            return self.getTypedRuleContext(ScalaParser.PatVarDefContext,0)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ScalaParser.AnnotationContext,i)


        def modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.ModifierContext)
            else:
                return self.getTypedRuleContext(ScalaParser.ModifierContext,i)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(ScalaParser.NL)
            else:
                return self.getToken(ScalaParser.NL, i)

        def getRuleIndex(self):
            return ScalaParser.RULE_earlyDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEarlyDef" ):
                listener.enterEarlyDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEarlyDef" ):
                listener.exitEarlyDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEarlyDef" ):
                return visitor.visitEarlyDef(self)
            else:
                return visitor.visitChildren(self)




    def earlyDef(self):

        localctx = ScalaParser.EarlyDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_earlyDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1364
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==44:
                self.state = 1358
                self.annotation()
                self.state = 1360
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==74:
                    self.state = 1359
                    self.match(ScalaParser.NL)


                self.state = 1366
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1370
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & 35466946581364736) != 0:
                self.state = 1367
                self.modifier()
                self.state = 1372
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1373
            self.patVarDef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstrExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def selfInvocation(self):
            return self.getTypedRuleContext(ScalaParser.SelfInvocationContext,0)


        def constrBlock(self):
            return self.getTypedRuleContext(ScalaParser.ConstrBlockContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_constrExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstrExpr" ):
                listener.enterConstrExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstrExpr" ):
                listener.exitConstrExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstrExpr" ):
                return visitor.visitConstrExpr(self)
            else:
                return visitor.visitChildren(self)




    def constrExpr(self):

        localctx = ScalaParser.ConstrExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_constrExpr)
        try:
            self.state = 1377
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1375
                self.selfInvocation()
                pass
            elif token in [13]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1376
                self.constrBlock()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstrBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def selfInvocation(self):
            return self.getTypedRuleContext(ScalaParser.SelfInvocationContext,0)


        def blockStat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.BlockStatContext)
            else:
                return self.getTypedRuleContext(ScalaParser.BlockStatContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_constrBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstrBlock" ):
                listener.enterConstrBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstrBlock" ):
                listener.exitConstrBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstrBlock" ):
                return visitor.visitConstrBlock(self)
            else:
                return visitor.visitChildren(self)




    def constrBlock(self):

        localctx = ScalaParser.ConstrBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_constrBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1379
            self.match(ScalaParser.T__12)
            self.state = 1380
            self.selfInvocation()
            self.state = 1384
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & -3486606401368644506) != 0 or (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 31) != 0:
                self.state = 1381
                self.blockStat()
                self.state = 1386
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1387
            self.match(ScalaParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelfInvocationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def argumentExprs(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.ArgumentExprsContext)
            else:
                return self.getTypedRuleContext(ScalaParser.ArgumentExprsContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_selfInvocation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelfInvocation" ):
                listener.enterSelfInvocation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelfInvocation" ):
                listener.exitSelfInvocation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelfInvocation" ):
                return visitor.visitSelfInvocation(self)
            else:
                return visitor.visitChildren(self)




    def selfInvocation(self):

        localctx = ScalaParser.SelfInvocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_selfInvocation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1389
            self.match(ScalaParser.T__4)
            self.state = 1391 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1390
                    self.argumentExprs()

                else:
                    raise NoViableAltException(self)
                self.state = 1393 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,200,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopStatSeqContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def topStat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.TopStatContext)
            else:
                return self.getTypedRuleContext(ScalaParser.TopStatContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_topStatSeq

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopStatSeq" ):
                listener.enterTopStatSeq(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopStatSeq" ):
                listener.exitTopStatSeq(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTopStatSeq" ):
                return visitor.visitTopStatSeq(self)
            else:
                return visitor.visitChildren(self)




    def topStatSeq(self):

        localctx = ScalaParser.TopStatSeqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_topStatSeq)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1396 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1395
                self.topStat()
                self.state = 1398 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((_la) & ~0x3f) == 0 and ((1 << _la) & 3386167059577569280) != 0):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopStatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tmplDef(self):
            return self.getTypedRuleContext(ScalaParser.TmplDefContext,0)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ScalaParser.AnnotationContext,i)


        def modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.ModifierContext)
            else:
                return self.getTypedRuleContext(ScalaParser.ModifierContext,i)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(ScalaParser.NL)
            else:
                return self.getToken(ScalaParser.NL, i)

        def import_(self):
            return self.getTypedRuleContext(ScalaParser.Import_Context,0)


        def packaging(self):
            return self.getTypedRuleContext(ScalaParser.PackagingContext,0)


        def packageObject(self):
            return self.getTypedRuleContext(ScalaParser.PackageObjectContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_topStat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopStat" ):
                listener.enterTopStat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopStat" ):
                listener.exitTopStat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTopStat" ):
                return visitor.visitTopStat(self)
            else:
                return visitor.visitChildren(self)




    def topStat(self):

        localctx = ScalaParser.TopStatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_topStat)
        self._la = 0 # Token type
        try:
            self.state = 1419
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,205,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1406
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==44:
                    self.state = 1400
                    self.annotation()
                    self.state = 1402
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==74:
                        self.state = 1401
                        self.match(ScalaParser.NL)


                    self.state = 1408
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1412
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((_la) & ~0x3f) == 0 and ((1 << _la) & 35466946581364736) != 0:
                    self.state = 1409
                    self.modifier()
                    self.state = 1414
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1415
                self.tmplDef()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1416
                self.import_()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1417
                self.packaging()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1418
                self.packageObject()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PackagingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualId(self):
            return self.getTypedRuleContext(ScalaParser.QualIdContext,0)


        def topStatSeq(self):
            return self.getTypedRuleContext(ScalaParser.TopStatSeqContext,0)


        def NL(self):
            return self.getToken(ScalaParser.NL, 0)

        def getRuleIndex(self):
            return ScalaParser.RULE_packaging

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPackaging" ):
                listener.enterPackaging(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPackaging" ):
                listener.exitPackaging(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPackaging" ):
                return visitor.visitPackaging(self)
            else:
                return visitor.visitChildren(self)




    def packaging(self):

        localctx = ScalaParser.PackagingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_packaging)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1421
            self.match(ScalaParser.T__60)
            self.state = 1422
            self.qualId()
            self.state = 1424
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==74:
                self.state = 1423
                self.match(ScalaParser.NL)


            self.state = 1426
            self.match(ScalaParser.T__12)
            self.state = 1427
            self.topStatSeq()
            self.state = 1428
            self.match(ScalaParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PackageObjectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def objectDef(self):
            return self.getTypedRuleContext(ScalaParser.ObjectDefContext,0)


        def getRuleIndex(self):
            return ScalaParser.RULE_packageObject

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPackageObject" ):
                listener.enterPackageObject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPackageObject" ):
                listener.exitPackageObject(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPackageObject" ):
                return visitor.visitPackageObject(self)
            else:
                return visitor.visitChildren(self)




    def packageObject(self):

        localctx = ScalaParser.PackageObjectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_packageObject)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1430
            self.match(ScalaParser.T__60)
            self.state = 1431
            self.match(ScalaParser.T__57)
            self.state = 1432
            self.objectDef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompilationUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def topStatSeq(self):
            return self.getTypedRuleContext(ScalaParser.TopStatSeqContext,0)


        def EOF(self):
            return self.getToken(ScalaParser.EOF, 0)

        def qualId(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ScalaParser.QualIdContext)
            else:
                return self.getTypedRuleContext(ScalaParser.QualIdContext,i)


        def getRuleIndex(self):
            return ScalaParser.RULE_compilationUnit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompilationUnit" ):
                listener.enterCompilationUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompilationUnit" ):
                listener.exitCompilationUnit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompilationUnit" ):
                return visitor.visitCompilationUnit(self)
            else:
                return visitor.visitChildren(self)




    def compilationUnit(self):

        localctx = ScalaParser.CompilationUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_compilationUnit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1438
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,207,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1434
                    self.match(ScalaParser.T__60)
                    self.state = 1435
                    self.qualId() 
                self.state = 1440
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,207,self._ctx)

            self.state = 1441
            self.topStatSeq()
            self.state = 1442
            self.match(ScalaParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[3] = self.stableId_sempred
        self._predicates[12] = self.simpleType_sempred
        self._predicates[23] = self.infixExpr_sempred
        self._predicates[26] = self.simpleExpr1_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def stableId_sempred(self, localctx:StableIdContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 2)
         

    def simpleType_sempred(self, localctx:SimpleTypeContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 3)
         

    def infixExpr_sempred(self, localctx:InfixExprContext, predIndex:int):
            if predIndex == 3:
                return self.precpred(self._ctx, 1)
         

    def simpleExpr1_sempred(self, localctx:SimpleExpr1Context, predIndex:int):
            if predIndex == 4:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 1)
         




