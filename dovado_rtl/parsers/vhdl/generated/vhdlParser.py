# Generated from vhdl.g4 by ANTLR 4.11.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,162,2599,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
        91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,
        98,7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,
        2,104,7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,
        7,109,2,110,7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,
        2,115,7,115,2,116,7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,
        7,120,2,121,7,121,2,122,7,122,2,123,7,123,2,124,7,124,2,125,7,125,
        2,126,7,126,2,127,7,127,2,128,7,128,2,129,7,129,2,130,7,130,2,131,
        7,131,2,132,7,132,2,133,7,133,2,134,7,134,2,135,7,135,2,136,7,136,
        2,137,7,137,2,138,7,138,2,139,7,139,2,140,7,140,2,141,7,141,2,142,
        7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,7,146,2,147,7,147,
        2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,7,152,2,153,
        7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,7,158,
        2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,
        7,164,2,165,7,165,2,166,7,166,2,167,7,167,2,168,7,168,2,169,7,169,
        2,170,7,170,2,171,7,171,2,172,7,172,2,173,7,173,2,174,7,174,2,175,
        7,175,2,176,7,176,2,177,7,177,2,178,7,178,2,179,7,179,2,180,7,180,
        2,181,7,181,2,182,7,182,2,183,7,183,2,184,7,184,2,185,7,185,2,186,
        7,186,2,187,7,187,2,188,7,188,2,189,7,189,2,190,7,190,2,191,7,191,
        2,192,7,192,2,193,7,193,2,194,7,194,2,195,7,195,2,196,7,196,2,197,
        7,197,2,198,7,198,2,199,7,199,2,200,7,200,2,201,7,201,2,202,7,202,
        2,203,7,203,2,204,7,204,2,205,7,205,2,206,7,206,2,207,7,207,2,208,
        7,208,2,209,7,209,2,210,7,210,2,211,7,211,2,212,7,212,2,213,7,213,
        2,214,7,214,2,215,7,215,2,216,7,216,2,217,7,217,2,218,7,218,2,219,
        7,219,2,220,7,220,2,221,7,221,2,222,7,222,2,223,7,223,2,224,7,224,
        2,225,7,225,2,226,7,226,2,227,7,227,2,228,7,228,2,229,7,229,2,230,
        7,230,2,231,7,231,2,232,7,232,2,233,7,233,2,234,7,234,2,235,7,235,
        2,236,7,236,2,237,7,237,2,238,7,238,2,239,7,239,2,240,7,240,2,241,
        7,241,2,242,7,242,2,243,7,243,2,244,7,244,2,245,7,245,2,246,7,246,
        2,247,7,247,2,248,7,248,2,249,7,249,2,250,7,250,2,251,7,251,2,252,
        7,252,2,253,7,253,2,254,7,254,1,0,1,0,1,1,1,1,1,1,1,2,1,2,3,2,518,
        8,2,1,2,1,2,3,2,522,8,2,1,2,1,2,1,3,1,3,3,3,528,8,3,1,4,1,4,1,5,
        1,5,1,5,1,5,1,5,1,5,3,5,538,8,5,1,6,1,6,1,7,1,7,1,7,1,7,5,7,546,
        8,7,10,7,12,7,549,9,7,1,7,1,7,1,8,1,8,1,8,1,8,3,8,557,8,8,1,8,1,
        8,1,8,3,8,562,8,8,1,8,1,8,1,9,1,9,1,9,3,9,569,8,9,1,10,1,10,3,10,
        573,8,10,1,11,1,11,1,11,3,11,578,8,11,1,12,1,12,1,12,1,12,1,12,1,
        12,1,12,1,12,1,12,1,12,3,12,590,8,12,1,12,3,12,593,8,12,1,12,1,12,
        1,13,5,13,598,8,13,10,13,12,13,601,9,13,1,14,1,14,1,14,3,14,606,
        8,14,1,14,1,14,3,14,610,8,14,1,14,1,14,3,14,614,8,14,1,14,3,14,617,
        8,14,1,14,1,14,1,14,1,14,1,14,3,14,624,8,14,1,15,5,15,627,8,15,10,
        15,12,15,630,9,15,1,16,1,16,3,16,634,8,16,1,17,1,17,3,17,638,8,17,
        1,18,1,18,1,18,1,18,3,18,644,8,18,1,18,1,18,3,18,648,8,18,1,19,3,
        19,651,8,19,1,19,1,19,1,19,1,20,1,20,1,20,3,20,659,8,20,1,20,1,20,
        1,21,1,21,1,21,5,21,666,8,21,10,21,12,21,669,9,21,1,22,1,22,1,22,
        1,22,1,22,1,23,1,23,1,23,1,23,1,23,1,23,1,23,3,23,683,8,23,1,24,
        1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,25,1,25,1,25,1,26,1,26,3,26,
        698,8,26,1,26,3,26,701,8,26,1,26,3,26,704,8,26,1,27,1,27,1,27,5,
        27,709,8,27,10,27,12,27,712,9,27,1,27,5,27,715,8,27,10,27,12,27,
        718,9,27,1,27,1,27,1,27,1,27,1,28,1,28,1,28,1,28,1,28,1,28,1,28,
        1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,
        1,28,1,28,3,28,746,8,28,1,29,5,29,749,8,29,10,29,12,29,752,9,29,
        1,30,1,30,1,30,1,30,3,30,758,8,30,3,30,760,8,30,1,30,1,30,1,30,1,
        30,3,30,766,8,30,3,30,768,8,30,1,31,1,31,1,31,1,31,1,31,3,31,775,
        8,31,1,31,3,31,778,8,31,1,32,1,32,1,32,1,32,1,32,1,32,3,32,786,8,
        32,1,32,3,32,789,8,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,3,32,798,
        8,32,1,32,1,32,1,33,5,33,803,8,33,10,33,12,33,806,9,33,1,34,1,34,
        3,34,810,8,34,1,34,3,34,813,8,34,1,34,1,34,1,34,1,35,3,35,819,8,
        35,1,35,1,35,1,35,1,35,1,36,1,36,1,36,5,36,828,8,36,10,36,12,36,
        831,9,36,1,37,1,37,1,37,1,37,1,38,3,38,838,8,38,1,38,1,38,3,38,842,
        8,38,1,38,1,38,3,38,846,8,38,1,38,1,38,1,39,3,39,851,8,39,1,39,1,
        39,1,39,1,39,4,39,857,8,39,11,39,12,39,858,1,39,1,39,1,39,3,39,864,
        8,39,1,39,1,39,1,40,1,40,1,40,1,40,1,40,1,41,1,41,1,41,1,41,3,41,
        877,8,41,1,42,1,42,1,42,5,42,882,8,42,10,42,12,42,885,9,42,1,43,
        1,43,1,43,1,43,1,43,3,43,892,8,43,1,43,3,43,895,8,43,1,43,1,43,1,
        43,1,43,1,44,1,44,1,44,3,44,904,8,44,1,44,3,44,907,8,44,1,44,3,44,
        910,8,44,1,44,1,44,1,44,3,44,915,8,44,1,44,1,44,1,45,1,45,1,45,3,
        45,922,8,45,1,45,3,45,925,8,45,1,45,1,45,1,46,1,46,1,46,1,46,1,47,
        1,47,3,47,935,8,47,1,48,1,48,3,48,939,8,48,1,49,3,49,942,8,49,1,
        49,3,49,945,8,49,1,49,1,49,1,49,1,50,3,50,951,8,50,1,50,1,50,3,50,
        955,8,50,1,50,3,50,958,8,50,1,50,1,50,3,50,962,8,50,1,50,1,50,1,
        51,3,51,967,8,51,1,51,3,51,970,8,51,1,51,1,51,1,51,1,52,3,52,976,
        8,52,1,52,3,52,979,8,52,1,52,1,52,3,52,983,8,52,1,53,1,53,1,54,1,
        54,1,54,1,55,1,55,1,55,1,55,1,55,1,55,1,56,1,56,1,56,1,56,1,56,3,
        56,1001,8,56,3,56,1003,8,56,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,
        57,1,57,3,57,1014,8,57,1,57,3,57,1017,8,57,1,57,1,57,1,58,1,58,1,
        58,3,58,1024,8,58,1,59,5,59,1027,8,59,10,59,12,59,1030,9,59,1,60,
        1,60,3,60,1034,8,60,1,61,1,61,1,61,1,61,1,61,1,62,1,62,1,62,1,62,
        1,62,1,62,3,62,1047,8,62,1,62,1,62,1,63,1,63,1,63,1,63,1,63,1,64,
        1,64,1,64,1,64,1,64,1,65,1,65,3,65,1063,8,65,1,66,5,66,1066,8,66,
        10,66,12,66,1069,9,66,1,67,1,67,3,67,1073,8,67,1,68,1,68,1,68,3,
        68,1078,8,68,1,68,3,68,1081,8,68,1,69,5,69,1084,8,69,10,69,12,69,
        1087,9,69,1,69,1,69,1,70,1,70,1,70,1,71,1,71,3,71,1096,8,71,1,72,
        1,72,1,73,1,73,1,73,1,73,1,73,1,73,1,74,1,74,3,74,1108,8,74,1,75,
        1,75,1,75,3,75,1113,8,75,1,75,1,75,1,76,1,76,1,76,1,76,1,76,1,77,
        1,77,1,78,1,78,1,79,1,79,1,79,1,79,1,79,1,79,3,79,1132,8,79,1,79,
        1,79,1,79,3,79,1137,8,79,1,80,1,80,1,81,1,81,3,81,1143,8,81,1,82,
        1,82,1,82,5,82,1148,8,82,10,82,12,82,1151,9,82,1,83,1,83,1,83,1,
        83,1,83,1,83,1,83,3,83,1160,8,83,1,83,1,83,3,83,1164,8,83,1,83,3,
        83,1167,8,83,1,83,1,83,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,
        84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,3,84,1191,
        8,84,1,85,5,85,1194,8,85,10,85,12,85,1197,9,85,1,86,1,86,3,86,1201,
        8,86,1,87,3,87,1204,8,87,1,87,3,87,1207,8,87,1,88,1,88,1,88,5,88,
        1212,8,88,10,88,12,88,1215,9,88,1,88,1,88,3,88,1219,8,88,1,89,1,
        89,1,89,1,89,1,90,1,90,1,90,3,90,1228,8,90,1,91,5,91,1231,8,91,10,
        91,12,91,1234,9,91,1,92,1,92,1,92,3,92,1239,8,92,1,93,1,93,3,93,
        1243,8,93,1,94,1,94,1,94,1,94,5,94,1249,8,94,10,94,12,94,1252,9,
        94,1,94,1,94,1,95,3,95,1257,8,95,1,95,1,95,3,95,1261,8,95,1,95,1,
        95,3,95,1265,8,95,1,95,1,95,1,96,1,96,1,96,1,96,5,96,1273,8,96,10,
        96,12,96,1276,9,96,1,97,1,97,1,97,3,97,1281,8,97,1,97,1,97,1,97,
        1,97,3,97,1287,8,97,1,98,1,98,1,98,1,98,1,98,3,98,1294,8,98,1,98,
        1,98,1,99,1,99,1,100,1,100,3,100,1302,8,100,1,100,1,100,1,100,1,
        101,1,101,1,101,1,101,1,102,1,102,1,103,1,103,1,103,1,103,1,103,
        1,103,3,103,1319,8,103,1,104,1,104,1,104,1,104,1,104,1,104,3,104,
        1327,8,104,1,104,1,104,1,105,1,105,1,105,1,105,5,105,1335,8,105,
        10,105,12,105,1338,9,105,1,105,3,105,1341,8,105,1,105,5,105,1344,
        8,105,10,105,12,105,1347,9,105,1,105,1,105,1,105,3,105,1352,8,105,
        1,105,1,105,1,106,1,106,1,106,1,106,3,106,1360,8,106,1,107,1,107,
        1,107,1,107,1,107,1,107,1,108,1,108,1,108,5,108,1371,8,108,10,108,
        12,108,1374,9,108,1,109,1,109,1,109,1,109,1,109,1,109,1,110,1,110,
        3,110,1384,8,110,1,111,1,111,1,111,5,111,1389,8,111,10,111,12,111,
        1392,9,111,1,112,1,112,1,112,1,112,1,112,1,112,1,112,1,112,1,113,
        1,113,1,113,1,113,1,113,1,113,1,113,1,113,1,114,1,114,1,114,1,114,
        1,115,1,115,1,116,1,116,1,116,5,116,1419,8,116,10,116,12,116,1422,
        9,116,1,117,3,117,1425,8,117,1,117,1,117,1,117,1,117,1,117,1,117,
        1,117,1,117,1,117,5,117,1436,8,117,10,117,12,117,1439,9,117,1,117,
        1,117,3,117,1443,8,117,1,117,1,117,1,117,3,117,1448,8,117,1,117,
        1,117,1,118,1,118,1,118,1,118,5,118,1456,8,118,10,118,12,118,1459,
        9,118,1,118,1,118,1,119,1,119,3,119,1465,8,119,1,120,1,120,1,120,
        1,120,1,121,3,121,1472,8,121,1,121,1,121,1,121,1,121,1,121,1,121,
        1,121,3,121,1481,8,121,1,121,1,121,3,121,1485,8,121,1,122,1,122,
        1,122,5,122,1490,8,122,10,122,12,122,1493,9,122,1,122,1,122,3,122,
        1497,8,122,1,123,3,123,1500,8,123,1,123,1,123,1,123,3,123,1505,8,
        123,1,123,1,123,1,123,3,123,1510,8,123,1,124,1,124,1,124,1,124,1,
        124,1,124,3,124,1518,8,124,1,125,1,125,1,126,1,126,1,126,1,126,1,
        126,1,127,1,127,1,127,5,127,1530,8,127,10,127,12,127,1533,9,127,
        1,128,1,128,1,128,5,128,1538,8,128,10,128,12,128,1541,9,128,1,129,
        1,129,1,129,5,129,1546,8,129,10,129,12,129,1549,9,129,1,130,1,130,
        1,130,1,130,3,130,1555,8,130,1,130,1,130,1,130,3,130,1560,8,130,
        1,131,1,131,1,131,3,131,1565,8,131,1,131,1,131,3,131,1569,8,131,
        1,131,1,131,3,131,1573,8,131,1,132,1,132,1,132,1,132,3,132,1579,
        8,132,1,132,1,132,3,132,1583,8,132,1,132,1,132,3,132,1587,8,132,
        1,133,1,133,1,133,1,133,1,133,1,134,3,134,1595,8,134,1,134,1,134,
        1,134,3,134,1600,8,134,1,134,1,134,1,134,3,134,1605,8,134,1,135,
        1,135,1,135,1,135,3,135,1611,8,135,1,136,1,136,1,136,1,137,1,137,
        1,137,1,137,1,138,1,138,3,138,1622,8,138,1,139,1,139,1,139,1,139,
        1,139,3,139,1629,8,139,1,140,1,140,1,141,1,141,1,141,5,141,1636,
        8,141,10,141,12,141,1639,9,141,1,142,1,142,1,143,3,143,1644,8,143,
        1,143,3,143,1647,8,143,1,143,1,143,1,143,1,143,1,143,3,143,1654,
        8,143,1,143,1,143,1,144,1,144,1,145,1,145,1,146,1,146,3,146,1664,
        8,146,1,146,5,146,1667,8,146,10,146,12,146,1670,9,146,1,147,1,147,
        1,147,1,147,3,147,1676,8,147,1,148,1,148,1,148,5,148,1681,8,148,
        10,148,12,148,1684,9,148,1,149,1,149,4,149,1688,8,149,11,149,12,
        149,1689,1,150,1,150,1,150,1,150,1,151,1,151,1,151,1,151,1,152,3,
        152,1701,8,152,1,152,1,152,1,152,1,152,1,152,1,152,3,152,1709,8,
        152,1,153,1,153,1,153,1,153,1,153,1,153,1,154,1,154,3,154,1719,8,
        154,1,155,1,155,1,155,1,155,1,156,3,156,1726,8,156,1,156,1,156,3,
        156,1730,8,156,1,156,1,156,3,156,1734,8,156,1,156,1,156,1,157,1,
        157,3,157,1740,8,157,1,158,1,158,1,158,1,158,1,158,1,158,3,158,1748,
        8,158,1,159,3,159,1751,8,159,1,159,3,159,1754,8,159,1,160,1,160,
        1,160,1,160,1,160,1,160,1,160,1,160,3,160,1764,8,160,1,160,3,160,
        1767,8,160,1,160,1,160,1,161,1,161,1,161,1,161,1,161,1,161,1,161,
        1,161,1,161,1,161,1,161,3,161,1782,8,161,1,162,5,162,1785,8,162,
        10,162,12,162,1788,9,162,1,163,1,163,1,163,1,163,1,163,1,163,3,163,
        1796,8,163,1,163,3,163,1799,8,163,1,163,1,163,1,164,1,164,1,164,
        1,164,1,164,1,164,1,164,1,164,1,164,1,164,1,164,1,164,1,164,1,164,
        1,164,1,164,1,164,1,164,1,164,3,164,1822,8,164,1,165,5,165,1825,
        8,165,10,165,12,165,1828,9,165,1,166,1,166,1,166,1,166,1,167,1,167,
        1,167,1,168,1,168,1,168,1,168,5,168,1841,8,168,10,168,12,168,1844,
        9,168,1,168,1,168,1,168,3,168,1849,8,168,1,169,1,169,1,169,1,169,
        1,169,1,169,1,170,1,170,1,171,1,171,1,171,1,171,1,171,1,171,1,172,
        1,172,1,172,1,172,1,172,1,172,1,172,1,172,1,172,3,172,1874,8,172,
        1,173,1,173,1,173,3,173,1879,8,173,1,174,1,174,1,174,1,174,1,174,
        1,174,1,174,1,174,1,174,1,174,1,174,1,174,3,174,1893,8,174,1,175,
        5,175,1896,8,175,10,175,12,175,1899,9,175,1,176,5,176,1902,8,176,
        10,176,12,176,1905,9,176,1,177,1,177,1,177,1,177,1,177,3,177,1912,
        8,177,1,178,3,178,1915,8,178,1,178,1,178,1,178,1,179,1,179,1,179,
        1,179,1,179,1,179,1,179,1,179,1,179,1,179,1,179,1,179,1,179,3,179,
        1933,8,179,1,180,5,180,1936,8,180,10,180,12,180,1939,9,180,1,181,
        3,181,1942,8,181,1,181,3,181,1945,8,181,1,181,1,181,1,181,1,181,
        1,181,3,181,1952,8,181,1,181,3,181,1955,8,181,1,181,1,181,1,181,
        1,181,1,181,3,181,1962,8,181,1,181,1,181,3,181,1966,8,181,1,181,
        1,181,1,182,5,182,1971,8,182,10,182,12,182,1974,9,182,1,183,1,183,
        1,183,1,183,1,183,1,183,1,183,3,183,1983,8,183,1,184,1,184,1,184,
        3,184,1988,8,184,1,185,1,185,1,185,5,185,1993,8,185,10,185,12,185,
        1996,9,185,1,185,1,185,3,185,2000,8,185,1,186,1,186,1,186,1,186,
        1,187,1,187,3,187,2008,8,187,1,188,1,188,1,188,1,188,3,188,2014,
        8,188,1,189,1,189,1,189,1,190,1,190,4,190,2021,8,190,11,190,12,190,
        2022,1,190,1,190,1,190,3,190,2028,8,190,1,191,1,191,4,191,2032,8,
        191,11,191,12,191,2033,1,191,1,191,1,191,3,191,2039,8,191,1,192,
        1,192,1,192,1,192,3,192,2045,8,192,1,193,1,193,1,194,3,194,2050,
        8,194,1,194,1,194,1,194,1,194,3,194,2056,8,194,1,194,1,194,1,195,
        3,195,2061,8,195,1,195,1,195,3,195,2065,8,195,1,195,1,195,1,196,
        1,196,1,196,1,196,1,196,1,196,1,196,1,197,1,197,1,197,3,197,2079,
        8,197,1,198,1,198,3,198,2083,8,198,1,199,1,199,1,199,1,199,1,199,
        1,200,1,200,1,200,1,200,1,200,1,200,1,200,1,200,1,200,1,201,1,201,
        1,201,1,201,1,201,1,201,1,201,1,201,5,201,2107,8,201,10,201,12,201,
        2110,9,201,1,202,1,202,1,202,1,203,1,203,1,203,5,203,2118,8,203,
        10,203,12,203,2121,9,203,1,204,5,204,2124,8,204,10,204,12,204,2127,
        9,204,1,205,1,205,1,205,1,205,1,205,1,205,1,205,1,205,1,205,1,205,
        1,205,1,205,3,205,2141,8,205,1,205,1,205,1,205,1,205,3,205,2147,
        8,205,1,206,1,206,1,206,1,206,3,206,2153,8,206,1,207,1,207,1,208,
        3,208,2158,8,208,1,208,1,208,1,208,3,208,2163,8,208,1,208,1,208,
        1,208,1,209,1,209,1,209,1,209,1,209,3,209,2173,8,209,1,209,1,209,
        3,209,2177,8,209,1,209,1,209,1,210,1,210,1,211,1,211,1,211,5,211,
        2186,8,211,10,211,12,211,2189,9,211,1,211,1,211,3,211,2193,8,211,
        1,212,1,212,1,212,1,212,5,212,2199,8,212,10,212,12,212,2202,9,212,
        3,212,2204,8,212,1,212,1,212,3,212,2208,8,212,1,212,1,212,1,213,
        3,213,2213,8,213,1,213,1,213,1,213,1,213,5,213,2219,8,213,10,213,
        12,213,2222,9,213,1,214,3,214,2225,8,214,1,214,1,214,1,214,1,214,
        3,214,2231,8,214,1,214,1,214,1,215,1,215,1,215,1,215,1,215,1,216,
        3,216,2241,8,216,1,216,1,216,1,216,1,216,4,216,2247,8,216,11,216,
        12,216,2248,1,216,1,216,1,216,3,216,2254,8,216,1,216,1,216,1,217,
        3,217,2259,8,217,1,217,1,217,1,217,1,217,1,217,1,217,1,217,1,217,
        1,217,5,217,2270,8,217,10,217,12,217,2273,9,217,1,217,1,217,3,217,
        2277,8,217,1,217,1,217,1,217,3,217,2282,8,217,1,217,1,217,1,218,
        3,218,2287,8,218,1,218,1,218,3,218,2291,8,218,1,218,1,218,1,218,
        1,218,1,218,1,218,3,218,2299,8,218,1,218,1,218,1,219,1,219,1,219,
        1,219,1,219,3,219,2308,8,219,1,219,1,219,3,219,2312,8,219,1,220,
        5,220,2315,8,220,10,220,12,220,2318,9,220,1,221,1,221,1,221,1,221,
        1,221,1,221,1,221,3,221,2327,8,221,1,222,1,222,1,222,1,222,1,222,
        1,222,1,222,1,223,1,223,1,223,1,223,1,223,1,223,1,224,1,224,1,224,
        1,224,1,224,1,224,1,225,1,225,3,225,2350,8,225,1,225,1,225,1,225,
        1,225,1,225,1,225,3,225,2358,8,225,1,226,1,226,1,226,1,226,1,226,
        1,226,1,226,3,226,2367,8,226,1,226,3,226,2370,8,226,1,226,1,226,
        1,227,1,227,1,227,1,228,1,228,1,228,1,228,1,228,1,228,1,228,1,228,
        1,228,1,228,1,228,1,228,1,228,3,228,2390,8,228,1,229,5,229,2393,
        8,229,10,229,12,229,2396,9,229,1,230,1,230,1,231,1,231,3,231,2402,
        8,231,1,232,1,232,1,232,1,232,1,232,1,232,3,232,2410,8,232,1,233,
        3,233,2413,8,233,1,233,1,233,1,233,1,233,1,233,1,233,3,233,2421,
        8,233,1,233,1,233,1,233,1,234,5,234,2427,8,234,10,234,12,234,2430,
        9,234,1,235,1,235,1,235,1,235,1,235,1,235,1,236,1,236,3,236,2440,
        8,236,1,236,3,236,2443,8,236,1,236,3,236,2446,8,236,1,237,1,237,
        1,237,1,237,3,237,2452,8,237,1,238,1,238,3,238,2456,8,238,1,239,
        1,239,1,239,1,239,5,239,2462,8,239,10,239,12,239,2465,9,239,1,240,
        1,240,1,240,3,240,2470,8,240,1,241,1,241,1,241,1,241,1,241,1,241,
        1,242,1,242,3,242,2480,8,242,1,242,1,242,3,242,2484,8,242,1,242,
        1,242,1,243,1,243,1,243,1,244,1,244,1,244,1,245,1,245,1,245,1,245,
        3,245,2498,8,245,1,245,1,245,1,246,1,246,1,246,1,246,3,246,2506,
        8,246,1,247,1,247,1,247,1,247,1,247,5,247,2513,8,247,10,247,12,247,
        2516,9,247,1,247,1,247,1,247,1,247,1,248,1,248,1,248,1,248,1,248,
        5,248,2527,8,248,10,248,12,248,2530,9,248,1,248,1,248,1,248,1,248,
        1,249,1,249,1,249,1,249,5,249,2540,8,249,10,249,12,249,2543,9,249,
        1,249,1,249,1,250,3,250,2548,8,250,1,250,1,250,1,250,1,250,1,250,
        1,251,3,251,2556,8,251,1,251,1,251,1,251,1,251,1,251,1,251,3,251,
        2564,8,251,1,251,1,251,1,252,3,252,2569,8,252,1,252,1,252,3,252,
        2573,8,252,1,252,3,252,2576,8,252,1,252,3,252,2579,8,252,1,252,1,
        252,1,253,1,253,1,253,5,253,2586,8,253,10,253,12,253,2589,9,253,
        1,253,3,253,2592,8,253,1,254,1,254,1,254,3,254,2597,8,254,1,254,
        0,0,255,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,
        42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,
        86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,
        122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,
        154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,
        186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,
        218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,
        250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,
        282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,
        314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,
        346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,
        378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,
        410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,
        442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,472,
        474,476,478,480,482,484,486,488,490,492,494,496,498,500,502,504,
        506,508,0,15,3,0,112,112,117,117,158,158,2,0,140,140,148,149,2,0,
        23,23,97,97,17,0,8,8,19,21,25,25,29,29,31,31,34,34,42,42,46,46,51,
        51,64,64,68,68,71,71,86,86,92,94,100,100,102,102,105,105,1,0,118,
        119,2,0,38,38,63,63,5,0,7,7,50,50,55,55,61,61,110,111,5,0,16,16,
        38,38,40,40,45,45,63,63,3,0,49,49,75,75,146,147,3,0,131,132,134,
        134,150,152,3,0,81,82,87,88,90,91,2,0,17,17,78,78,1,0,148,149,2,
        0,31,31,68,68,2,0,37,37,70,70,2797,0,510,1,0,0,0,2,512,1,0,0,0,4,
        515,1,0,0,0,6,527,1,0,0,0,8,529,1,0,0,0,10,537,1,0,0,0,12,539,1,
        0,0,0,14,541,1,0,0,0,16,552,1,0,0,0,18,568,1,0,0,0,20,572,1,0,0,
        0,22,574,1,0,0,0,24,579,1,0,0,0,26,599,1,0,0,0,28,623,1,0,0,0,30,
        628,1,0,0,0,32,633,1,0,0,0,34,637,1,0,0,0,36,639,1,0,0,0,38,650,
        1,0,0,0,40,658,1,0,0,0,42,662,1,0,0,0,44,670,1,0,0,0,46,682,1,0,
        0,0,48,684,1,0,0,0,50,692,1,0,0,0,52,697,1,0,0,0,54,705,1,0,0,0,
        56,745,1,0,0,0,58,750,1,0,0,0,60,759,1,0,0,0,62,777,1,0,0,0,64,779,
        1,0,0,0,66,804,1,0,0,0,68,807,1,0,0,0,70,818,1,0,0,0,72,824,1,0,
        0,0,74,832,1,0,0,0,76,837,1,0,0,0,78,850,1,0,0,0,80,867,1,0,0,0,
        82,876,1,0,0,0,84,878,1,0,0,0,86,886,1,0,0,0,88,900,1,0,0,0,90,918,
        1,0,0,0,92,928,1,0,0,0,94,934,1,0,0,0,96,938,1,0,0,0,98,941,1,0,
        0,0,100,950,1,0,0,0,102,966,1,0,0,0,104,975,1,0,0,0,106,984,1,0,
        0,0,108,986,1,0,0,0,110,989,1,0,0,0,112,995,1,0,0,0,114,1004,1,0,
        0,0,116,1023,1,0,0,0,118,1028,1,0,0,0,120,1033,1,0,0,0,122,1035,
        1,0,0,0,124,1040,1,0,0,0,126,1050,1,0,0,0,128,1055,1,0,0,0,130,1062,
        1,0,0,0,132,1067,1,0,0,0,134,1072,1,0,0,0,136,1080,1,0,0,0,138,1085,
        1,0,0,0,140,1090,1,0,0,0,142,1095,1,0,0,0,144,1097,1,0,0,0,146,1099,
        1,0,0,0,148,1107,1,0,0,0,150,1112,1,0,0,0,152,1116,1,0,0,0,154,1121,
        1,0,0,0,156,1123,1,0,0,0,158,1136,1,0,0,0,160,1138,1,0,0,0,162,1140,
        1,0,0,0,164,1144,1,0,0,0,166,1152,1,0,0,0,168,1190,1,0,0,0,170,1195,
        1,0,0,0,172,1198,1,0,0,0,174,1203,1,0,0,0,176,1218,1,0,0,0,178,1220,
        1,0,0,0,180,1227,1,0,0,0,182,1232,1,0,0,0,184,1238,1,0,0,0,186,1242,
        1,0,0,0,188,1244,1,0,0,0,190,1256,1,0,0,0,192,1268,1,0,0,0,194,1286,
        1,0,0,0,196,1288,1,0,0,0,198,1297,1,0,0,0,200,1301,1,0,0,0,202,1306,
        1,0,0,0,204,1310,1,0,0,0,206,1318,1,0,0,0,208,1320,1,0,0,0,210,1330,
        1,0,0,0,212,1359,1,0,0,0,214,1361,1,0,0,0,216,1367,1,0,0,0,218,1375,
        1,0,0,0,220,1383,1,0,0,0,222,1385,1,0,0,0,224,1393,1,0,0,0,226,1401,
        1,0,0,0,228,1409,1,0,0,0,230,1413,1,0,0,0,232,1415,1,0,0,0,234,1424,
        1,0,0,0,236,1451,1,0,0,0,238,1464,1,0,0,0,240,1466,1,0,0,0,242,1484,
        1,0,0,0,244,1496,1,0,0,0,246,1499,1,0,0,0,248,1517,1,0,0,0,250,1519,
        1,0,0,0,252,1521,1,0,0,0,254,1526,1,0,0,0,256,1534,1,0,0,0,258,1542,
        1,0,0,0,260,1550,1,0,0,0,262,1561,1,0,0,0,264,1574,1,0,0,0,266,1588,
        1,0,0,0,268,1594,1,0,0,0,270,1610,1,0,0,0,272,1612,1,0,0,0,274,1615,
        1,0,0,0,276,1621,1,0,0,0,278,1628,1,0,0,0,280,1630,1,0,0,0,282,1632,
        1,0,0,0,284,1640,1,0,0,0,286,1643,1,0,0,0,288,1657,1,0,0,0,290,1659,
        1,0,0,0,292,1663,1,0,0,0,294,1675,1,0,0,0,296,1677,1,0,0,0,298,1687,
        1,0,0,0,300,1691,1,0,0,0,302,1695,1,0,0,0,304,1700,1,0,0,0,306,1710,
        1,0,0,0,308,1718,1,0,0,0,310,1720,1,0,0,0,312,1725,1,0,0,0,314,1739,
        1,0,0,0,316,1747,1,0,0,0,318,1750,1,0,0,0,320,1755,1,0,0,0,322,1781,
        1,0,0,0,324,1786,1,0,0,0,326,1789,1,0,0,0,328,1821,1,0,0,0,330,1826,
        1,0,0,0,332,1829,1,0,0,0,334,1833,1,0,0,0,336,1836,1,0,0,0,338,1850,
        1,0,0,0,340,1856,1,0,0,0,342,1858,1,0,0,0,344,1873,1,0,0,0,346,1878,
        1,0,0,0,348,1892,1,0,0,0,350,1897,1,0,0,0,352,1903,1,0,0,0,354,1906,
        1,0,0,0,356,1914,1,0,0,0,358,1932,1,0,0,0,360,1937,1,0,0,0,362,1941,
        1,0,0,0,364,1972,1,0,0,0,366,1975,1,0,0,0,368,1987,1,0,0,0,370,1999,
        1,0,0,0,372,2001,1,0,0,0,374,2007,1,0,0,0,376,2009,1,0,0,0,378,2015,
        1,0,0,0,380,2018,1,0,0,0,382,2029,1,0,0,0,384,2040,1,0,0,0,386,2046,
        1,0,0,0,388,2049,1,0,0,0,390,2060,1,0,0,0,392,2068,1,0,0,0,394,2078,
        1,0,0,0,396,2082,1,0,0,0,398,2084,1,0,0,0,400,2089,1,0,0,0,402,2098,
        1,0,0,0,404,2111,1,0,0,0,406,2114,1,0,0,0,408,2125,1,0,0,0,410,2146,
        1,0,0,0,412,2148,1,0,0,0,414,2154,1,0,0,0,416,2157,1,0,0,0,418,2167,
        1,0,0,0,420,2180,1,0,0,0,422,2192,1,0,0,0,424,2194,1,0,0,0,426,2212,
        1,0,0,0,428,2224,1,0,0,0,430,2234,1,0,0,0,432,2240,1,0,0,0,434,2258,
        1,0,0,0,436,2286,1,0,0,0,438,2311,1,0,0,0,440,2316,1,0,0,0,442,2326,
        1,0,0,0,444,2328,1,0,0,0,446,2335,1,0,0,0,448,2341,1,0,0,0,450,2347,
        1,0,0,0,452,2359,1,0,0,0,454,2373,1,0,0,0,456,2389,1,0,0,0,458,2394,
        1,0,0,0,460,2397,1,0,0,0,462,2401,1,0,0,0,464,2403,1,0,0,0,466,2412,
        1,0,0,0,468,2428,1,0,0,0,470,2431,1,0,0,0,472,2437,1,0,0,0,474,2451,
        1,0,0,0,476,2455,1,0,0,0,478,2457,1,0,0,0,480,2466,1,0,0,0,482,2471,
        1,0,0,0,484,2477,1,0,0,0,486,2487,1,0,0,0,488,2490,1,0,0,0,490,2493,
        1,0,0,0,492,2505,1,0,0,0,494,2507,1,0,0,0,496,2521,1,0,0,0,498,2535,
        1,0,0,0,500,2547,1,0,0,0,502,2555,1,0,0,0,504,2568,1,0,0,0,506,2591,
        1,0,0,0,508,2593,1,0,0,0,510,511,7,0,0,0,511,1,1,0,0,0,512,513,5,
        2,0,0,513,514,3,472,236,0,514,3,1,0,0,0,515,517,3,232,116,0,516,
        518,3,488,244,0,517,516,1,0,0,0,517,518,1,0,0,0,518,521,1,0,0,0,
        519,520,5,135,0,0,520,522,3,192,96,0,521,519,1,0,0,0,521,522,1,0,
        0,0,522,523,1,0,0,0,523,524,5,3,0,0,524,5,1,0,0,0,525,528,3,192,
        96,0,526,528,5,60,0,0,527,525,1,0,0,0,527,526,1,0,0,0,528,7,1,0,
        0,0,529,530,3,42,21,0,530,9,1,0,0,0,531,532,3,292,146,0,532,533,
        5,141,0,0,533,534,3,6,3,0,534,535,5,142,0,0,535,538,1,0,0,0,536,
        538,3,6,3,0,537,531,1,0,0,0,537,536,1,0,0,0,538,11,1,0,0,0,539,540,
        7,1,0,0,540,13,1,0,0,0,541,542,5,141,0,0,542,547,3,150,75,0,543,
        544,5,139,0,0,544,546,3,150,75,0,545,543,1,0,0,0,546,549,1,0,0,0,
        547,545,1,0,0,0,547,548,1,0,0,0,548,550,1,0,0,0,549,547,1,0,0,0,
        550,551,5,142,0,0,551,15,1,0,0,0,552,553,5,5,0,0,553,556,3,18,9,
        0,554,555,5,145,0,0,555,557,3,20,10,0,556,554,1,0,0,0,556,557,1,
        0,0,0,557,558,1,0,0,0,558,559,5,41,0,0,559,561,3,292,146,0,560,562,
        3,424,212,0,561,560,1,0,0,0,561,562,1,0,0,0,562,563,1,0,0,0,563,
        564,5,138,0,0,564,17,1,0,0,0,565,569,3,230,115,0,566,569,5,126,0,
        0,567,569,5,127,0,0,568,565,1,0,0,0,568,566,1,0,0,0,568,567,1,0,
        0,0,569,19,1,0,0,0,570,573,3,450,225,0,571,573,3,472,236,0,572,570,
        1,0,0,0,572,571,1,0,0,0,573,21,1,0,0,0,574,577,5,52,0,0,575,578,
        3,366,183,0,576,578,3,472,236,0,577,575,1,0,0,0,577,576,1,0,0,0,
        578,23,1,0,0,0,579,580,5,8,0,0,580,581,3,230,115,0,581,582,5,58,
        0,0,582,583,3,230,115,0,583,584,5,41,0,0,584,585,3,26,13,0,585,586,
        5,12,0,0,586,587,3,30,15,0,587,589,5,24,0,0,588,590,5,8,0,0,589,
        588,1,0,0,0,589,590,1,0,0,0,590,592,1,0,0,0,591,593,3,230,115,0,
        592,591,1,0,0,0,592,593,1,0,0,0,593,594,1,0,0,0,594,595,5,138,0,
        0,595,25,1,0,0,0,596,598,3,56,28,0,597,596,1,0,0,0,598,601,1,0,0,
        0,599,597,1,0,0,0,599,600,1,0,0,0,600,27,1,0,0,0,601,599,1,0,0,0,
        602,624,3,64,32,0,603,624,3,362,181,0,604,606,3,272,136,0,605,604,
        1,0,0,0,605,606,1,0,0,0,606,607,1,0,0,0,607,624,3,102,51,0,608,610,
        3,272,136,0,609,608,1,0,0,0,609,610,1,0,0,0,610,611,1,0,0,0,611,
        624,3,98,49,0,612,614,3,272,136,0,613,612,1,0,0,0,613,614,1,0,0,
        0,614,616,1,0,0,0,615,617,5,66,0,0,616,615,1,0,0,0,616,617,1,0,0,
        0,617,618,1,0,0,0,618,624,3,104,52,0,619,624,3,90,45,0,620,624,3,
        210,105,0,621,624,3,100,50,0,622,624,3,438,219,0,623,602,1,0,0,0,
        623,603,1,0,0,0,623,605,1,0,0,0,623,609,1,0,0,0,623,613,1,0,0,0,
        623,619,1,0,0,0,623,620,1,0,0,0,623,621,1,0,0,0,623,622,1,0,0,0,
        624,29,1,0,0,0,625,627,3,28,14,0,626,625,1,0,0,0,627,630,1,0,0,0,
        628,626,1,0,0,0,628,629,1,0,0,0,629,31,1,0,0,0,630,628,1,0,0,0,631,
        634,3,496,248,0,632,634,3,128,64,0,633,631,1,0,0,0,633,632,1,0,0,
        0,634,33,1,0,0,0,635,638,3,494,247,0,636,638,3,126,63,0,637,635,
        1,0,0,0,637,636,1,0,0,0,638,35,1,0,0,0,639,640,5,10,0,0,640,643,
        3,106,53,0,641,642,5,79,0,0,642,644,3,192,96,0,643,641,1,0,0,0,643,
        644,1,0,0,0,644,647,1,0,0,0,645,646,5,84,0,0,646,648,3,192,96,0,
        647,645,1,0,0,0,647,648,1,0,0,0,648,37,1,0,0,0,649,651,3,272,136,
        0,650,649,1,0,0,0,650,651,1,0,0,0,651,652,1,0,0,0,652,653,3,36,18,
        0,653,654,5,138,0,0,654,39,1,0,0,0,655,656,3,206,103,0,656,657,5,
        133,0,0,657,659,1,0,0,0,658,655,1,0,0,0,658,659,1,0,0,0,659,660,
        1,0,0,0,660,661,3,10,5,0,661,41,1,0,0,0,662,667,3,40,20,0,663,664,
        5,139,0,0,664,666,3,40,20,0,665,663,1,0,0,0,666,669,1,0,0,0,667,
        665,1,0,0,0,667,668,1,0,0,0,668,43,1,0,0,0,669,667,1,0,0,0,670,671,
        5,11,0,0,671,672,3,272,136,0,672,673,3,292,146,0,673,674,5,138,0,
        0,674,45,1,0,0,0,675,683,3,230,115,0,676,683,5,72,0,0,677,683,5,
        73,0,0,678,683,5,3,0,0,679,683,5,96,0,0,680,683,5,77,0,0,681,683,
        5,98,0,0,682,675,1,0,0,0,682,676,1,0,0,0,682,677,1,0,0,0,682,678,
        1,0,0,0,682,679,1,0,0,0,682,680,1,0,0,0,682,681,1,0,0,0,683,47,1,
        0,0,0,684,685,5,11,0,0,685,686,3,46,23,0,686,687,5,58,0,0,687,688,
        3,178,89,0,688,689,5,41,0,0,689,690,3,192,96,0,690,691,5,138,0,0,
        691,49,1,0,0,0,692,693,3,230,115,0,693,694,5,138,0,0,694,51,1,0,
        0,0,695,696,5,104,0,0,696,698,3,158,79,0,697,695,1,0,0,0,697,698,
        1,0,0,0,698,700,1,0,0,0,699,701,3,218,109,0,700,699,1,0,0,0,700,
        701,1,0,0,0,701,703,1,0,0,0,702,704,3,342,171,0,703,702,1,0,0,0,
        703,704,1,0,0,0,704,53,1,0,0,0,705,706,5,30,0,0,706,710,3,62,31,
        0,707,709,3,498,249,0,708,707,1,0,0,0,709,712,1,0,0,0,710,708,1,
        0,0,0,710,711,1,0,0,0,711,716,1,0,0,0,712,710,1,0,0,0,713,715,3,
        120,60,0,714,713,1,0,0,0,715,718,1,0,0,0,716,714,1,0,0,0,716,717,
        1,0,0,0,717,719,1,0,0,0,718,716,1,0,0,0,719,720,5,24,0,0,720,721,
        5,30,0,0,721,722,5,138,0,0,722,55,1,0,0,0,723,746,3,454,227,0,724,
        746,3,452,226,0,725,746,3,490,245,0,726,746,3,470,235,0,727,746,
        3,124,62,0,728,746,3,418,209,0,729,746,3,502,251,0,730,746,3,196,
        98,0,731,746,3,16,8,0,732,746,3,88,44,0,733,746,3,44,22,0,734,746,
        3,48,24,0,735,746,3,122,61,0,736,746,3,146,73,0,737,746,3,446,223,
        0,738,746,3,498,249,0,739,746,3,226,113,0,740,746,3,224,112,0,741,
        746,3,306,153,0,742,746,3,448,224,0,743,746,3,368,184,0,744,746,
        3,482,241,0,745,723,1,0,0,0,745,724,1,0,0,0,745,725,1,0,0,0,745,
        726,1,0,0,0,745,727,1,0,0,0,745,728,1,0,0,0,745,729,1,0,0,0,745,
        730,1,0,0,0,745,731,1,0,0,0,745,732,1,0,0,0,745,733,1,0,0,0,745,
        734,1,0,0,0,745,735,1,0,0,0,745,736,1,0,0,0,745,737,1,0,0,0,745,
        738,1,0,0,0,745,739,1,0,0,0,745,740,1,0,0,0,745,741,1,0,0,0,745,
        742,1,0,0,0,745,743,1,0,0,0,745,744,1,0,0,0,746,57,1,0,0,0,747,749,
        3,56,28,0,748,747,1,0,0,0,749,752,1,0,0,0,750,748,1,0,0,0,750,751,
        1,0,0,0,751,59,1,0,0,0,752,750,1,0,0,0,753,757,3,214,107,0,754,755,
        3,218,109,0,755,756,5,138,0,0,756,758,1,0,0,0,757,754,1,0,0,0,757,
        758,1,0,0,0,758,760,1,0,0,0,759,753,1,0,0,0,759,760,1,0,0,0,760,
        767,1,0,0,0,761,765,3,338,169,0,762,763,3,342,171,0,763,764,5,138,
        0,0,764,766,1,0,0,0,765,762,1,0,0,0,765,766,1,0,0,0,766,768,1,0,
        0,0,767,761,1,0,0,0,767,768,1,0,0,0,768,61,1,0,0,0,769,774,3,230,
        115,0,770,771,5,141,0,0,771,772,3,238,119,0,772,773,5,142,0,0,773,
        775,1,0,0,0,774,770,1,0,0,0,774,775,1,0,0,0,775,778,1,0,0,0,776,
        778,3,292,146,0,777,769,1,0,0,0,777,776,1,0,0,0,778,63,1,0,0,0,779,
        780,3,272,136,0,780,785,5,13,0,0,781,782,5,141,0,0,782,783,3,192,
        96,0,783,784,5,142,0,0,784,786,1,0,0,0,785,781,1,0,0,0,785,786,1,
        0,0,0,786,788,1,0,0,0,787,789,5,41,0,0,788,787,1,0,0,0,788,789,1,
        0,0,0,789,790,1,0,0,0,790,791,3,60,30,0,791,792,3,58,29,0,792,793,
        5,12,0,0,793,794,3,66,33,0,794,795,5,24,0,0,795,797,5,13,0,0,796,
        798,3,230,115,0,797,796,1,0,0,0,797,798,1,0,0,0,798,799,1,0,0,0,
        799,800,5,138,0,0,800,65,1,0,0,0,801,803,3,28,14,0,802,801,1,0,0,
        0,803,806,1,0,0,0,804,802,1,0,0,0,804,805,1,0,0,0,805,67,1,0,0,0,
        806,804,1,0,0,0,807,809,5,71,0,0,808,810,3,4,2,0,809,808,1,0,0,0,
        809,810,1,0,0,0,810,812,1,0,0,0,811,813,3,484,242,0,812,811,1,0,
        0,0,812,813,1,0,0,0,813,814,1,0,0,0,814,815,3,480,240,0,815,816,
        5,138,0,0,816,69,1,0,0,0,817,819,3,74,37,0,818,817,1,0,0,0,818,819,
        1,0,0,0,819,820,1,0,0,0,820,821,3,292,146,0,821,822,5,133,0,0,822,
        823,3,192,96,0,823,71,1,0,0,0,824,829,3,70,35,0,825,826,5,139,0,
        0,826,828,3,70,35,0,827,825,1,0,0,0,828,831,1,0,0,0,829,827,1,0,
        0,0,829,830,1,0,0,0,830,73,1,0,0,0,831,829,1,0,0,0,832,833,5,30,
        0,0,833,834,3,292,146,0,834,835,5,104,0,0,835,75,1,0,0,0,836,838,
        3,272,136,0,837,836,1,0,0,0,837,838,1,0,0,0,838,839,1,0,0,0,839,
        841,5,15,0,0,840,842,3,72,36,0,841,840,1,0,0,0,841,842,1,0,0,0,842,
        845,1,0,0,0,843,844,5,108,0,0,844,846,3,106,53,0,845,843,1,0,0,0,
        845,846,1,0,0,0,846,847,1,0,0,0,847,848,5,138,0,0,848,77,1,0,0,0,
        849,851,3,272,136,0,850,849,1,0,0,0,850,851,1,0,0,0,851,852,1,0,
        0,0,852,853,5,18,0,0,853,854,3,192,96,0,854,856,5,41,0,0,855,857,
        3,80,40,0,856,855,1,0,0,0,857,858,1,0,0,0,858,856,1,0,0,0,858,859,
        1,0,0,0,859,860,1,0,0,0,860,861,5,24,0,0,861,863,5,18,0,0,862,864,
        3,230,115,0,863,862,1,0,0,0,863,864,1,0,0,0,864,865,1,0,0,0,865,
        866,5,138,0,0,866,79,1,0,0,0,867,868,5,108,0,0,868,869,3,84,42,0,
        869,870,5,133,0,0,870,871,3,408,204,0,871,81,1,0,0,0,872,877,3,230,
        115,0,873,877,3,148,74,0,874,877,3,426,213,0,875,877,5,62,0,0,876,
        872,1,0,0,0,876,873,1,0,0,0,876,874,1,0,0,0,876,875,1,0,0,0,877,
        83,1,0,0,0,878,883,3,82,41,0,879,880,5,153,0,0,880,882,3,82,41,0,
        881,879,1,0,0,0,882,885,1,0,0,0,883,881,1,0,0,0,883,884,1,0,0,0,
        884,85,1,0,0,0,885,883,1,0,0,0,886,887,5,30,0,0,887,891,3,92,46,
        0,888,889,3,52,26,0,889,890,5,138,0,0,890,892,1,0,0,0,891,888,1,
        0,0,0,891,892,1,0,0,0,892,894,1,0,0,0,893,895,3,54,27,0,894,893,
        1,0,0,0,894,895,1,0,0,0,895,896,1,0,0,0,896,897,5,24,0,0,897,898,
        5,30,0,0,898,899,5,138,0,0,899,87,1,0,0,0,900,901,5,19,0,0,901,903,
        3,230,115,0,902,904,5,41,0,0,903,902,1,0,0,0,903,904,1,0,0,0,904,
        906,1,0,0,0,905,907,3,214,107,0,906,905,1,0,0,0,906,907,1,0,0,0,
        907,909,1,0,0,0,908,910,3,338,169,0,909,908,1,0,0,0,909,910,1,0,
        0,0,910,911,1,0,0,0,911,912,5,24,0,0,912,914,5,19,0,0,913,915,3,
        230,115,0,914,913,1,0,0,0,914,915,1,0,0,0,915,916,1,0,0,0,916,917,
        5,138,0,0,917,89,1,0,0,0,918,919,3,272,136,0,919,921,3,242,121,0,
        920,922,3,218,109,0,921,920,1,0,0,0,921,922,1,0,0,0,922,924,1,0,
        0,0,923,925,3,342,171,0,924,923,1,0,0,0,924,925,1,0,0,0,925,926,
        1,0,0,0,926,927,5,138,0,0,927,91,1,0,0,0,928,929,3,244,122,0,929,
        930,5,145,0,0,930,931,3,292,146,0,931,93,1,0,0,0,932,935,3,32,16,
        0,933,935,3,380,190,0,934,932,1,0,0,0,934,933,1,0,0,0,935,95,1,0,
        0,0,936,939,3,34,17,0,937,939,3,382,191,0,938,936,1,0,0,0,938,937,
        1,0,0,0,939,97,1,0,0,0,940,942,3,272,136,0,941,940,1,0,0,0,941,942,
        1,0,0,0,942,944,1,0,0,0,943,945,5,66,0,0,944,943,1,0,0,0,944,945,
        1,0,0,0,945,946,1,0,0,0,946,947,3,36,18,0,947,948,5,138,0,0,948,
        99,1,0,0,0,949,951,3,272,136,0,950,949,1,0,0,0,950,951,1,0,0,0,951,
        952,1,0,0,0,952,954,5,15,0,0,953,955,3,72,36,0,954,953,1,0,0,0,954,
        955,1,0,0,0,955,957,1,0,0,0,956,958,3,404,202,0,957,956,1,0,0,0,
        957,958,1,0,0,0,958,961,1,0,0,0,959,960,5,108,0,0,960,962,3,106,
        53,0,961,959,1,0,0,0,961,962,1,0,0,0,962,963,1,0,0,0,963,964,5,138,
        0,0,964,101,1,0,0,0,965,967,3,272,136,0,966,965,1,0,0,0,966,967,
        1,0,0,0,967,969,1,0,0,0,968,970,5,66,0,0,969,968,1,0,0,0,969,970,
        1,0,0,0,970,971,1,0,0,0,971,972,3,354,177,0,972,973,5,138,0,0,973,
        103,1,0,0,0,974,976,3,272,136,0,975,974,1,0,0,0,975,976,1,0,0,0,
        976,978,1,0,0,0,977,979,5,66,0,0,978,977,1,0,0,0,978,979,1,0,0,0,
        979,982,1,0,0,0,980,983,3,110,55,0,981,983,3,400,200,0,982,980,1,
        0,0,0,982,981,1,0,0,0,983,105,1,0,0,0,984,985,3,192,96,0,985,107,
        1,0,0,0,986,987,5,103,0,0,987,988,3,106,53,0,988,109,1,0,0,0,989,
        990,3,476,238,0,990,991,5,131,0,0,991,992,3,318,159,0,992,993,3,
        112,56,0,993,994,5,138,0,0,994,111,1,0,0,0,995,1002,3,506,253,0,
        996,997,5,108,0,0,997,1000,3,106,53,0,998,999,5,26,0,0,999,1001,
        3,112,56,0,1000,998,1,0,0,0,1000,1001,1,0,0,0,1001,1003,1,0,0,0,
        1002,996,1,0,0,0,1002,1003,1,0,0,0,1003,113,1,0,0,0,1004,1005,5,
        20,0,0,1005,1006,3,230,115,0,1006,1007,5,58,0,0,1007,1008,3,292,
        146,0,1008,1009,5,41,0,0,1009,1010,3,118,59,0,1010,1011,3,54,27,
        0,1011,1013,5,24,0,0,1012,1014,5,20,0,0,1013,1012,1,0,0,0,1013,1014,
        1,0,0,0,1014,1016,1,0,0,0,1015,1017,3,230,115,0,1016,1015,1,0,0,
        0,1016,1017,1,0,0,0,1017,1018,1,0,0,0,1018,1019,5,138,0,0,1019,115,
        1,0,0,0,1020,1024,3,498,249,0,1021,1024,3,48,24,0,1022,1024,3,224,
        112,0,1023,1020,1,0,0,0,1023,1021,1,0,0,0,1023,1022,1,0,0,0,1024,
        117,1,0,0,0,1025,1027,3,116,58,0,1026,1025,1,0,0,0,1027,1030,1,0,
        0,0,1028,1026,1,0,0,0,1028,1029,1,0,0,0,1029,119,1,0,0,0,1030,1028,
        1,0,0,0,1031,1034,3,54,27,0,1032,1034,3,86,43,0,1033,1031,1,0,0,
        0,1033,1032,1,0,0,0,1034,121,1,0,0,0,1035,1036,5,30,0,0,1036,1037,
        3,92,46,0,1037,1038,3,52,26,0,1038,1039,5,138,0,0,1039,123,1,0,0,
        0,1040,1041,5,21,0,0,1041,1042,3,232,116,0,1042,1043,5,145,0,0,1043,
        1046,3,472,236,0,1044,1045,5,135,0,0,1045,1047,3,192,96,0,1046,1044,
        1,0,0,0,1046,1047,1,0,0,0,1047,1048,1,0,0,0,1048,1049,5,138,0,0,
        1049,125,1,0,0,0,1050,1051,5,9,0,0,1051,1052,3,236,118,0,1052,1053,
        5,58,0,0,1053,1054,3,472,236,0,1054,127,1,0,0,0,1055,1056,5,9,0,
        0,1056,1057,3,236,118,0,1057,1058,5,58,0,0,1058,1059,3,450,225,0,
        1059,129,1,0,0,0,1060,1063,3,378,189,0,1061,1063,3,236,118,0,1062,
        1060,1,0,0,0,1062,1061,1,0,0,0,1063,131,1,0,0,0,1064,1066,3,134,
        67,0,1065,1064,1,0,0,0,1066,1069,1,0,0,0,1067,1065,1,0,0,0,1067,
        1068,1,0,0,0,1068,133,1,0,0,0,1069,1067,1,0,0,0,1070,1073,3,274,
        137,0,1071,1073,3,498,249,0,1072,1070,1,0,0,0,1072,1071,1,0,0,0,
        1073,135,1,0,0,0,1074,1081,5,99,0,0,1075,1076,5,74,0,0,1076,1078,
        3,192,96,0,1077,1075,1,0,0,0,1077,1078,1,0,0,0,1078,1079,1,0,0,0,
        1079,1081,5,39,0,0,1080,1074,1,0,0,0,1080,1077,1,0,0,0,1081,137,
        1,0,0,0,1082,1084,3,140,70,0,1083,1082,1,0,0,0,1084,1087,1,0,0,0,
        1085,1083,1,0,0,0,1085,1086,1,0,0,0,1086,1088,1,0,0,0,1087,1085,
        1,0,0,0,1088,1089,5,0,0,1,1089,139,1,0,0,0,1090,1091,3,132,66,0,
        1091,1092,3,276,138,0,1092,141,1,0,0,0,1093,1096,3,230,115,0,1094,
        1096,5,127,0,0,1095,1093,1,0,0,0,1095,1094,1,0,0,0,1096,143,1,0,
        0,0,1097,1098,7,2,0,0,1098,145,1,0,0,0,1099,1100,5,22,0,0,1100,1101,
        3,228,114,0,1101,1102,5,4,0,0,1102,1103,3,192,96,0,1103,1104,5,138,
        0,0,1104,147,1,0,0,0,1105,1108,3,374,187,0,1106,1108,3,472,236,0,
        1107,1105,1,0,0,0,1107,1106,1,0,0,0,1108,149,1,0,0,0,1109,1110,3,
        84,42,0,1110,1111,5,133,0,0,1111,1113,1,0,0,0,1112,1109,1,0,0,0,
        1112,1113,1,0,0,0,1113,1114,1,0,0,0,1114,1115,3,192,96,0,1115,151,
        1,0,0,0,1116,1117,3,232,116,0,1117,1118,5,145,0,0,1118,1119,3,156,
        78,0,1119,1120,5,138,0,0,1120,153,1,0,0,0,1121,1122,3,450,225,0,
        1122,155,1,0,0,0,1123,1124,3,472,236,0,1124,157,1,0,0,0,1125,1126,
        5,25,0,0,1126,1131,3,292,146,0,1127,1128,5,141,0,0,1128,1129,3,230,
        115,0,1129,1130,5,142,0,0,1130,1132,1,0,0,0,1131,1127,1,0,0,0,1131,
        1132,1,0,0,0,1132,1137,1,0,0,0,1133,1134,5,20,0,0,1134,1137,3,292,
        146,0,1135,1137,5,60,0,0,1136,1125,1,0,0,0,1136,1133,1,0,0,0,1136,
        1135,1,0,0,0,1137,159,1,0,0,0,1138,1139,7,3,0,0,1139,161,1,0,0,0,
        1140,1142,3,160,80,0,1141,1143,5,136,0,0,1142,1141,1,0,0,0,1142,
        1143,1,0,0,0,1143,163,1,0,0,0,1144,1149,3,162,81,0,1145,1146,5,139,
        0,0,1146,1148,3,162,81,0,1147,1145,1,0,0,0,1148,1151,1,0,0,0,1149,
        1147,1,0,0,0,1149,1150,1,0,0,0,1150,165,1,0,0,0,1151,1149,1,0,0,
        0,1152,1153,5,25,0,0,1153,1154,3,230,115,0,1154,1155,5,41,0,0,1155,
        1156,3,174,87,0,1156,1159,3,170,85,0,1157,1158,5,12,0,0,1158,1160,
        3,182,91,0,1159,1157,1,0,0,0,1159,1160,1,0,0,0,1160,1161,1,0,0,0,
        1161,1163,5,24,0,0,1162,1164,5,25,0,0,1163,1162,1,0,0,0,1163,1164,
        1,0,0,0,1164,1166,1,0,0,0,1165,1167,3,230,115,0,1166,1165,1,0,0,
        0,1166,1167,1,0,0,0,1167,1168,1,0,0,0,1168,1169,5,138,0,0,1169,167,
        1,0,0,0,1170,1191,3,454,227,0,1171,1191,3,452,226,0,1172,1191,3,
        490,245,0,1173,1191,3,470,235,0,1174,1191,3,124,62,0,1175,1191,3,
        418,209,0,1176,1191,3,502,251,0,1177,1191,3,196,98,0,1178,1191,3,
        16,8,0,1179,1191,3,44,22,0,1180,1191,3,48,24,0,1181,1191,3,146,73,
        0,1182,1191,3,446,223,0,1183,1191,3,498,249,0,1184,1191,3,226,113,
        0,1185,1191,3,224,112,0,1186,1191,3,306,153,0,1187,1191,3,448,224,
        0,1188,1191,3,368,184,0,1189,1191,3,482,241,0,1190,1170,1,0,0,0,
        1190,1171,1,0,0,0,1190,1172,1,0,0,0,1190,1173,1,0,0,0,1190,1174,
        1,0,0,0,1190,1175,1,0,0,0,1190,1176,1,0,0,0,1190,1177,1,0,0,0,1190,
        1178,1,0,0,0,1190,1179,1,0,0,0,1190,1180,1,0,0,0,1190,1181,1,0,0,
        0,1190,1182,1,0,0,0,1190,1183,1,0,0,0,1190,1184,1,0,0,0,1190,1185,
        1,0,0,0,1190,1186,1,0,0,0,1190,1187,1,0,0,0,1190,1188,1,0,0,0,1190,
        1189,1,0,0,0,1191,169,1,0,0,0,1192,1194,3,168,84,0,1193,1192,1,0,
        0,0,1194,1197,1,0,0,0,1195,1193,1,0,0,0,1195,1196,1,0,0,0,1196,171,
        1,0,0,0,1197,1195,1,0,0,0,1198,1200,3,184,92,0,1199,1201,3,424,212,
        0,1200,1199,1,0,0,0,1200,1201,1,0,0,0,1201,173,1,0,0,0,1202,1204,
        3,214,107,0,1203,1202,1,0,0,0,1203,1204,1,0,0,0,1204,1206,1,0,0,
        0,1205,1207,3,338,169,0,1206,1205,1,0,0,0,1206,1207,1,0,0,0,1207,
        175,1,0,0,0,1208,1213,3,172,86,0,1209,1210,5,139,0,0,1210,1212,3,
        172,86,0,1211,1209,1,0,0,0,1212,1215,1,0,0,0,1213,1211,1,0,0,0,1213,
        1214,1,0,0,0,1214,1219,1,0,0,0,1215,1213,1,0,0,0,1216,1219,5,62,
        0,0,1217,1219,5,6,0,0,1218,1208,1,0,0,0,1218,1216,1,0,0,0,1218,1217,
        1,0,0,0,1219,177,1,0,0,0,1220,1221,3,176,88,0,1221,1222,5,145,0,
        0,1222,1223,3,160,80,0,1223,179,1,0,0,0,1224,1228,3,98,49,0,1225,
        1228,3,362,181,0,1226,1228,3,102,51,0,1227,1224,1,0,0,0,1227,1225,
        1,0,0,0,1227,1226,1,0,0,0,1228,181,1,0,0,0,1229,1231,3,180,90,0,
        1230,1229,1,0,0,0,1231,1234,1,0,0,0,1232,1230,1,0,0,0,1232,1233,
        1,0,0,0,1233,183,1,0,0,0,1234,1232,1,0,0,0,1235,1239,3,230,115,0,
        1236,1239,5,126,0,0,1237,1239,5,127,0,0,1238,1235,1,0,0,0,1238,1236,
        1,0,0,0,1238,1237,1,0,0,0,1239,185,1,0,0,0,1240,1243,3,230,115,0,
        1241,1243,5,126,0,0,1242,1240,1,0,0,0,1242,1241,1,0,0,0,1243,187,
        1,0,0,0,1244,1245,5,141,0,0,1245,1250,3,186,93,0,1246,1247,5,139,
        0,0,1247,1249,3,186,93,0,1248,1246,1,0,0,0,1249,1252,1,0,0,0,1250,
        1248,1,0,0,0,1250,1251,1,0,0,0,1251,1253,1,0,0,0,1252,1250,1,0,0,
        0,1253,1254,5,142,0,0,1254,189,1,0,0,0,1255,1257,3,272,136,0,1256,
        1255,1,0,0,0,1256,1257,1,0,0,0,1257,1258,1,0,0,0,1258,1260,5,28,
        0,0,1259,1261,3,230,115,0,1260,1259,1,0,0,0,1260,1261,1,0,0,0,1261,
        1264,1,0,0,0,1262,1263,5,108,0,0,1263,1265,3,106,53,0,1264,1262,
        1,0,0,0,1264,1265,1,0,0,0,1265,1266,1,0,0,0,1266,1267,5,138,0,0,
        1267,191,1,0,0,0,1268,1274,3,384,192,0,1269,1270,3,284,142,0,1270,
        1271,3,384,192,0,1271,1273,1,0,0,0,1272,1269,1,0,0,0,1273,1276,1,
        0,0,0,1274,1272,1,0,0,0,1274,1275,1,0,0,0,1275,193,1,0,0,0,1276,
        1274,1,0,0,0,1277,1280,3,344,172,0,1278,1279,5,129,0,0,1279,1281,
        3,344,172,0,1280,1278,1,0,0,0,1280,1281,1,0,0,0,1281,1287,1,0,0,
        0,1282,1283,5,1,0,0,1283,1287,3,344,172,0,1284,1285,5,56,0,0,1285,
        1287,3,344,172,0,1286,1277,1,0,0,0,1286,1282,1,0,0,0,1286,1284,1,
        0,0,0,1287,195,1,0,0,0,1288,1289,5,29,0,0,1289,1290,3,232,116,0,
        1290,1291,5,145,0,0,1291,1293,3,472,236,0,1292,1294,3,200,100,0,
        1293,1292,1,0,0,0,1293,1294,1,0,0,0,1294,1295,1,0,0,0,1295,1296,
        5,138,0,0,1296,197,1,0,0,0,1297,1298,3,192,96,0,1298,199,1,0,0,0,
        1299,1300,5,60,0,0,1300,1302,3,192,96,0,1301,1299,1,0,0,0,1301,1302,
        1,0,0,0,1302,1303,1,0,0,0,1303,1304,5,41,0,0,1304,1305,3,198,99,
        0,1305,201,1,0,0,0,1306,1307,5,29,0,0,1307,1308,5,58,0,0,1308,1309,
        3,472,236,0,1309,203,1,0,0,0,1310,1311,3,258,129,0,1311,205,1,0,
        0,0,1312,1319,3,230,115,0,1313,1314,3,230,115,0,1314,1315,5,141,
        0,0,1315,1316,3,376,188,0,1316,1317,5,142,0,0,1317,1319,1,0,0,0,
        1318,1312,1,0,0,0,1318,1313,1,0,0,0,1319,207,1,0,0,0,1320,1321,5,
        71,0,0,1321,1322,3,232,116,0,1322,1323,5,145,0,0,1323,1326,3,472,
        236,0,1324,1325,5,135,0,0,1325,1327,3,192,96,0,1326,1324,1,0,0,0,
        1326,1327,1,0,0,0,1327,1328,1,0,0,0,1328,1329,5,138,0,0,1329,209,
        1,0,0,0,1330,1331,3,272,136,0,1331,1332,3,212,106,0,1332,1340,5,
        32,0,0,1333,1335,3,56,28,0,1334,1333,1,0,0,0,1335,1338,1,0,0,0,1336,
        1334,1,0,0,0,1336,1337,1,0,0,0,1337,1339,1,0,0,0,1338,1336,1,0,0,
        0,1339,1341,5,12,0,0,1340,1336,1,0,0,0,1340,1341,1,0,0,0,1341,1345,
        1,0,0,0,1342,1344,3,28,14,0,1343,1342,1,0,0,0,1344,1347,1,0,0,0,
        1345,1343,1,0,0,0,1345,1346,1,0,0,0,1346,1348,1,0,0,0,1347,1345,
        1,0,0,0,1348,1349,5,24,0,0,1349,1351,5,32,0,0,1350,1352,3,230,115,
        0,1351,1350,1,0,0,0,1351,1352,1,0,0,0,1352,1353,1,0,0,0,1353,1354,
        5,138,0,0,1354,211,1,0,0,0,1355,1356,5,30,0,0,1356,1360,3,332,166,
        0,1357,1358,5,36,0,0,1358,1360,3,106,53,0,1359,1355,1,0,0,0,1359,
        1357,1,0,0,0,1360,213,1,0,0,0,1361,1362,5,33,0,0,1362,1363,5,141,
        0,0,1363,1364,3,216,108,0,1364,1365,5,142,0,0,1365,1366,5,138,0,
        0,1366,215,1,0,0,0,1367,1372,3,246,123,0,1368,1369,5,138,0,0,1369,
        1371,3,246,123,0,1370,1368,1,0,0,0,1371,1374,1,0,0,0,1372,1370,1,
        0,0,0,1372,1373,1,0,0,0,1373,217,1,0,0,0,1374,1372,1,0,0,0,1375,
        1376,5,33,0,0,1376,1377,5,48,0,0,1377,1378,5,141,0,0,1378,1379,3,
        42,21,0,1379,1380,5,142,0,0,1380,219,1,0,0,0,1381,1384,3,292,146,
        0,1382,1384,5,126,0,0,1383,1381,1,0,0,0,1383,1382,1,0,0,0,1384,221,
        1,0,0,0,1385,1390,3,220,110,0,1386,1387,5,139,0,0,1387,1389,3,220,
        110,0,1388,1386,1,0,0,0,1389,1392,1,0,0,0,1390,1388,1,0,0,0,1390,
        1391,1,0,0,0,1391,223,1,0,0,0,1392,1390,1,0,0,0,1393,1394,5,34,0,
        0,1394,1395,3,272,136,0,1395,1396,3,292,146,0,1396,1397,5,141,0,
        0,1397,1398,3,222,111,0,1398,1399,5,142,0,0,1399,1400,5,138,0,0,
        1400,225,1,0,0,0,1401,1402,5,34,0,0,1402,1403,3,230,115,0,1403,1404,
        5,41,0,0,1404,1405,5,141,0,0,1405,1406,3,164,82,0,1406,1407,5,142,
        0,0,1407,1408,5,138,0,0,1408,227,1,0,0,0,1409,1410,3,422,211,0,1410,
        1411,5,145,0,0,1411,1412,3,292,146,0,1412,229,1,0,0,0,1413,1414,
        7,4,0,0,1414,231,1,0,0,0,1415,1420,3,230,115,0,1416,1417,5,139,0,
        0,1417,1419,3,230,115,0,1418,1416,1,0,0,0,1419,1422,1,0,0,0,1420,
        1418,1,0,0,0,1420,1421,1,0,0,0,1421,233,1,0,0,0,1422,1420,1,0,0,
        0,1423,1425,3,272,136,0,1424,1423,1,0,0,0,1424,1425,1,0,0,0,1425,
        1426,1,0,0,0,1426,1427,5,36,0,0,1427,1428,3,106,53,0,1428,1429,5,
        95,0,0,1429,1437,3,408,204,0,1430,1431,5,27,0,0,1431,1432,3,106,
        53,0,1432,1433,5,95,0,0,1433,1434,3,408,204,0,1434,1436,1,0,0,0,
        1435,1430,1,0,0,0,1436,1439,1,0,0,0,1437,1435,1,0,0,0,1437,1438,
        1,0,0,0,1438,1442,1,0,0,0,1439,1437,1,0,0,0,1440,1441,5,26,0,0,1441,
        1443,3,408,204,0,1442,1440,1,0,0,0,1442,1443,1,0,0,0,1443,1444,1,
        0,0,0,1444,1445,5,24,0,0,1445,1447,5,36,0,0,1446,1448,3,230,115,
        0,1447,1446,1,0,0,0,1447,1448,1,0,0,0,1448,1449,1,0,0,0,1449,1450,
        5,138,0,0,1450,235,1,0,0,0,1451,1452,5,141,0,0,1452,1457,3,148,74,
        0,1453,1454,5,139,0,0,1454,1456,3,148,74,0,1455,1453,1,0,0,0,1456,
        1459,1,0,0,0,1457,1455,1,0,0,0,1457,1458,1,0,0,0,1458,1460,1,0,0,
        0,1459,1457,1,0,0,0,1460,1461,5,142,0,0,1461,237,1,0,0,0,1462,1465,
        3,148,74,0,1463,1465,3,192,96,0,1464,1462,1,0,0,0,1464,1463,1,0,
        0,0,1465,239,1,0,0,0,1466,1467,3,292,146,0,1467,1468,5,72,0,0,1468,
        1469,5,136,0,0,1469,241,1,0,0,0,1470,1472,5,19,0,0,1471,1470,1,0,
        0,0,1471,1472,1,0,0,0,1472,1473,1,0,0,0,1473,1485,3,292,146,0,1474,
        1475,5,25,0,0,1475,1480,3,292,146,0,1476,1477,5,141,0,0,1477,1478,
        3,230,115,0,1478,1479,5,142,0,0,1479,1481,1,0,0,0,1480,1476,1,0,
        0,0,1480,1481,1,0,0,0,1481,1485,1,0,0,0,1482,1483,5,20,0,0,1483,
        1485,3,292,146,0,1484,1471,1,0,0,0,1484,1474,1,0,0,0,1484,1482,1,
        0,0,0,1485,243,1,0,0,0,1486,1491,3,230,115,0,1487,1488,5,139,0,0,
        1488,1490,3,230,115,0,1489,1487,1,0,0,0,1490,1493,1,0,0,0,1491,1489,
        1,0,0,0,1491,1492,1,0,0,0,1492,1497,1,0,0,0,1493,1491,1,0,0,0,1494,
        1497,5,62,0,0,1495,1497,5,6,0,0,1496,1486,1,0,0,0,1496,1494,1,0,
        0,0,1496,1495,1,0,0,0,1497,245,1,0,0,0,1498,1500,5,21,0,0,1499,1498,
        1,0,0,0,1499,1500,1,0,0,0,1500,1501,1,0,0,0,1501,1502,3,232,116,
        0,1502,1504,5,145,0,0,1503,1505,5,38,0,0,1504,1503,1,0,0,0,1504,
        1505,1,0,0,0,1505,1506,1,0,0,0,1506,1509,3,472,236,0,1507,1508,5,
        135,0,0,1508,1510,3,192,96,0,1509,1507,1,0,0,0,1509,1510,1,0,0,0,
        1510,247,1,0,0,0,1511,1518,3,246,123,0,1512,1518,3,264,132,0,1513,
        1518,3,268,134,0,1514,1518,3,252,126,0,1515,1518,3,266,133,0,1516,
        1518,3,260,130,0,1517,1511,1,0,0,0,1517,1512,1,0,0,0,1517,1513,1,
        0,0,0,1517,1514,1,0,0,0,1517,1515,1,0,0,0,1517,1516,1,0,0,0,1518,
        249,1,0,0,0,1519,1520,3,248,124,0,1520,251,1,0,0,0,1521,1522,5,29,
        0,0,1522,1523,3,232,116,0,1523,1524,5,145,0,0,1524,1525,3,472,236,
        0,1525,253,1,0,0,0,1526,1531,3,264,132,0,1527,1528,5,138,0,0,1528,
        1530,3,264,132,0,1529,1527,1,0,0,0,1530,1533,1,0,0,0,1531,1529,1,
        0,0,0,1531,1532,1,0,0,0,1532,255,1,0,0,0,1533,1531,1,0,0,0,1534,
        1539,3,262,131,0,1535,1536,5,138,0,0,1536,1538,3,262,131,0,1537,
        1535,1,0,0,0,1538,1541,1,0,0,0,1539,1537,1,0,0,0,1539,1540,1,0,0,
        0,1540,257,1,0,0,0,1541,1539,1,0,0,0,1542,1547,3,250,125,0,1543,
        1544,5,138,0,0,1544,1546,3,250,125,0,1545,1543,1,0,0,0,1546,1549,
        1,0,0,0,1547,1545,1,0,0,0,1547,1548,1,0,0,0,1548,259,1,0,0,0,1549,
        1547,1,0,0,0,1550,1551,5,71,0,0,1551,1552,3,232,116,0,1552,1554,
        5,145,0,0,1553,1555,7,5,0,0,1554,1553,1,0,0,0,1554,1555,1,0,0,0,
        1555,1556,1,0,0,0,1556,1559,3,472,236,0,1557,1558,5,135,0,0,1558,
        1560,3,192,96,0,1559,1557,1,0,0,0,1559,1560,1,0,0,0,1560,261,1,0,
        0,0,1561,1562,3,232,116,0,1562,1564,5,145,0,0,1563,1565,3,288,144,
        0,1564,1563,1,0,0,0,1564,1565,1,0,0,0,1565,1566,1,0,0,0,1566,1568,
        3,472,236,0,1567,1569,5,17,0,0,1568,1567,1,0,0,0,1568,1569,1,0,0,
        0,1569,1572,1,0,0,0,1570,1571,5,135,0,0,1571,1573,3,192,96,0,1572,
        1570,1,0,0,0,1572,1573,1,0,0,0,1573,263,1,0,0,0,1574,1575,5,86,0,
        0,1575,1576,3,232,116,0,1576,1578,5,145,0,0,1577,1579,3,288,144,
        0,1578,1577,1,0,0,0,1578,1579,1,0,0,0,1579,1580,1,0,0,0,1580,1582,
        3,472,236,0,1581,1583,5,17,0,0,1582,1581,1,0,0,0,1582,1583,1,0,0,
        0,1583,1586,1,0,0,0,1584,1585,5,135,0,0,1585,1587,3,192,96,0,1586,
        1584,1,0,0,0,1586,1587,1,0,0,0,1587,265,1,0,0,0,1588,1589,5,94,0,
        0,1589,1590,3,232,116,0,1590,1591,5,145,0,0,1591,1592,3,450,225,
        0,1592,267,1,0,0,0,1593,1595,5,105,0,0,1594,1593,1,0,0,0,1594,1595,
        1,0,0,0,1595,1596,1,0,0,0,1596,1597,3,232,116,0,1597,1599,5,145,
        0,0,1598,1600,3,288,144,0,1599,1598,1,0,0,0,1599,1600,1,0,0,0,1600,
        1601,1,0,0,0,1601,1604,3,472,236,0,1602,1603,5,135,0,0,1603,1605,
        3,192,96,0,1604,1602,1,0,0,0,1604,1605,1,0,0,0,1605,269,1,0,0,0,
        1606,1607,5,109,0,0,1607,1611,3,106,53,0,1608,1609,5,30,0,0,1609,
        1611,3,332,166,0,1610,1606,1,0,0,0,1610,1608,1,0,0,0,1611,271,1,
        0,0,0,1612,1613,3,230,115,0,1613,1614,5,145,0,0,1614,273,1,0,0,0,
        1615,1616,5,43,0,0,1616,1617,3,282,141,0,1617,1618,5,138,0,0,1618,
        275,1,0,0,0,1619,1622,3,396,198,0,1620,1622,3,346,173,0,1621,1619,
        1,0,0,0,1621,1620,1,0,0,0,1622,277,1,0,0,0,1623,1629,5,57,0,0,1624,
        1629,5,113,0,0,1625,1629,5,127,0,0,1626,1629,3,186,93,0,1627,1629,
        3,314,157,0,1628,1623,1,0,0,0,1628,1624,1,0,0,0,1628,1625,1,0,0,
        0,1628,1626,1,0,0,0,1628,1627,1,0,0,0,1629,279,1,0,0,0,1630,1631,
        3,230,115,0,1631,281,1,0,0,0,1632,1637,3,280,140,0,1633,1634,5,139,
        0,0,1634,1636,3,280,140,0,1635,1633,1,0,0,0,1636,1639,1,0,0,0,1637,
        1635,1,0,0,0,1637,1638,1,0,0,0,1638,283,1,0,0,0,1639,1637,1,0,0,
        0,1640,1641,7,6,0,0,1641,285,1,0,0,0,1642,1644,3,272,136,0,1643,
        1642,1,0,0,0,1643,1644,1,0,0,0,1644,1646,1,0,0,0,1645,1647,3,270,
        135,0,1646,1645,1,0,0,0,1646,1647,1,0,0,0,1647,1648,1,0,0,0,1648,
        1649,5,47,0,0,1649,1650,3,408,204,0,1650,1651,5,24,0,0,1651,1653,
        5,47,0,0,1652,1654,3,230,115,0,1653,1652,1,0,0,0,1653,1654,1,0,0,
        0,1654,1655,1,0,0,0,1655,1656,5,138,0,0,1656,287,1,0,0,0,1657,1658,
        7,7,0,0,1658,289,1,0,0,0,1659,1660,7,8,0,0,1660,291,1,0,0,0,1661,
        1664,3,230,115,0,1662,1664,5,127,0,0,1663,1661,1,0,0,0,1663,1662,
        1,0,0,0,1664,1668,1,0,0,0,1665,1667,3,294,147,0,1666,1665,1,0,0,
        0,1667,1670,1,0,0,0,1668,1666,1,0,0,0,1668,1669,1,0,0,0,1669,293,
        1,0,0,0,1670,1668,1,0,0,0,1671,1676,3,298,149,0,1672,1676,3,300,
        150,0,1673,1676,3,302,151,0,1674,1676,3,304,152,0,1675,1671,1,0,
        0,0,1675,1672,1,0,0,0,1675,1673,1,0,0,0,1675,1674,1,0,0,0,1676,295,
        1,0,0,0,1677,1682,3,230,115,0,1678,1679,5,154,0,0,1679,1681,3,474,
        237,0,1680,1678,1,0,0,0,1681,1684,1,0,0,0,1682,1680,1,0,0,0,1682,
        1683,1,0,0,0,1683,297,1,0,0,0,1684,1682,1,0,0,0,1685,1686,5,154,
        0,0,1686,1688,3,474,237,0,1687,1685,1,0,0,0,1688,1689,1,0,0,0,1689,
        1687,1,0,0,0,1689,1690,1,0,0,0,1690,299,1,0,0,0,1691,1692,5,141,
        0,0,1692,1693,3,8,4,0,1693,1694,5,142,0,0,1694,301,1,0,0,0,1695,
        1696,5,141,0,0,1696,1697,3,148,74,0,1697,1698,5,142,0,0,1698,303,
        1,0,0,0,1699,1701,3,424,212,0,1700,1699,1,0,0,0,1700,1701,1,0,0,
        0,1701,1702,1,0,0,0,1702,1703,5,162,0,0,1703,1708,3,46,23,0,1704,
        1705,5,141,0,0,1705,1706,3,192,96,0,1706,1707,5,142,0,0,1707,1709,
        1,0,0,0,1708,1704,1,0,0,0,1708,1709,1,0,0,0,1709,305,1,0,0,0,1710,
        1711,5,51,0,0,1711,1712,3,230,115,0,1712,1713,5,41,0,0,1713,1714,
        3,308,154,0,1714,1715,5,138,0,0,1715,307,1,0,0,0,1716,1719,3,392,
        196,0,1717,1719,3,94,47,0,1718,1716,1,0,0,0,1718,1717,1,0,0,0,1719,
        309,1,0,0,0,1720,1721,3,232,116,0,1721,1722,5,145,0,0,1722,1723,
        3,154,77,0,1723,311,1,0,0,0,1724,1726,3,272,136,0,1725,1724,1,0,
        0,0,1725,1726,1,0,0,0,1726,1727,1,0,0,0,1727,1729,5,53,0,0,1728,
        1730,3,230,115,0,1729,1728,1,0,0,0,1729,1730,1,0,0,0,1730,1733,1,
        0,0,0,1731,1732,5,108,0,0,1732,1734,3,106,53,0,1733,1731,1,0,0,0,
        1733,1734,1,0,0,0,1734,1735,1,0,0,0,1735,1736,5,138,0,0,1736,313,
        1,0,0,0,1737,1740,3,0,0,0,1738,1740,3,334,167,0,1739,1737,1,0,0,
        0,1739,1738,1,0,0,0,1740,315,1,0,0,0,1741,1748,3,124,62,0,1742,1748,
        3,418,209,0,1743,1748,3,502,251,0,1744,1748,3,196,98,0,1745,1748,
        3,482,241,0,1746,1748,3,368,184,0,1747,1741,1,0,0,0,1747,1742,1,
        0,0,0,1747,1743,1,0,0,0,1747,1744,1,0,0,0,1747,1745,1,0,0,0,1747,
        1746,1,0,0,0,1748,317,1,0,0,0,1749,1751,5,35,0,0,1750,1749,1,0,0,
        0,1750,1751,1,0,0,0,1751,1753,1,0,0,0,1752,1754,3,136,68,0,1753,
        1752,1,0,0,0,1753,1754,1,0,0,0,1754,319,1,0,0,0,1755,1756,5,64,0,
        0,1756,1757,5,14,0,0,1757,1758,3,230,115,0,1758,1759,5,41,0,0,1759,
        1760,3,324,162,0,1760,1763,5,24,0,0,1761,1762,5,64,0,0,1762,1764,
        5,14,0,0,1763,1761,1,0,0,0,1763,1764,1,0,0,0,1764,1766,1,0,0,0,1765,
        1767,3,230,115,0,1766,1765,1,0,0,0,1766,1767,1,0,0,0,1767,1768,1,
        0,0,0,1768,1769,5,138,0,0,1769,321,1,0,0,0,1770,1782,3,454,227,0,
        1771,1782,3,452,226,0,1772,1782,3,490,245,0,1773,1782,3,470,235,
        0,1774,1782,3,124,62,0,1775,1782,3,502,251,0,1776,1782,3,196,98,
        0,1777,1782,3,16,8,0,1778,1782,3,498,249,0,1779,1782,3,226,113,0,
        1780,1782,3,224,112,0,1781,1770,1,0,0,0,1781,1771,1,0,0,0,1781,1772,
        1,0,0,0,1781,1773,1,0,0,0,1781,1774,1,0,0,0,1781,1775,1,0,0,0,1781,
        1776,1,0,0,0,1781,1777,1,0,0,0,1781,1778,1,0,0,0,1781,1779,1,0,0,
        0,1781,1780,1,0,0,0,1782,323,1,0,0,0,1783,1785,3,322,161,0,1784,
        1783,1,0,0,0,1785,1788,1,0,0,0,1786,1784,1,0,0,0,1786,1787,1,0,0,
        0,1787,325,1,0,0,0,1788,1786,1,0,0,0,1789,1790,5,64,0,0,1790,1791,
        3,230,115,0,1791,1792,5,41,0,0,1792,1793,3,330,165,0,1793,1795,5,
        24,0,0,1794,1796,5,64,0,0,1795,1794,1,0,0,0,1795,1796,1,0,0,0,1796,
        1798,1,0,0,0,1797,1799,3,230,115,0,1798,1797,1,0,0,0,1798,1799,1,
        0,0,0,1799,1800,1,0,0,0,1800,1801,5,138,0,0,1801,327,1,0,0,0,1802,
        1822,3,454,227,0,1803,1822,3,452,226,0,1804,1822,3,490,245,0,1805,
        1822,3,470,235,0,1806,1822,3,124,62,0,1807,1822,3,418,209,0,1808,
        1822,3,502,251,0,1809,1822,3,196,98,0,1810,1822,3,16,8,0,1811,1822,
        3,88,44,0,1812,1822,3,44,22,0,1813,1822,3,48,24,0,1814,1822,3,146,
        73,0,1815,1822,3,498,249,0,1816,1822,3,226,113,0,1817,1822,3,224,
        112,0,1818,1822,3,306,153,0,1819,1822,3,448,224,0,1820,1822,3,482,
        241,0,1821,1802,1,0,0,0,1821,1803,1,0,0,0,1821,1804,1,0,0,0,1821,
        1805,1,0,0,0,1821,1806,1,0,0,0,1821,1807,1,0,0,0,1821,1808,1,0,0,
        0,1821,1809,1,0,0,0,1821,1810,1,0,0,0,1821,1811,1,0,0,0,1821,1812,
        1,0,0,0,1821,1813,1,0,0,0,1821,1814,1,0,0,0,1821,1815,1,0,0,0,1821,
        1816,1,0,0,0,1821,1817,1,0,0,0,1821,1818,1,0,0,0,1821,1819,1,0,0,
        0,1821,1820,1,0,0,0,1822,329,1,0,0,0,1823,1825,3,328,164,0,1824,
        1823,1,0,0,0,1825,1828,1,0,0,0,1826,1824,1,0,0,0,1826,1827,1,0,0,
        0,1827,331,1,0,0,0,1828,1826,1,0,0,0,1829,1830,3,230,115,0,1830,
        1831,5,38,0,0,1831,1832,3,148,74,0,1832,333,1,0,0,0,1833,1834,3,
        0,0,0,1834,1835,3,230,115,0,1835,335,1,0,0,0,1836,1837,3,378,189,
        0,1837,1838,5,102,0,0,1838,1842,3,50,25,0,1839,1841,3,398,199,0,
        1840,1839,1,0,0,0,1841,1844,1,0,0,0,1842,1840,1,0,0,0,1842,1843,
        1,0,0,0,1843,1845,1,0,0,0,1844,1842,1,0,0,0,1845,1846,5,24,0,0,1846,
        1848,5,102,0,0,1847,1849,3,230,115,0,1848,1847,1,0,0,0,1848,1849,
        1,0,0,0,1849,337,1,0,0,0,1850,1851,5,65,0,0,1851,1852,5,141,0,0,
        1852,1853,3,340,170,0,1853,1854,5,142,0,0,1854,1855,5,138,0,0,1855,
        339,1,0,0,0,1856,1857,3,256,128,0,1857,341,1,0,0,0,1858,1859,5,65,
        0,0,1859,1860,5,48,0,0,1860,1861,5,141,0,0,1861,1862,3,42,21,0,1862,
        1863,5,142,0,0,1863,343,1,0,0,0,1864,1874,3,278,139,0,1865,1874,
        3,366,183,0,1866,1867,5,141,0,0,1867,1868,3,192,96,0,1868,1869,5,
        142,0,0,1869,1874,1,0,0,0,1870,1874,3,22,11,0,1871,1874,3,14,7,0,
        1872,1874,3,292,146,0,1873,1864,1,0,0,0,1873,1865,1,0,0,0,1873,1866,
        1,0,0,0,1873,1870,1,0,0,0,1873,1871,1,0,0,0,1873,1872,1,0,0,0,1874,
        345,1,0,0,0,1875,1879,3,166,83,0,1876,1879,3,114,57,0,1877,1879,
        3,326,163,0,1878,1875,1,0,0,0,1878,1876,1,0,0,0,1878,1877,1,0,0,
        0,1879,347,1,0,0,0,1880,1893,3,454,227,0,1881,1893,3,452,226,0,1882,
        1893,3,490,245,0,1883,1893,3,470,235,0,1884,1893,3,124,62,0,1885,
        1893,3,502,251,0,1886,1893,3,16,8,0,1887,1893,3,44,22,0,1888,1893,
        3,48,24,0,1889,1893,3,498,249,0,1890,1893,3,226,113,0,1891,1893,
        3,224,112,0,1892,1880,1,0,0,0,1892,1881,1,0,0,0,1892,1882,1,0,0,
        0,1892,1883,1,0,0,0,1892,1884,1,0,0,0,1892,1885,1,0,0,0,1892,1886,
        1,0,0,0,1892,1887,1,0,0,0,1892,1888,1,0,0,0,1892,1889,1,0,0,0,1892,
        1890,1,0,0,0,1892,1891,1,0,0,0,1893,349,1,0,0,0,1894,1896,3,348,
        174,0,1895,1894,1,0,0,0,1896,1899,1,0,0,0,1897,1895,1,0,0,0,1897,
        1898,1,0,0,0,1898,351,1,0,0,0,1899,1897,1,0,0,0,1900,1902,3,410,
        205,0,1901,1900,1,0,0,0,1902,1905,1,0,0,0,1903,1901,1,0,0,0,1903,
        1904,1,0,0,0,1904,353,1,0,0,0,1905,1903,1,0,0,0,1906,1911,3,296,
        148,0,1907,1908,5,141,0,0,1908,1909,3,8,4,0,1909,1910,5,142,0,0,
        1910,1912,1,0,0,0,1911,1907,1,0,0,0,1911,1912,1,0,0,0,1912,355,1,
        0,0,0,1913,1915,3,272,136,0,1914,1913,1,0,0,0,1914,1915,1,0,0,0,
        1915,1916,1,0,0,0,1916,1917,3,354,177,0,1917,1918,5,138,0,0,1918,
        357,1,0,0,0,1919,1933,3,454,227,0,1920,1933,3,452,226,0,1921,1933,
        3,490,245,0,1922,1933,3,470,235,0,1923,1933,3,124,62,0,1924,1933,
        3,502,251,0,1925,1933,3,196,98,0,1926,1933,3,16,8,0,1927,1933,3,
        44,22,0,1928,1933,3,48,24,0,1929,1933,3,498,249,0,1930,1933,3,226,
        113,0,1931,1933,3,224,112,0,1932,1919,1,0,0,0,1932,1920,1,0,0,0,
        1932,1921,1,0,0,0,1932,1922,1,0,0,0,1932,1923,1,0,0,0,1932,1924,
        1,0,0,0,1932,1925,1,0,0,0,1932,1926,1,0,0,0,1932,1927,1,0,0,0,1932,
        1928,1,0,0,0,1932,1929,1,0,0,0,1932,1930,1,0,0,0,1932,1931,1,0,0,
        0,1933,359,1,0,0,0,1934,1936,3,358,179,0,1935,1934,1,0,0,0,1936,
        1939,1,0,0,0,1937,1935,1,0,0,0,1937,1938,1,0,0,0,1938,361,1,0,0,
        0,1939,1937,1,0,0,0,1940,1942,3,272,136,0,1941,1940,1,0,0,0,1941,
        1942,1,0,0,0,1942,1944,1,0,0,0,1943,1945,5,66,0,0,1944,1943,1,0,
        0,0,1944,1945,1,0,0,0,1945,1946,1,0,0,0,1946,1951,5,67,0,0,1947,
        1948,5,141,0,0,1948,1949,3,406,203,0,1949,1950,5,142,0,0,1950,1952,
        1,0,0,0,1951,1947,1,0,0,0,1951,1952,1,0,0,0,1952,1954,1,0,0,0,1953,
        1955,5,41,0,0,1954,1953,1,0,0,0,1954,1955,1,0,0,0,1955,1956,1,0,
        0,0,1956,1957,3,360,180,0,1957,1958,5,12,0,0,1958,1959,3,364,182,
        0,1959,1961,5,24,0,0,1960,1962,5,66,0,0,1961,1960,1,0,0,0,1961,1962,
        1,0,0,0,1962,1963,1,0,0,0,1963,1965,5,67,0,0,1964,1966,3,230,115,
        0,1965,1964,1,0,0,0,1965,1966,1,0,0,0,1966,1967,1,0,0,0,1967,1968,
        5,138,0,0,1968,363,1,0,0,0,1969,1971,3,410,205,0,1970,1969,1,0,0,
        0,1971,1974,1,0,0,0,1972,1970,1,0,0,0,1972,1973,1,0,0,0,1973,365,
        1,0,0,0,1974,1972,1,0,0,0,1975,1976,3,472,236,0,1976,1982,5,162,
        0,0,1977,1983,3,14,7,0,1978,1979,5,141,0,0,1979,1980,3,192,96,0,
        1980,1981,5,142,0,0,1981,1983,1,0,0,0,1982,1977,1,0,0,0,1982,1978,
        1,0,0,0,1983,367,1,0,0,0,1984,1988,3,208,104,0,1985,1988,3,68,34,
        0,1986,1988,3,444,222,0,1987,1984,1,0,0,0,1987,1985,1,0,0,0,1987,
        1986,1,0,0,0,1988,369,1,0,0,0,1989,1994,3,292,146,0,1990,1991,5,
        139,0,0,1991,1993,3,292,146,0,1992,1990,1,0,0,0,1993,1996,1,0,0,
        0,1994,1992,1,0,0,0,1994,1995,1,0,0,0,1995,2000,1,0,0,0,1996,1994,
        1,0,0,0,1997,2000,5,62,0,0,1998,2000,5,6,0,0,1999,1989,1,0,0,0,1999,
        1997,1,0,0,0,1999,1998,1,0,0,0,2000,371,1,0,0,0,2001,2002,3,370,
        185,0,2002,2003,5,145,0,0,2003,2004,3,292,146,0,2004,373,1,0,0,0,
        2005,2008,3,376,188,0,2006,2008,3,292,146,0,2007,2005,1,0,0,0,2007,
        2006,1,0,0,0,2008,375,1,0,0,0,2009,2013,3,426,213,0,2010,2011,3,
        144,72,0,2011,2012,3,426,213,0,2012,2014,1,0,0,0,2013,2010,1,0,0,
        0,2013,2014,1,0,0,0,2014,377,1,0,0,0,2015,2016,5,72,0,0,2016,2017,
        3,374,187,0,2017,379,1,0,0,0,2018,2020,5,76,0,0,2019,2021,3,310,
        155,0,2020,2019,1,0,0,0,2021,2022,1,0,0,0,2022,2020,1,0,0,0,2022,
        2023,1,0,0,0,2023,2024,1,0,0,0,2024,2025,5,24,0,0,2025,2027,5,76,
        0,0,2026,2028,3,230,115,0,2027,2026,1,0,0,0,2027,2028,1,0,0,0,2028,
        381,1,0,0,0,2029,2031,5,76,0,0,2030,2032,3,152,76,0,2031,2030,1,
        0,0,0,2032,2033,1,0,0,0,2033,2031,1,0,0,0,2033,2034,1,0,0,0,2034,
        2035,1,0,0,0,2035,2036,5,24,0,0,2036,2038,5,76,0,0,2037,2039,3,230,
        115,0,2038,2037,1,0,0,0,2038,2039,1,0,0,0,2039,383,1,0,0,0,2040,
        2044,3,412,206,0,2041,2042,3,386,193,0,2042,2043,3,412,206,0,2043,
        2045,1,0,0,0,2044,2041,1,0,0,0,2044,2045,1,0,0,0,2045,385,1,0,0,
        0,2046,2047,7,9,0,0,2047,387,1,0,0,0,2048,2050,3,272,136,0,2049,
        2048,1,0,0,0,2049,2050,1,0,0,0,2050,2051,1,0,0,0,2051,2052,5,79,
        0,0,2052,2055,3,192,96,0,2053,2054,5,84,0,0,2054,2056,3,192,96,0,
        2055,2053,1,0,0,0,2055,2056,1,0,0,0,2056,2057,1,0,0,0,2057,2058,
        5,138,0,0,2058,389,1,0,0,0,2059,2061,3,272,136,0,2060,2059,1,0,0,
        0,2060,2061,1,0,0,0,2061,2062,1,0,0,0,2062,2064,5,80,0,0,2063,2065,
        3,192,96,0,2064,2063,1,0,0,0,2064,2065,1,0,0,0,2065,2066,1,0,0,0,
        2066,2067,5,138,0,0,2067,391,1,0,0,0,2068,2069,3,292,146,0,2069,
        2070,5,3,0,0,2070,2071,3,292,146,0,2071,2072,5,96,0,0,2072,2073,
        3,292,146,0,2073,2074,5,77,0,0,2074,393,1,0,0,0,2075,2079,3,336,
        168,0,2076,2079,3,188,94,0,2077,2079,3,378,189,0,2078,2075,1,0,0,
        0,2078,2076,1,0,0,0,2078,2077,1,0,0,0,2079,395,1,0,0,0,2080,2083,
        3,24,12,0,2081,2083,3,320,160,0,2082,2080,1,0,0,0,2082,2081,1,0,
        0,0,2083,397,1,0,0,0,2084,2085,3,230,115,0,2085,2086,5,152,0,0,2086,
        2087,3,334,167,0,2087,2088,5,138,0,0,2088,399,1,0,0,0,2089,2090,
        5,107,0,0,2090,2091,3,192,96,0,2091,2092,5,83,0,0,2092,2093,3,476,
        238,0,2093,2094,5,131,0,0,2094,2095,3,318,159,0,2095,2096,3,402,
        201,0,2096,2097,5,138,0,0,2097,401,1,0,0,0,2098,2099,3,506,253,0,
        2099,2100,5,108,0,0,2100,2108,3,84,42,0,2101,2102,5,139,0,0,2102,
        2103,3,506,253,0,2103,2104,5,108,0,0,2104,2105,3,84,42,0,2105,2107,
        1,0,0,0,2106,2101,1,0,0,0,2107,2110,1,0,0,0,2108,2106,1,0,0,0,2108,
        2109,1,0,0,0,2109,403,1,0,0,0,2110,2108,1,0,0,0,2111,2112,5,59,0,
        0,2112,2113,3,406,203,0,2113,405,1,0,0,0,2114,2119,3,292,146,0,2115,
        2116,5,139,0,0,2116,2118,3,292,146,0,2117,2115,1,0,0,0,2118,2121,
        1,0,0,0,2119,2117,1,0,0,0,2119,2120,1,0,0,0,2120,407,1,0,0,0,2121,
        2119,1,0,0,0,2122,2124,3,410,205,0,2123,2122,1,0,0,0,2124,2127,1,
        0,0,0,2125,2123,1,0,0,0,2125,2126,1,0,0,0,2126,409,1,0,0,0,2127,
        2125,1,0,0,0,2128,2147,3,504,252,0,2129,2147,3,38,19,0,2130,2147,
        3,388,194,0,2131,2147,3,416,208,0,2132,2147,3,500,250,0,2133,2147,
        3,234,117,0,2134,2147,3,78,39,0,2135,2147,3,286,143,0,2136,2147,
        3,312,156,0,2137,2147,3,190,95,0,2138,2147,3,390,195,0,2139,2141,
        3,272,136,0,2140,2139,1,0,0,0,2140,2141,1,0,0,0,2141,2142,1,0,0,
        0,2142,2143,5,57,0,0,2143,2147,5,138,0,0,2144,2147,3,76,38,0,2145,
        2147,3,356,178,0,2146,2128,1,0,0,0,2146,2129,1,0,0,0,2146,2130,1,
        0,0,0,2146,2131,1,0,0,0,2146,2132,1,0,0,0,2146,2133,1,0,0,0,2146,
        2134,1,0,0,0,2146,2135,1,0,0,0,2146,2136,1,0,0,0,2146,2137,1,0,0,
        0,2146,2138,1,0,0,0,2146,2140,1,0,0,0,2146,2144,1,0,0,0,2146,2145,
        1,0,0,0,2147,411,1,0,0,0,2148,2152,3,426,213,0,2149,2150,3,414,207,
        0,2150,2151,3,426,213,0,2151,2153,1,0,0,0,2152,2149,1,0,0,0,2152,
        2153,1,0,0,0,2153,413,1,0,0,0,2154,2155,7,10,0,0,2155,415,1,0,0,
        0,2156,2158,3,272,136,0,2157,2156,1,0,0,0,2157,2158,1,0,0,0,2158,
        2159,1,0,0,0,2159,2160,3,476,238,0,2160,2162,5,131,0,0,2161,2163,
        3,136,68,0,2162,2161,1,0,0,0,2162,2163,1,0,0,0,2163,2164,1,0,0,0,
        2164,2165,3,506,253,0,2165,2166,5,138,0,0,2166,417,1,0,0,0,2167,
        2168,5,86,0,0,2168,2169,3,232,116,0,2169,2170,5,145,0,0,2170,2172,
        3,472,236,0,2171,2173,3,420,210,0,2172,2171,1,0,0,0,2172,2173,1,
        0,0,0,2173,2176,1,0,0,0,2174,2175,5,135,0,0,2175,2177,3,192,96,0,
        2176,2174,1,0,0,0,2176,2177,1,0,0,0,2177,2178,1,0,0,0,2178,2179,
        5,138,0,0,2179,419,1,0,0,0,2180,2181,7,11,0,0,2181,421,1,0,0,0,2182,
        2187,3,292,146,0,2183,2184,5,139,0,0,2184,2186,3,292,146,0,2185,
        2183,1,0,0,0,2186,2189,1,0,0,0,2187,2185,1,0,0,0,2187,2188,1,0,0,
        0,2188,2193,1,0,0,0,2189,2187,1,0,0,0,2190,2193,5,62,0,0,2191,2193,
        5,6,0,0,2192,2182,1,0,0,0,2192,2190,1,0,0,0,2192,2191,1,0,0,0,2193,
        423,1,0,0,0,2194,2203,5,143,0,0,2195,2200,3,292,146,0,2196,2197,
        5,139,0,0,2197,2199,3,292,146,0,2198,2196,1,0,0,0,2199,2202,1,0,
        0,0,2200,2198,1,0,0,0,2200,2201,1,0,0,0,2201,2204,1,0,0,0,2202,2200,
        1,0,0,0,2203,2195,1,0,0,0,2203,2204,1,0,0,0,2204,2207,1,0,0,0,2205,
        2206,5,80,0,0,2206,2208,3,292,146,0,2207,2205,1,0,0,0,2207,2208,
        1,0,0,0,2208,2209,1,0,0,0,2209,2210,5,144,0,0,2210,425,1,0,0,0,2211,
        2213,7,12,0,0,2212,2211,1,0,0,0,2212,2213,1,0,0,0,2213,2214,1,0,
        0,0,2214,2220,3,478,239,0,2215,2216,3,12,6,0,2216,2217,3,478,239,
        0,2217,2219,1,0,0,0,2218,2215,1,0,0,0,2219,2222,1,0,0,0,2220,2218,
        1,0,0,0,2220,2221,1,0,0,0,2221,427,1,0,0,0,2222,2220,1,0,0,0,2223,
        2225,3,272,136,0,2224,2223,1,0,0,0,2224,2225,1,0,0,0,2225,2226,1,
        0,0,0,2226,2227,3,426,213,0,2227,2228,5,130,0,0,2228,2230,3,426,
        213,0,2229,2231,3,488,244,0,2230,2229,1,0,0,0,2230,2231,1,0,0,0,
        2231,2232,1,0,0,0,2232,2233,5,138,0,0,2233,429,1,0,0,0,2234,2235,
        5,108,0,0,2235,2236,3,84,42,0,2236,2237,5,133,0,0,2237,2238,3,440,
        220,0,2238,431,1,0,0,0,2239,2241,3,272,136,0,2240,2239,1,0,0,0,2240,
        2241,1,0,0,0,2241,2242,1,0,0,0,2242,2243,5,18,0,0,2243,2244,3,192,
        96,0,2244,2246,5,104,0,0,2245,2247,3,430,215,0,2246,2245,1,0,0,0,
        2247,2248,1,0,0,0,2248,2246,1,0,0,0,2248,2249,1,0,0,0,2249,2250,
        1,0,0,0,2250,2251,5,24,0,0,2251,2253,5,18,0,0,2252,2254,3,230,115,
        0,2253,2252,1,0,0,0,2253,2254,1,0,0,0,2254,2255,1,0,0,0,2255,2256,
        5,138,0,0,2256,433,1,0,0,0,2257,2259,3,272,136,0,2258,2257,1,0,0,
        0,2258,2259,1,0,0,0,2259,2260,1,0,0,0,2260,2261,5,36,0,0,2261,2262,
        3,106,53,0,2262,2263,5,104,0,0,2263,2271,3,440,220,0,2264,2265,5,
        27,0,0,2265,2266,3,106,53,0,2266,2267,5,104,0,0,2267,2268,3,440,
        220,0,2268,2270,1,0,0,0,2269,2264,1,0,0,0,2270,2273,1,0,0,0,2271,
        2269,1,0,0,0,2271,2272,1,0,0,0,2272,2276,1,0,0,0,2273,2271,1,0,0,
        0,2274,2275,5,26,0,0,2275,2277,3,440,220,0,2276,2274,1,0,0,0,2276,
        2277,1,0,0,0,2277,2278,1,0,0,0,2278,2279,5,24,0,0,2279,2281,5,104,
        0,0,2280,2282,3,230,115,0,2281,2280,1,0,0,0,2281,2282,1,0,0,0,2282,
        2283,1,0,0,0,2283,2284,5,138,0,0,2284,435,1,0,0,0,2285,2287,3,272,
        136,0,2286,2285,1,0,0,0,2286,2287,1,0,0,0,2287,2288,1,0,0,0,2288,
        2290,5,69,0,0,2289,2291,5,41,0,0,2290,2289,1,0,0,0,2290,2291,1,0,
        0,0,2291,2292,1,0,0,0,2292,2293,3,350,175,0,2293,2294,5,12,0,0,2294,
        2295,3,352,176,0,2295,2296,5,24,0,0,2296,2298,5,69,0,0,2297,2299,
        3,230,115,0,2298,2297,1,0,0,0,2298,2299,1,0,0,0,2299,2300,1,0,0,
        0,2300,2301,5,138,0,0,2301,437,1,0,0,0,2302,2312,3,428,214,0,2303,
        2312,3,434,217,0,2304,2312,3,432,216,0,2305,2312,3,436,218,0,2306,
        2308,3,272,136,0,2307,2306,1,0,0,0,2307,2308,1,0,0,0,2308,2309,1,
        0,0,0,2309,2310,5,57,0,0,2310,2312,5,138,0,0,2311,2302,1,0,0,0,2311,
        2303,1,0,0,0,2311,2304,1,0,0,0,2311,2305,1,0,0,0,2311,2307,1,0,0,
        0,2312,439,1,0,0,0,2313,2315,3,438,219,0,2314,2313,1,0,0,0,2315,
        2318,1,0,0,0,2316,2314,1,0,0,0,2316,2317,1,0,0,0,2317,441,1,0,0,
        0,2318,2316,1,0,0,0,2319,2320,5,89,0,0,2320,2321,3,426,213,0,2321,
        2322,5,139,0,0,2322,2323,3,426,213,0,2323,2327,1,0,0,0,2324,2325,
        5,54,0,0,2325,2327,3,426,213,0,2326,2319,1,0,0,0,2326,2324,1,0,0,
        0,2327,443,1,0,0,0,2328,2329,5,71,0,0,2329,2330,3,232,116,0,2330,
        2331,5,145,0,0,2331,2332,3,472,236,0,2332,2333,3,442,221,0,2333,
        2334,5,138,0,0,2334,445,1,0,0,0,2335,2336,5,44,0,0,2336,2337,3,372,
        186,0,2337,2338,5,107,0,0,2338,2339,3,192,96,0,2339,2340,5,138,0,
        0,2340,447,1,0,0,0,2341,2342,5,92,0,0,2342,2343,3,230,115,0,2343,
        2344,5,41,0,0,2344,2345,3,450,225,0,2345,2346,5,138,0,0,2346,449,
        1,0,0,0,2347,2349,3,292,146,0,2348,2350,3,236,118,0,2349,2348,1,
        0,0,0,2349,2350,1,0,0,0,2350,2357,1,0,0,0,2351,2352,5,98,0,0,2352,
        2353,3,192,96,0,2353,2354,5,3,0,0,2354,2355,3,192,96,0,2355,2356,
        5,96,0,0,2356,2358,1,0,0,0,2357,2351,1,0,0,0,2357,2358,1,0,0,0,2358,
        451,1,0,0,0,2359,2360,3,462,231,0,2360,2361,5,41,0,0,2361,2362,3,
        458,229,0,2362,2363,5,12,0,0,2363,2364,3,468,234,0,2364,2366,5,24,
        0,0,2365,2367,3,460,230,0,2366,2365,1,0,0,0,2366,2367,1,0,0,0,2367,
        2369,1,0,0,0,2368,2370,3,142,71,0,2369,2368,1,0,0,0,2369,2370,1,
        0,0,0,2370,2371,1,0,0,0,2371,2372,5,138,0,0,2372,453,1,0,0,0,2373,
        2374,3,462,231,0,2374,2375,5,138,0,0,2375,455,1,0,0,0,2376,2390,
        3,454,227,0,2377,2390,3,452,226,0,2378,2390,3,490,245,0,2379,2390,
        3,470,235,0,2380,2390,3,124,62,0,2381,2390,3,502,251,0,2382,2390,
        3,196,98,0,2383,2390,3,16,8,0,2384,2390,3,44,22,0,2385,2390,3,48,
        24,0,2386,2390,3,498,249,0,2387,2390,3,226,113,0,2388,2390,3,224,
        112,0,2389,2376,1,0,0,0,2389,2377,1,0,0,0,2389,2378,1,0,0,0,2389,
        2379,1,0,0,0,2389,2380,1,0,0,0,2389,2381,1,0,0,0,2389,2382,1,0,0,
        0,2389,2383,1,0,0,0,2389,2384,1,0,0,0,2389,2385,1,0,0,0,2389,2386,
        1,0,0,0,2389,2387,1,0,0,0,2389,2388,1,0,0,0,2390,457,1,0,0,0,2391,
        2393,3,456,228,0,2392,2391,1,0,0,0,2393,2396,1,0,0,0,2394,2392,1,
        0,0,0,2394,2395,1,0,0,0,2395,459,1,0,0,0,2396,2394,1,0,0,0,2397,
        2398,7,13,0,0,2398,461,1,0,0,0,2399,2402,3,464,232,0,2400,2402,3,
        466,233,0,2401,2399,1,0,0,0,2401,2400,1,0,0,0,2402,463,1,0,0,0,2403,
        2404,5,68,0,0,2404,2409,3,142,71,0,2405,2406,5,141,0,0,2406,2407,
        3,204,102,0,2407,2408,5,142,0,0,2408,2410,1,0,0,0,2409,2405,1,0,
        0,0,2409,2410,1,0,0,0,2410,465,1,0,0,0,2411,2413,7,14,0,0,2412,2411,
        1,0,0,0,2412,2413,1,0,0,0,2413,2414,1,0,0,0,2414,2415,5,31,0,0,2415,
        2420,3,142,71,0,2416,2417,5,141,0,0,2417,2418,3,204,102,0,2418,2419,
        5,142,0,0,2419,2421,1,0,0,0,2420,2416,1,0,0,0,2420,2421,1,0,0,0,
        2421,2422,1,0,0,0,2422,2423,5,80,0,0,2423,2424,3,472,236,0,2424,
        467,1,0,0,0,2425,2427,3,410,205,0,2426,2425,1,0,0,0,2427,2430,1,
        0,0,0,2428,2426,1,0,0,0,2428,2429,1,0,0,0,2429,469,1,0,0,0,2430,
        2428,1,0,0,0,2431,2432,5,93,0,0,2432,2433,3,230,115,0,2433,2434,
        5,41,0,0,2434,2435,3,472,236,0,2435,2436,5,138,0,0,2436,471,1,0,
        0,0,2437,2439,3,296,148,0,2438,2440,3,296,148,0,2439,2438,1,0,0,
        0,2439,2440,1,0,0,0,2440,2442,1,0,0,0,2441,2443,3,130,65,0,2442,
        2441,1,0,0,0,2442,2443,1,0,0,0,2443,2445,1,0,0,0,2444,2446,3,488,
        244,0,2445,2444,1,0,0,0,2445,2446,1,0,0,0,2446,473,1,0,0,0,2447,
        2452,3,230,115,0,2448,2452,5,126,0,0,2449,2452,5,127,0,0,2450,2452,
        5,6,0,0,2451,2447,1,0,0,0,2451,2448,1,0,0,0,2451,2449,1,0,0,0,2451,
        2450,1,0,0,0,2452,475,1,0,0,0,2453,2456,3,292,146,0,2454,2456,3,
        14,7,0,2455,2453,1,0,0,0,2455,2454,1,0,0,0,2456,477,1,0,0,0,2457,
        2463,3,194,97,0,2458,2459,3,290,145,0,2459,2460,3,194,97,0,2460,
        2462,1,0,0,0,2461,2458,1,0,0,0,2462,2465,1,0,0,0,2463,2461,1,0,0,
        0,2463,2464,1,0,0,0,2464,479,1,0,0,0,2465,2463,1,0,0,0,2466,2469,
        3,292,146,0,2467,2468,5,97,0,0,2468,2470,3,292,146,0,2469,2467,1,
        0,0,0,2469,2470,1,0,0,0,2470,481,1,0,0,0,2471,2472,5,94,0,0,2472,
        2473,3,232,116,0,2473,2474,5,145,0,0,2474,2475,3,450,225,0,2475,
        2476,5,138,0,0,2476,483,1,0,0,0,2477,2479,3,232,116,0,2478,2480,
        3,488,244,0,2479,2478,1,0,0,0,2479,2480,1,0,0,0,2480,2483,1,0,0,
        0,2481,2482,5,135,0,0,2482,2484,3,192,96,0,2483,2481,1,0,0,0,2483,
        2484,1,0,0,0,2484,2485,1,0,0,0,2485,2486,5,96,0,0,2486,485,1,0,0,
        0,2487,2488,5,30,0,0,2488,2489,3,192,96,0,2489,487,1,0,0,0,2490,
        2491,5,98,0,0,2491,2492,3,192,96,0,2492,489,1,0,0,0,2493,2494,5,
        100,0,0,2494,2497,3,230,115,0,2495,2496,5,41,0,0,2496,2498,3,492,
        246,0,2497,2495,1,0,0,0,2497,2498,1,0,0,0,2498,2499,1,0,0,0,2499,
        2500,5,138,0,0,2500,491,1,0,0,0,2501,2506,3,394,197,0,2502,2506,
        3,96,48,0,2503,2506,3,2,1,0,2504,2506,3,202,101,0,2505,2501,1,0,
        0,0,2505,2502,1,0,0,0,2505,2503,1,0,0,0,2505,2504,1,0,0,0,2506,493,
        1,0,0,0,2507,2508,5,9,0,0,2508,2509,5,141,0,0,2509,2514,3,240,120,
        0,2510,2511,5,139,0,0,2511,2513,3,240,120,0,2512,2510,1,0,0,0,2513,
        2516,1,0,0,0,2514,2512,1,0,0,0,2514,2515,1,0,0,0,2515,2517,1,0,0,
        0,2516,2514,1,0,0,0,2517,2518,5,142,0,0,2518,2519,5,58,0,0,2519,
        2520,3,472,236,0,2520,495,1,0,0,0,2521,2522,5,9,0,0,2522,2523,5,
        141,0,0,2523,2528,3,240,120,0,2524,2525,5,139,0,0,2525,2527,3,240,
        120,0,2526,2524,1,0,0,0,2527,2530,1,0,0,0,2528,2526,1,0,0,0,2528,
        2529,1,0,0,0,2529,2531,1,0,0,0,2530,2528,1,0,0,0,2531,2532,5,142,
        0,0,2532,2533,5,58,0,0,2533,2534,3,450,225,0,2534,497,1,0,0,0,2535,
        2536,5,104,0,0,2536,2541,3,296,148,0,2537,2538,5,139,0,0,2538,2540,
        3,296,148,0,2539,2537,1,0,0,0,2540,2543,1,0,0,0,2541,2539,1,0,0,
        0,2541,2542,1,0,0,0,2542,2544,1,0,0,0,2543,2541,1,0,0,0,2544,2545,
        5,138,0,0,2545,499,1,0,0,0,2546,2548,3,272,136,0,2547,2546,1,0,0,
        0,2547,2548,1,0,0,0,2548,2549,1,0,0,0,2549,2550,3,476,238,0,2550,
        2551,5,135,0,0,2551,2552,3,192,96,0,2552,2553,5,138,0,0,2553,501,
        1,0,0,0,2554,2556,5,85,0,0,2555,2554,1,0,0,0,2555,2556,1,0,0,0,2556,
        2557,1,0,0,0,2557,2558,5,105,0,0,2558,2559,3,232,116,0,2559,2560,
        5,145,0,0,2560,2563,3,472,236,0,2561,2562,5,135,0,0,2562,2564,3,
        192,96,0,2563,2561,1,0,0,0,2563,2564,1,0,0,0,2564,2565,1,0,0,0,2565,
        2566,5,138,0,0,2566,503,1,0,0,0,2567,2569,3,272,136,0,2568,2567,
        1,0,0,0,2568,2569,1,0,0,0,2569,2570,1,0,0,0,2570,2572,5,106,0,0,
        2571,2573,3,404,202,0,2572,2571,1,0,0,0,2572,2573,1,0,0,0,2573,2575,
        1,0,0,0,2574,2576,3,108,54,0,2575,2574,1,0,0,0,2575,2576,1,0,0,0,
        2576,2578,1,0,0,0,2577,2579,3,486,243,0,2578,2577,1,0,0,0,2578,2579,
        1,0,0,0,2579,2580,1,0,0,0,2580,2581,5,138,0,0,2581,505,1,0,0,0,2582,
        2587,3,508,254,0,2583,2584,5,139,0,0,2584,2586,3,508,254,0,2585,
        2583,1,0,0,0,2586,2589,1,0,0,0,2587,2585,1,0,0,0,2587,2588,1,0,0,
        0,2588,2592,1,0,0,0,2589,2587,1,0,0,0,2590,2592,5,101,0,0,2591,2582,
        1,0,0,0,2591,2590,1,0,0,0,2592,507,1,0,0,0,2593,2596,3,192,96,0,
        2594,2595,5,4,0,0,2595,2597,3,192,96,0,2596,2594,1,0,0,0,2596,2597,
        1,0,0,0,2597,509,1,0,0,0,294,517,521,527,537,547,556,561,568,572,
        577,589,592,599,605,609,613,616,623,628,633,637,643,647,650,658,
        667,682,697,700,703,710,716,745,750,757,759,765,767,774,777,785,
        788,797,804,809,812,818,829,837,841,845,850,858,863,876,883,891,
        894,903,906,909,914,921,924,934,938,941,944,950,954,957,961,966,
        969,975,978,982,1000,1002,1013,1016,1023,1028,1033,1046,1062,1067,
        1072,1077,1080,1085,1095,1107,1112,1131,1136,1142,1149,1159,1163,
        1166,1190,1195,1200,1203,1206,1213,1218,1227,1232,1238,1242,1250,
        1256,1260,1264,1274,1280,1286,1293,1301,1318,1326,1336,1340,1345,
        1351,1359,1372,1383,1390,1420,1424,1437,1442,1447,1457,1464,1471,
        1480,1484,1491,1496,1499,1504,1509,1517,1531,1539,1547,1554,1559,
        1564,1568,1572,1578,1582,1586,1594,1599,1604,1610,1621,1628,1637,
        1643,1646,1653,1663,1668,1675,1682,1689,1700,1708,1718,1725,1729,
        1733,1739,1747,1750,1753,1763,1766,1781,1786,1795,1798,1821,1826,
        1842,1848,1873,1878,1892,1897,1903,1911,1914,1932,1937,1941,1944,
        1951,1954,1961,1965,1972,1982,1987,1994,1999,2007,2013,2022,2027,
        2033,2038,2044,2049,2055,2060,2064,2078,2082,2108,2119,2125,2140,
        2146,2152,2157,2162,2172,2176,2187,2192,2200,2203,2207,2212,2220,
        2224,2230,2240,2248,2253,2258,2271,2276,2281,2286,2290,2298,2307,
        2311,2316,2326,2349,2357,2366,2369,2389,2394,2401,2409,2412,2420,
        2428,2439,2442,2445,2451,2455,2463,2469,2479,2483,2497,2505,2514,
        2528,2541,2547,2555,2563,2568,2572,2575,2578,2587,2591,2596
    ]

class vhdlParser ( Parser ):

    grammarFileName = "vhdl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'\\n'", "'\\r'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'**'", "'=='", "'<='", "'>='", "'=>'", "'/='", "':='", 
                     "'<>'", "'\"'", "';'", "','", "'&'", "'('", "')'", 
                     "'['", "']'", "':'", "'*'", "'/'", "'+'", "'-'", "'<'", 
                     "'>'", "'='", "'|'", "'.'", "'\\'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'''" ]

    symbolicNames = [ "<INVALID>", "ABS", "ACCESS", "ACROSS", "AFTER", "ALIAS", 
                      "ALL", "AND", "ARCHITECTURE", "ARRAY", "ASSERT", "ATTRIBUTE", 
                      "BEGIN", "BLOCK", "BODY", "BREAK", "BUFFER", "BUS", 
                      "CASE", "COMPONENT", "CONFIGURATION", "CONSTANT", 
                      "DISCONNECT", "DOWNTO", "END", "ENTITY", "ELSE", "ELSIF", 
                      "EXIT", "FILE", "FOR", "FUNCTION", "GENERATE", "GENERIC", 
                      "GROUP", "GUARDED", "IF", "IMPURE", "IN", "INERTIAL", 
                      "INOUT", "IS", "LABEL", "LIBRARY", "LIMIT", "LINKAGE", 
                      "LITERAL", "LOOP", "MAP", "MOD", "NAND", "NATURE", 
                      "NEW", "NEXT", "NOISE", "NOR", "NOT", "NULL_", "OF", 
                      "ON", "OPEN", "OR", "OTHERS", "OUT", "PACKAGE", "PORT", 
                      "POSTPONED", "PROCESS", "PROCEDURE", "PROCEDURAL", 
                      "PURE", "QUANTITY", "RANGE", "REVERSE_RANGE", "REJECT", 
                      "REM", "RECORD", "REFERENCE", "REGISTER", "REPORT", 
                      "RETURN", "ROL", "ROR", "SELECT", "SEVERITY", "SHARED", 
                      "SIGNAL", "SLA", "SLL", "SPECTRUM", "SRA", "SRL", 
                      "SUBNATURE", "SUBTYPE", "TERMINAL", "THEN", "THROUGH", 
                      "TO", "TOLERANCE", "TRANSPORT", "TYPE", "UNAFFECTED", 
                      "UNITS", "UNTIL", "USE", "VARIABLE", "WAIT", "WITH", 
                      "WHEN", "WHILE", "XNOR", "XOR", "BASE_LITERAL", "BIT_STRING_LITERAL", 
                      "BIT_STRING_LITERAL_BINARY", "BIT_STRING_LITERAL_OCTAL", 
                      "BIT_STRING_LITERAL_HEX", "REAL_LITERAL", "BASIC_IDENTIFIER", 
                      "EXTENDED_IDENTIFIER", "LETTER", "COMMENT", "TAB", 
                      "SPACE", "NEWLINE", "CR", "CHARACTER_LITERAL", "STRING_LITERAL", 
                      "OTHER_SPECIAL_CHARACTER", "DOUBLESTAR", "ASSIGN", 
                      "LE", "GE", "ARROW", "NEQ", "VARASGN", "BOX", "DBLQUOTE", 
                      "SEMI", "COMMA", "AMPERSAND", "LPAREN", "RPAREN", 
                      "LBRACKET", "RBRACKET", "COLON", "MUL", "DIV", "PLUS", 
                      "MINUS", "LOWERTHAN", "GREATERTHAN", "EQ", "BAR", 
                      "DOT", "BACKSLASH", "EXPONENT", "HEXDIGIT", "INTEGER", 
                      "DIGIT", "BASED_INTEGER", "EXTENDED_DIGIT", "APOSTROPHE" ]

    RULE_abstract_literal = 0
    RULE_access_type_definition = 1
    RULE_across_aspect = 2
    RULE_actual_designator = 3
    RULE_actual_parameter_part = 4
    RULE_actual_part = 5
    RULE_adding_operator = 6
    RULE_aggregate = 7
    RULE_alias_declaration = 8
    RULE_alias_designator = 9
    RULE_alias_indication = 10
    RULE_allocator = 11
    RULE_architecture_body = 12
    RULE_architecture_declarative_part = 13
    RULE_architecture_statement = 14
    RULE_architecture_statement_part = 15
    RULE_array_nature_definition = 16
    RULE_array_type_definition = 17
    RULE_assertion = 18
    RULE_assertion_statement = 19
    RULE_association_element = 20
    RULE_association_list = 21
    RULE_attribute_declaration = 22
    RULE_attribute_designator = 23
    RULE_attribute_specification = 24
    RULE_base_unit_declaration = 25
    RULE_binding_indication = 26
    RULE_block_configuration = 27
    RULE_block_declarative_item = 28
    RULE_block_declarative_part = 29
    RULE_block_header = 30
    RULE_block_specification = 31
    RULE_block_statement = 32
    RULE_block_statement_part = 33
    RULE_branch_quantity_declaration = 34
    RULE_break_element = 35
    RULE_break_list = 36
    RULE_break_selector_clause = 37
    RULE_break_statement = 38
    RULE_case_statement = 39
    RULE_case_statement_alternative = 40
    RULE_choice = 41
    RULE_choices = 42
    RULE_component_configuration = 43
    RULE_component_declaration = 44
    RULE_component_instantiation_statement = 45
    RULE_component_specification = 46
    RULE_composite_nature_definition = 47
    RULE_composite_type_definition = 48
    RULE_concurrent_assertion_statement = 49
    RULE_concurrent_break_statement = 50
    RULE_concurrent_procedure_call_statement = 51
    RULE_concurrent_signal_assignment_statement = 52
    RULE_condition = 53
    RULE_condition_clause = 54
    RULE_conditional_signal_assignment = 55
    RULE_conditional_waveforms = 56
    RULE_configuration_declaration = 57
    RULE_configuration_declarative_item = 58
    RULE_configuration_declarative_part = 59
    RULE_configuration_item = 60
    RULE_configuration_specification = 61
    RULE_constant_declaration = 62
    RULE_constrained_array_definition = 63
    RULE_constrained_nature_definition = 64
    RULE_constraint = 65
    RULE_context_clause = 66
    RULE_context_item = 67
    RULE_delay_mechanism = 68
    RULE_design_file = 69
    RULE_design_unit = 70
    RULE_designator = 71
    RULE_direction = 72
    RULE_disconnection_specification = 73
    RULE_discrete_range = 74
    RULE_element_association = 75
    RULE_element_declaration = 76
    RULE_element_subnature_definition = 77
    RULE_element_subtype_definition = 78
    RULE_entity_aspect = 79
    RULE_entity_class = 80
    RULE_entity_class_entry = 81
    RULE_entity_class_entry_list = 82
    RULE_entity_declaration = 83
    RULE_entity_declarative_item = 84
    RULE_entity_declarative_part = 85
    RULE_entity_designator = 86
    RULE_entity_header = 87
    RULE_entity_name_list = 88
    RULE_entity_specification = 89
    RULE_entity_statement = 90
    RULE_entity_statement_part = 91
    RULE_entity_tag = 92
    RULE_enumeration_literal = 93
    RULE_enumeration_type_definition = 94
    RULE_exit_statement = 95
    RULE_expression = 96
    RULE_factor = 97
    RULE_file_declaration = 98
    RULE_file_logical_name = 99
    RULE_file_open_information = 100
    RULE_file_type_definition = 101
    RULE_formal_parameter_list = 102
    RULE_formal_part = 103
    RULE_free_quantity_declaration = 104
    RULE_generate_statement = 105
    RULE_generation_scheme = 106
    RULE_generic_clause = 107
    RULE_generic_list = 108
    RULE_generic_map_aspect = 109
    RULE_group_constituent = 110
    RULE_group_constituent_list = 111
    RULE_group_declaration = 112
    RULE_group_template_declaration = 113
    RULE_guarded_signal_specification = 114
    RULE_identifier = 115
    RULE_identifier_list = 116
    RULE_if_statement = 117
    RULE_index_constraint = 118
    RULE_index_specification = 119
    RULE_index_subtype_definition = 120
    RULE_instantiated_unit = 121
    RULE_instantiation_list = 122
    RULE_interface_constant_declaration = 123
    RULE_interface_declaration = 124
    RULE_interface_element = 125
    RULE_interface_file_declaration = 126
    RULE_interface_signal_list = 127
    RULE_interface_port_list = 128
    RULE_interface_list = 129
    RULE_interface_quantity_declaration = 130
    RULE_interface_port_declaration = 131
    RULE_interface_signal_declaration = 132
    RULE_interface_terminal_declaration = 133
    RULE_interface_variable_declaration = 134
    RULE_iteration_scheme = 135
    RULE_label_colon = 136
    RULE_library_clause = 137
    RULE_library_unit = 138
    RULE_literal = 139
    RULE_logical_name = 140
    RULE_logical_name_list = 141
    RULE_logical_operator = 142
    RULE_loop_statement = 143
    RULE_signal_mode = 144
    RULE_multiplying_operator = 145
    RULE_name = 146
    RULE_name_part = 147
    RULE_selected_name = 148
    RULE_selected_name_part = 149
    RULE_function_call_or_indexed_name_part = 150
    RULE_slice_name_part = 151
    RULE_attribute_name_part = 152
    RULE_nature_declaration = 153
    RULE_nature_definition = 154
    RULE_nature_element_declaration = 155
    RULE_next_statement = 156
    RULE_numeric_literal = 157
    RULE_object_declaration = 158
    RULE_opts = 159
    RULE_package_body = 160
    RULE_package_body_declarative_item = 161
    RULE_package_body_declarative_part = 162
    RULE_package_declaration = 163
    RULE_package_declarative_item = 164
    RULE_package_declarative_part = 165
    RULE_parameter_specification = 166
    RULE_physical_literal = 167
    RULE_physical_type_definition = 168
    RULE_port_clause = 169
    RULE_port_list = 170
    RULE_port_map_aspect = 171
    RULE_primary = 172
    RULE_primary_unit = 173
    RULE_procedural_declarative_item = 174
    RULE_procedural_declarative_part = 175
    RULE_procedural_statement_part = 176
    RULE_procedure_call = 177
    RULE_procedure_call_statement = 178
    RULE_process_declarative_item = 179
    RULE_process_declarative_part = 180
    RULE_process_statement = 181
    RULE_process_statement_part = 182
    RULE_qualified_expression = 183
    RULE_quantity_declaration = 184
    RULE_quantity_list = 185
    RULE_quantity_specification = 186
    RULE_range_decl = 187
    RULE_explicit_range = 188
    RULE_range_constraint = 189
    RULE_record_nature_definition = 190
    RULE_record_type_definition = 191
    RULE_relation = 192
    RULE_relational_operator = 193
    RULE_report_statement = 194
    RULE_return_statement = 195
    RULE_scalar_nature_definition = 196
    RULE_scalar_type_definition = 197
    RULE_secondary_unit = 198
    RULE_secondary_unit_declaration = 199
    RULE_selected_signal_assignment = 200
    RULE_selected_waveforms = 201
    RULE_sensitivity_clause = 202
    RULE_sensitivity_list = 203
    RULE_sequence_of_statements = 204
    RULE_sequential_statement = 205
    RULE_shift_expression = 206
    RULE_shift_operator = 207
    RULE_signal_assignment_statement = 208
    RULE_signal_declaration = 209
    RULE_signal_kind = 210
    RULE_signal_list = 211
    RULE_signature = 212
    RULE_simple_expression = 213
    RULE_simple_simultaneous_statement = 214
    RULE_simultaneous_alternative = 215
    RULE_simultaneous_case_statement = 216
    RULE_simultaneous_if_statement = 217
    RULE_simultaneous_procedural_statement = 218
    RULE_simultaneous_statement = 219
    RULE_simultaneous_statement_part = 220
    RULE_source_aspect = 221
    RULE_source_quantity_declaration = 222
    RULE_step_limit_specification = 223
    RULE_subnature_declaration = 224
    RULE_subnature_indication = 225
    RULE_subprogram_body = 226
    RULE_subprogram_declaration = 227
    RULE_subprogram_declarative_item = 228
    RULE_subprogram_declarative_part = 229
    RULE_subprogram_kind = 230
    RULE_subprogram_specification = 231
    RULE_procedure_specification = 232
    RULE_function_specification = 233
    RULE_subprogram_statement_part = 234
    RULE_subtype_declaration = 235
    RULE_subtype_indication = 236
    RULE_suffix = 237
    RULE_target = 238
    RULE_term = 239
    RULE_terminal_aspect = 240
    RULE_terminal_declaration = 241
    RULE_through_aspect = 242
    RULE_timeout_clause = 243
    RULE_tolerance_aspect = 244
    RULE_type_declaration = 245
    RULE_type_definition = 246
    RULE_unconstrained_array_definition = 247
    RULE_unconstrained_nature_definition = 248
    RULE_use_clause = 249
    RULE_variable_assignment_statement = 250
    RULE_variable_declaration = 251
    RULE_wait_statement = 252
    RULE_waveform = 253
    RULE_waveform_element = 254

    ruleNames =  [ "abstract_literal", "access_type_definition", "across_aspect", 
                   "actual_designator", "actual_parameter_part", "actual_part", 
                   "adding_operator", "aggregate", "alias_declaration", 
                   "alias_designator", "alias_indication", "allocator", 
                   "architecture_body", "architecture_declarative_part", 
                   "architecture_statement", "architecture_statement_part", 
                   "array_nature_definition", "array_type_definition", "assertion", 
                   "assertion_statement", "association_element", "association_list", 
                   "attribute_declaration", "attribute_designator", "attribute_specification", 
                   "base_unit_declaration", "binding_indication", "block_configuration", 
                   "block_declarative_item", "block_declarative_part", "block_header", 
                   "block_specification", "block_statement", "block_statement_part", 
                   "branch_quantity_declaration", "break_element", "break_list", 
                   "break_selector_clause", "break_statement", "case_statement", 
                   "case_statement_alternative", "choice", "choices", "component_configuration", 
                   "component_declaration", "component_instantiation_statement", 
                   "component_specification", "composite_nature_definition", 
                   "composite_type_definition", "concurrent_assertion_statement", 
                   "concurrent_break_statement", "concurrent_procedure_call_statement", 
                   "concurrent_signal_assignment_statement", "condition", 
                   "condition_clause", "conditional_signal_assignment", 
                   "conditional_waveforms", "configuration_declaration", 
                   "configuration_declarative_item", "configuration_declarative_part", 
                   "configuration_item", "configuration_specification", 
                   "constant_declaration", "constrained_array_definition", 
                   "constrained_nature_definition", "constraint", "context_clause", 
                   "context_item", "delay_mechanism", "design_file", "design_unit", 
                   "designator", "direction", "disconnection_specification", 
                   "discrete_range", "element_association", "element_declaration", 
                   "element_subnature_definition", "element_subtype_definition", 
                   "entity_aspect", "entity_class", "entity_class_entry", 
                   "entity_class_entry_list", "entity_declaration", "entity_declarative_item", 
                   "entity_declarative_part", "entity_designator", "entity_header", 
                   "entity_name_list", "entity_specification", "entity_statement", 
                   "entity_statement_part", "entity_tag", "enumeration_literal", 
                   "enumeration_type_definition", "exit_statement", "expression", 
                   "factor", "file_declaration", "file_logical_name", "file_open_information", 
                   "file_type_definition", "formal_parameter_list", "formal_part", 
                   "free_quantity_declaration", "generate_statement", "generation_scheme", 
                   "generic_clause", "generic_list", "generic_map_aspect", 
                   "group_constituent", "group_constituent_list", "group_declaration", 
                   "group_template_declaration", "guarded_signal_specification", 
                   "identifier", "identifier_list", "if_statement", "index_constraint", 
                   "index_specification", "index_subtype_definition", "instantiated_unit", 
                   "instantiation_list", "interface_constant_declaration", 
                   "interface_declaration", "interface_element", "interface_file_declaration", 
                   "interface_signal_list", "interface_port_list", "interface_list", 
                   "interface_quantity_declaration", "interface_port_declaration", 
                   "interface_signal_declaration", "interface_terminal_declaration", 
                   "interface_variable_declaration", "iteration_scheme", 
                   "label_colon", "library_clause", "library_unit", "literal", 
                   "logical_name", "logical_name_list", "logical_operator", 
                   "loop_statement", "signal_mode", "multiplying_operator", 
                   "name", "name_part", "selected_name", "selected_name_part", 
                   "function_call_or_indexed_name_part", "slice_name_part", 
                   "attribute_name_part", "nature_declaration", "nature_definition", 
                   "nature_element_declaration", "next_statement", "numeric_literal", 
                   "object_declaration", "opts", "package_body", "package_body_declarative_item", 
                   "package_body_declarative_part", "package_declaration", 
                   "package_declarative_item", "package_declarative_part", 
                   "parameter_specification", "physical_literal", "physical_type_definition", 
                   "port_clause", "port_list", "port_map_aspect", "primary", 
                   "primary_unit", "procedural_declarative_item", "procedural_declarative_part", 
                   "procedural_statement_part", "procedure_call", "procedure_call_statement", 
                   "process_declarative_item", "process_declarative_part", 
                   "process_statement", "process_statement_part", "qualified_expression", 
                   "quantity_declaration", "quantity_list", "quantity_specification", 
                   "range_decl", "explicit_range", "range_constraint", "record_nature_definition", 
                   "record_type_definition", "relation", "relational_operator", 
                   "report_statement", "return_statement", "scalar_nature_definition", 
                   "scalar_type_definition", "secondary_unit", "secondary_unit_declaration", 
                   "selected_signal_assignment", "selected_waveforms", "sensitivity_clause", 
                   "sensitivity_list", "sequence_of_statements", "sequential_statement", 
                   "shift_expression", "shift_operator", "signal_assignment_statement", 
                   "signal_declaration", "signal_kind", "signal_list", "signature", 
                   "simple_expression", "simple_simultaneous_statement", 
                   "simultaneous_alternative", "simultaneous_case_statement", 
                   "simultaneous_if_statement", "simultaneous_procedural_statement", 
                   "simultaneous_statement", "simultaneous_statement_part", 
                   "source_aspect", "source_quantity_declaration", "step_limit_specification", 
                   "subnature_declaration", "subnature_indication", "subprogram_body", 
                   "subprogram_declaration", "subprogram_declarative_item", 
                   "subprogram_declarative_part", "subprogram_kind", "subprogram_specification", 
                   "procedure_specification", "function_specification", 
                   "subprogram_statement_part", "subtype_declaration", "subtype_indication", 
                   "suffix", "target", "term", "terminal_aspect", "terminal_declaration", 
                   "through_aspect", "timeout_clause", "tolerance_aspect", 
                   "type_declaration", "type_definition", "unconstrained_array_definition", 
                   "unconstrained_nature_definition", "use_clause", "variable_assignment_statement", 
                   "variable_declaration", "wait_statement", "waveform", 
                   "waveform_element" ]

    EOF = Token.EOF
    ABS=1
    ACCESS=2
    ACROSS=3
    AFTER=4
    ALIAS=5
    ALL=6
    AND=7
    ARCHITECTURE=8
    ARRAY=9
    ASSERT=10
    ATTRIBUTE=11
    BEGIN=12
    BLOCK=13
    BODY=14
    BREAK=15
    BUFFER=16
    BUS=17
    CASE=18
    COMPONENT=19
    CONFIGURATION=20
    CONSTANT=21
    DISCONNECT=22
    DOWNTO=23
    END=24
    ENTITY=25
    ELSE=26
    ELSIF=27
    EXIT=28
    FILE=29
    FOR=30
    FUNCTION=31
    GENERATE=32
    GENERIC=33
    GROUP=34
    GUARDED=35
    IF=36
    IMPURE=37
    IN=38
    INERTIAL=39
    INOUT=40
    IS=41
    LABEL=42
    LIBRARY=43
    LIMIT=44
    LINKAGE=45
    LITERAL=46
    LOOP=47
    MAP=48
    MOD=49
    NAND=50
    NATURE=51
    NEW=52
    NEXT=53
    NOISE=54
    NOR=55
    NOT=56
    NULL_=57
    OF=58
    ON=59
    OPEN=60
    OR=61
    OTHERS=62
    OUT=63
    PACKAGE=64
    PORT=65
    POSTPONED=66
    PROCESS=67
    PROCEDURE=68
    PROCEDURAL=69
    PURE=70
    QUANTITY=71
    RANGE=72
    REVERSE_RANGE=73
    REJECT=74
    REM=75
    RECORD=76
    REFERENCE=77
    REGISTER=78
    REPORT=79
    RETURN=80
    ROL=81
    ROR=82
    SELECT=83
    SEVERITY=84
    SHARED=85
    SIGNAL=86
    SLA=87
    SLL=88
    SPECTRUM=89
    SRA=90
    SRL=91
    SUBNATURE=92
    SUBTYPE=93
    TERMINAL=94
    THEN=95
    THROUGH=96
    TO=97
    TOLERANCE=98
    TRANSPORT=99
    TYPE=100
    UNAFFECTED=101
    UNITS=102
    UNTIL=103
    USE=104
    VARIABLE=105
    WAIT=106
    WITH=107
    WHEN=108
    WHILE=109
    XNOR=110
    XOR=111
    BASE_LITERAL=112
    BIT_STRING_LITERAL=113
    BIT_STRING_LITERAL_BINARY=114
    BIT_STRING_LITERAL_OCTAL=115
    BIT_STRING_LITERAL_HEX=116
    REAL_LITERAL=117
    BASIC_IDENTIFIER=118
    EXTENDED_IDENTIFIER=119
    LETTER=120
    COMMENT=121
    TAB=122
    SPACE=123
    NEWLINE=124
    CR=125
    CHARACTER_LITERAL=126
    STRING_LITERAL=127
    OTHER_SPECIAL_CHARACTER=128
    DOUBLESTAR=129
    ASSIGN=130
    LE=131
    GE=132
    ARROW=133
    NEQ=134
    VARASGN=135
    BOX=136
    DBLQUOTE=137
    SEMI=138
    COMMA=139
    AMPERSAND=140
    LPAREN=141
    RPAREN=142
    LBRACKET=143
    RBRACKET=144
    COLON=145
    MUL=146
    DIV=147
    PLUS=148
    MINUS=149
    LOWERTHAN=150
    GREATERTHAN=151
    EQ=152
    BAR=153
    DOT=154
    BACKSLASH=155
    EXPONENT=156
    HEXDIGIT=157
    INTEGER=158
    DIGIT=159
    BASED_INTEGER=160
    EXTENDED_DIGIT=161
    APOSTROPHE=162

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.11.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class Abstract_literalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER(self):
            return self.getToken(vhdlParser.INTEGER, 0)

        def REAL_LITERAL(self):
            return self.getToken(vhdlParser.REAL_LITERAL, 0)

        def BASE_LITERAL(self):
            return self.getToken(vhdlParser.BASE_LITERAL, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_abstract_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbstract_literal" ):
                listener.enterAbstract_literal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbstract_literal" ):
                listener.exitAbstract_literal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAbstract_literal" ):
                return visitor.visitAbstract_literal(self)
            else:
                return visitor.visitChildren(self)




    def abstract_literal(self):

        localctx = vhdlParser.Abstract_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_abstract_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 510
            _la = self._input.LA(1)
            if not((((_la - 112)) & ~0x3f) == 0 and ((1 << (_la - 112)) & 70368744177697) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Access_type_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ACCESS(self):
            return self.getToken(vhdlParser.ACCESS, 0)

        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_access_type_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAccess_type_definition" ):
                listener.enterAccess_type_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAccess_type_definition" ):
                listener.exitAccess_type_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAccess_type_definition" ):
                return visitor.visitAccess_type_definition(self)
            else:
                return visitor.visitChildren(self)




    def access_type_definition(self):

        localctx = vhdlParser.Access_type_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_access_type_definition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 512
            self.match(vhdlParser.ACCESS)
            self.state = 513
            self.subtype_indication()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Across_aspectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier_list(self):
            return self.getTypedRuleContext(vhdlParser.Identifier_listContext,0)


        def ACROSS(self):
            return self.getToken(vhdlParser.ACROSS, 0)

        def tolerance_aspect(self):
            return self.getTypedRuleContext(vhdlParser.Tolerance_aspectContext,0)


        def VARASGN(self):
            return self.getToken(vhdlParser.VARASGN, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_across_aspect

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAcross_aspect" ):
                listener.enterAcross_aspect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAcross_aspect" ):
                listener.exitAcross_aspect(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAcross_aspect" ):
                return visitor.visitAcross_aspect(self)
            else:
                return visitor.visitChildren(self)




    def across_aspect(self):

        localctx = vhdlParser.Across_aspectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_across_aspect)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 515
            self.identifier_list()
            self.state = 517
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==98:
                self.state = 516
                self.tolerance_aspect()


            self.state = 521
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==135:
                self.state = 519
                self.match(vhdlParser.VARASGN)
                self.state = 520
                self.expression()


            self.state = 523
            self.match(vhdlParser.ACROSS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Actual_designatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def OPEN(self):
            return self.getToken(vhdlParser.OPEN, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_actual_designator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActual_designator" ):
                listener.enterActual_designator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActual_designator" ):
                listener.exitActual_designator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitActual_designator" ):
                return visitor.visitActual_designator(self)
            else:
                return visitor.visitChildren(self)




    def actual_designator(self):

        localctx = vhdlParser.Actual_designatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_actual_designator)
        try:
            self.state = 527
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [1, 52, 56, 57, 112, 113, 117, 118, 119, 126, 127, 141, 148, 149, 158]:
                self.enterOuterAlt(localctx, 1)
                self.state = 525
                self.expression()
                pass
            elif token in [60]:
                self.enterOuterAlt(localctx, 2)
                self.state = 526
                self.match(vhdlParser.OPEN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Actual_parameter_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def association_list(self):
            return self.getTypedRuleContext(vhdlParser.Association_listContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_actual_parameter_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActual_parameter_part" ):
                listener.enterActual_parameter_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActual_parameter_part" ):
                listener.exitActual_parameter_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitActual_parameter_part" ):
                return visitor.visitActual_parameter_part(self)
            else:
                return visitor.visitChildren(self)




    def actual_parameter_part(self):

        localctx = vhdlParser.Actual_parameter_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_actual_parameter_part)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 529
            self.association_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Actual_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(vhdlParser.NameContext,0)


        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def actual_designator(self):
            return self.getTypedRuleContext(vhdlParser.Actual_designatorContext,0)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_actual_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActual_part" ):
                listener.enterActual_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActual_part" ):
                listener.exitActual_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitActual_part" ):
                return visitor.visitActual_part(self)
            else:
                return visitor.visitChildren(self)




    def actual_part(self):

        localctx = vhdlParser.Actual_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_actual_part)
        try:
            self.state = 537
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 531
                self.name()
                self.state = 532
                self.match(vhdlParser.LPAREN)
                self.state = 533
                self.actual_designator()
                self.state = 534
                self.match(vhdlParser.RPAREN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 536
                self.actual_designator()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Adding_operatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(vhdlParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(vhdlParser.MINUS, 0)

        def AMPERSAND(self):
            return self.getToken(vhdlParser.AMPERSAND, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_adding_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdding_operator" ):
                listener.enterAdding_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdding_operator" ):
                listener.exitAdding_operator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdding_operator" ):
                return visitor.visitAdding_operator(self)
            else:
                return visitor.visitChildren(self)




    def adding_operator(self):

        localctx = vhdlParser.Adding_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_adding_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 539
            _la = self._input.LA(1)
            if not((((_la - 140)) & ~0x3f) == 0 and ((1 << (_la - 140)) & 769) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def element_association(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Element_associationContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Element_associationContext,i)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.COMMA)
            else:
                return self.getToken(vhdlParser.COMMA, i)

        def getRuleIndex(self):
            return vhdlParser.RULE_aggregate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregate" ):
                listener.enterAggregate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregate" ):
                listener.exitAggregate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregate" ):
                return visitor.visitAggregate(self)
            else:
                return visitor.visitChildren(self)




    def aggregate(self):

        localctx = vhdlParser.AggregateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_aggregate)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 541
            self.match(vhdlParser.LPAREN)
            self.state = 542
            self.element_association()
            self.state = 547
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==139:
                self.state = 543
                self.match(vhdlParser.COMMA)
                self.state = 544
                self.element_association()
                self.state = 549
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 550
            self.match(vhdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alias_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALIAS(self):
            return self.getToken(vhdlParser.ALIAS, 0)

        def alias_designator(self):
            return self.getTypedRuleContext(vhdlParser.Alias_designatorContext,0)


        def IS(self):
            return self.getToken(vhdlParser.IS, 0)

        def name(self):
            return self.getTypedRuleContext(vhdlParser.NameContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def alias_indication(self):
            return self.getTypedRuleContext(vhdlParser.Alias_indicationContext,0)


        def signature(self):
            return self.getTypedRuleContext(vhdlParser.SignatureContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_alias_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlias_declaration" ):
                listener.enterAlias_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlias_declaration" ):
                listener.exitAlias_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlias_declaration" ):
                return visitor.visitAlias_declaration(self)
            else:
                return visitor.visitChildren(self)




    def alias_declaration(self):

        localctx = vhdlParser.Alias_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_alias_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 552
            self.match(vhdlParser.ALIAS)
            self.state = 553
            self.alias_designator()
            self.state = 556
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==145:
                self.state = 554
                self.match(vhdlParser.COLON)
                self.state = 555
                self.alias_indication()


            self.state = 558
            self.match(vhdlParser.IS)
            self.state = 559
            self.name()
            self.state = 561
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==143:
                self.state = 560
                self.signature()


            self.state = 563
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alias_designatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def CHARACTER_LITERAL(self):
            return self.getToken(vhdlParser.CHARACTER_LITERAL, 0)

        def STRING_LITERAL(self):
            return self.getToken(vhdlParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_alias_designator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlias_designator" ):
                listener.enterAlias_designator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlias_designator" ):
                listener.exitAlias_designator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlias_designator" ):
                return visitor.visitAlias_designator(self)
            else:
                return visitor.visitChildren(self)




    def alias_designator(self):

        localctx = vhdlParser.Alias_designatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_alias_designator)
        try:
            self.state = 568
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [118, 119]:
                self.enterOuterAlt(localctx, 1)
                self.state = 565
                self.identifier()
                pass
            elif token in [126]:
                self.enterOuterAlt(localctx, 2)
                self.state = 566
                self.match(vhdlParser.CHARACTER_LITERAL)
                pass
            elif token in [127]:
                self.enterOuterAlt(localctx, 3)
                self.state = 567
                self.match(vhdlParser.STRING_LITERAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alias_indicationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subnature_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subnature_indicationContext,0)


        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_alias_indication

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlias_indication" ):
                listener.enterAlias_indication(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlias_indication" ):
                listener.exitAlias_indication(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlias_indication" ):
                return visitor.visitAlias_indication(self)
            else:
                return visitor.visitChildren(self)




    def alias_indication(self):

        localctx = vhdlParser.Alias_indicationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_alias_indication)
        try:
            self.state = 572
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 570
                self.subnature_indication()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 571
                self.subtype_indication()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AllocatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEW(self):
            return self.getToken(vhdlParser.NEW, 0)

        def qualified_expression(self):
            return self.getTypedRuleContext(vhdlParser.Qualified_expressionContext,0)


        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_allocator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAllocator" ):
                listener.enterAllocator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAllocator" ):
                listener.exitAllocator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAllocator" ):
                return visitor.visitAllocator(self)
            else:
                return visitor.visitChildren(self)




    def allocator(self):

        localctx = vhdlParser.AllocatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_allocator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 574
            self.match(vhdlParser.NEW)
            self.state = 577
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.state = 575
                self.qualified_expression()
                pass

            elif la_ == 2:
                self.state = 576
                self.subtype_indication()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Architecture_bodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ARCHITECTURE(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.ARCHITECTURE)
            else:
                return self.getToken(vhdlParser.ARCHITECTURE, i)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(vhdlParser.IdentifierContext,i)


        def OF(self):
            return self.getToken(vhdlParser.OF, 0)

        def IS(self):
            return self.getToken(vhdlParser.IS, 0)

        def architecture_declarative_part(self):
            return self.getTypedRuleContext(vhdlParser.Architecture_declarative_partContext,0)


        def BEGIN(self):
            return self.getToken(vhdlParser.BEGIN, 0)

        def architecture_statement_part(self):
            return self.getTypedRuleContext(vhdlParser.Architecture_statement_partContext,0)


        def END(self):
            return self.getToken(vhdlParser.END, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_architecture_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArchitecture_body" ):
                listener.enterArchitecture_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArchitecture_body" ):
                listener.exitArchitecture_body(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArchitecture_body" ):
                return visitor.visitArchitecture_body(self)
            else:
                return visitor.visitChildren(self)




    def architecture_body(self):

        localctx = vhdlParser.Architecture_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_architecture_body)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 579
            self.match(vhdlParser.ARCHITECTURE)
            self.state = 580
            self.identifier()
            self.state = 581
            self.match(vhdlParser.OF)
            self.state = 582
            self.identifier()
            self.state = 583
            self.match(vhdlParser.IS)
            self.state = 584
            self.architecture_declarative_part()
            self.state = 585
            self.match(vhdlParser.BEGIN)
            self.state = 586
            self.architecture_statement_part()
            self.state = 587
            self.match(vhdlParser.END)
            self.state = 589
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 588
                self.match(vhdlParser.ARCHITECTURE)


            self.state = 592
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 591
                self.identifier()


            self.state = 594
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Architecture_declarative_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block_declarative_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Block_declarative_itemContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Block_declarative_itemContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_architecture_declarative_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArchitecture_declarative_part" ):
                listener.enterArchitecture_declarative_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArchitecture_declarative_part" ):
                listener.exitArchitecture_declarative_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArchitecture_declarative_part" ):
                return visitor.visitArchitecture_declarative_part(self)
            else:
                return visitor.visitChildren(self)




    def architecture_declarative_part(self):

        localctx = vhdlParser.Architecture_declarative_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_architecture_declarative_part)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 599
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & 2269550383466528) != 0 or (((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & 210571231245) != 0:
                self.state = 596
                self.block_declarative_item()
                self.state = 601
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Architecture_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block_statement(self):
            return self.getTypedRuleContext(vhdlParser.Block_statementContext,0)


        def process_statement(self):
            return self.getTypedRuleContext(vhdlParser.Process_statementContext,0)


        def concurrent_procedure_call_statement(self):
            return self.getTypedRuleContext(vhdlParser.Concurrent_procedure_call_statementContext,0)


        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def concurrent_assertion_statement(self):
            return self.getTypedRuleContext(vhdlParser.Concurrent_assertion_statementContext,0)


        def concurrent_signal_assignment_statement(self):
            return self.getTypedRuleContext(vhdlParser.Concurrent_signal_assignment_statementContext,0)


        def POSTPONED(self):
            return self.getToken(vhdlParser.POSTPONED, 0)

        def component_instantiation_statement(self):
            return self.getTypedRuleContext(vhdlParser.Component_instantiation_statementContext,0)


        def generate_statement(self):
            return self.getTypedRuleContext(vhdlParser.Generate_statementContext,0)


        def concurrent_break_statement(self):
            return self.getTypedRuleContext(vhdlParser.Concurrent_break_statementContext,0)


        def simultaneous_statement(self):
            return self.getTypedRuleContext(vhdlParser.Simultaneous_statementContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_architecture_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArchitecture_statement" ):
                listener.enterArchitecture_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArchitecture_statement" ):
                listener.exitArchitecture_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArchitecture_statement" ):
                return visitor.visitArchitecture_statement(self)
            else:
                return visitor.visitChildren(self)




    def architecture_statement(self):

        localctx = vhdlParser.Architecture_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_architecture_statement)
        try:
            self.state = 623
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 602
                self.block_statement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 603
                self.process_statement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 605
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
                if la_ == 1:
                    self.state = 604
                    self.label_colon()


                self.state = 607
                self.concurrent_procedure_call_statement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 609
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
                if la_ == 1:
                    self.state = 608
                    self.label_colon()


                self.state = 611
                self.concurrent_assertion_statement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 613
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
                if la_ == 1:
                    self.state = 612
                    self.label_colon()


                self.state = 616
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
                if la_ == 1:
                    self.state = 615
                    self.match(vhdlParser.POSTPONED)


                self.state = 618
                self.concurrent_signal_assignment_statement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 619
                self.component_instantiation_statement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 620
                self.generate_statement()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 621
                self.concurrent_break_statement()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 622
                self.simultaneous_statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Architecture_statement_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def architecture_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Architecture_statementContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Architecture_statementContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_architecture_statement_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArchitecture_statement_part" ):
                listener.enterArchitecture_statement_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArchitecture_statement_part" ):
                listener.exitArchitecture_statement_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArchitecture_statement_part" ):
                return visitor.visitArchitecture_statement_part(self)
            else:
                return visitor.visitChildren(self)




    def architecture_statement_part(self):

        localctx = vhdlParser.Architecture_statement_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_architecture_statement_part)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 628
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & 220676450460926978) != 0 or (((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & 3474740417772126219) != 0 or (((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & 131457) != 0:
                self.state = 625
                self.architecture_statement()
                self.state = 630
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Array_nature_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unconstrained_nature_definition(self):
            return self.getTypedRuleContext(vhdlParser.Unconstrained_nature_definitionContext,0)


        def constrained_nature_definition(self):
            return self.getTypedRuleContext(vhdlParser.Constrained_nature_definitionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_array_nature_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArray_nature_definition" ):
                listener.enterArray_nature_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArray_nature_definition" ):
                listener.exitArray_nature_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArray_nature_definition" ):
                return visitor.visitArray_nature_definition(self)
            else:
                return visitor.visitChildren(self)




    def array_nature_definition(self):

        localctx = vhdlParser.Array_nature_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_array_nature_definition)
        try:
            self.state = 633
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 631
                self.unconstrained_nature_definition()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 632
                self.constrained_nature_definition()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Array_type_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unconstrained_array_definition(self):
            return self.getTypedRuleContext(vhdlParser.Unconstrained_array_definitionContext,0)


        def constrained_array_definition(self):
            return self.getTypedRuleContext(vhdlParser.Constrained_array_definitionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_array_type_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArray_type_definition" ):
                listener.enterArray_type_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArray_type_definition" ):
                listener.exitArray_type_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArray_type_definition" ):
                return visitor.visitArray_type_definition(self)
            else:
                return visitor.visitChildren(self)




    def array_type_definition(self):

        localctx = vhdlParser.Array_type_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_array_type_definition)
        try:
            self.state = 637
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 635
                self.unconstrained_array_definition()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 636
                self.constrained_array_definition()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssertionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASSERT(self):
            return self.getToken(vhdlParser.ASSERT, 0)

        def condition(self):
            return self.getTypedRuleContext(vhdlParser.ConditionContext,0)


        def REPORT(self):
            return self.getToken(vhdlParser.REPORT, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(vhdlParser.ExpressionContext,i)


        def SEVERITY(self):
            return self.getToken(vhdlParser.SEVERITY, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_assertion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssertion" ):
                listener.enterAssertion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssertion" ):
                listener.exitAssertion(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssertion" ):
                return visitor.visitAssertion(self)
            else:
                return visitor.visitChildren(self)




    def assertion(self):

        localctx = vhdlParser.AssertionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_assertion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 639
            self.match(vhdlParser.ASSERT)
            self.state = 640
            self.condition()
            self.state = 643
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==79:
                self.state = 641
                self.match(vhdlParser.REPORT)
                self.state = 642
                self.expression()


            self.state = 647
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==84:
                self.state = 645
                self.match(vhdlParser.SEVERITY)
                self.state = 646
                self.expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Assertion_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assertion(self):
            return self.getTypedRuleContext(vhdlParser.AssertionContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_assertion_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssertion_statement" ):
                listener.enterAssertion_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssertion_statement" ):
                listener.exitAssertion_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssertion_statement" ):
                return visitor.visitAssertion_statement(self)
            else:
                return visitor.visitChildren(self)




    def assertion_statement(self):

        localctx = vhdlParser.Assertion_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_assertion_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 650
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 649
                self.label_colon()


            self.state = 652
            self.assertion()
            self.state = 653
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Association_elementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def actual_part(self):
            return self.getTypedRuleContext(vhdlParser.Actual_partContext,0)


        def formal_part(self):
            return self.getTypedRuleContext(vhdlParser.Formal_partContext,0)


        def ARROW(self):
            return self.getToken(vhdlParser.ARROW, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_association_element

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssociation_element" ):
                listener.enterAssociation_element(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssociation_element" ):
                listener.exitAssociation_element(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssociation_element" ):
                return visitor.visitAssociation_element(self)
            else:
                return visitor.visitChildren(self)




    def association_element(self):

        localctx = vhdlParser.Association_elementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_association_element)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 658
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
            if la_ == 1:
                self.state = 655
                self.formal_part()
                self.state = 656
                self.match(vhdlParser.ARROW)


            self.state = 660
            self.actual_part()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Association_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def association_element(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Association_elementContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Association_elementContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.COMMA)
            else:
                return self.getToken(vhdlParser.COMMA, i)

        def getRuleIndex(self):
            return vhdlParser.RULE_association_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssociation_list" ):
                listener.enterAssociation_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssociation_list" ):
                listener.exitAssociation_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssociation_list" ):
                return visitor.visitAssociation_list(self)
            else:
                return visitor.visitChildren(self)




    def association_list(self):

        localctx = vhdlParser.Association_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_association_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 662
            self.association_element()
            self.state = 667
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==139:
                self.state = 663
                self.match(vhdlParser.COMMA)
                self.state = 664
                self.association_element()
                self.state = 669
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Attribute_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATTRIBUTE(self):
            return self.getToken(vhdlParser.ATTRIBUTE, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def name(self):
            return self.getTypedRuleContext(vhdlParser.NameContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_attribute_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribute_declaration" ):
                listener.enterAttribute_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribute_declaration" ):
                listener.exitAttribute_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribute_declaration" ):
                return visitor.visitAttribute_declaration(self)
            else:
                return visitor.visitChildren(self)




    def attribute_declaration(self):

        localctx = vhdlParser.Attribute_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_attribute_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 670
            self.match(vhdlParser.ATTRIBUTE)
            self.state = 671
            self.label_colon()
            self.state = 672
            self.name()
            self.state = 673
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Attribute_designatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def RANGE(self):
            return self.getToken(vhdlParser.RANGE, 0)

        def REVERSE_RANGE(self):
            return self.getToken(vhdlParser.REVERSE_RANGE, 0)

        def ACROSS(self):
            return self.getToken(vhdlParser.ACROSS, 0)

        def THROUGH(self):
            return self.getToken(vhdlParser.THROUGH, 0)

        def REFERENCE(self):
            return self.getToken(vhdlParser.REFERENCE, 0)

        def TOLERANCE(self):
            return self.getToken(vhdlParser.TOLERANCE, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_attribute_designator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribute_designator" ):
                listener.enterAttribute_designator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribute_designator" ):
                listener.exitAttribute_designator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribute_designator" ):
                return visitor.visitAttribute_designator(self)
            else:
                return visitor.visitChildren(self)




    def attribute_designator(self):

        localctx = vhdlParser.Attribute_designatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_attribute_designator)
        try:
            self.state = 682
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [118, 119]:
                self.enterOuterAlt(localctx, 1)
                self.state = 675
                self.identifier()
                pass
            elif token in [72]:
                self.enterOuterAlt(localctx, 2)
                self.state = 676
                self.match(vhdlParser.RANGE)
                pass
            elif token in [73]:
                self.enterOuterAlt(localctx, 3)
                self.state = 677
                self.match(vhdlParser.REVERSE_RANGE)
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 4)
                self.state = 678
                self.match(vhdlParser.ACROSS)
                pass
            elif token in [96]:
                self.enterOuterAlt(localctx, 5)
                self.state = 679
                self.match(vhdlParser.THROUGH)
                pass
            elif token in [77]:
                self.enterOuterAlt(localctx, 6)
                self.state = 680
                self.match(vhdlParser.REFERENCE)
                pass
            elif token in [98]:
                self.enterOuterAlt(localctx, 7)
                self.state = 681
                self.match(vhdlParser.TOLERANCE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Attribute_specificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATTRIBUTE(self):
            return self.getToken(vhdlParser.ATTRIBUTE, 0)

        def attribute_designator(self):
            return self.getTypedRuleContext(vhdlParser.Attribute_designatorContext,0)


        def OF(self):
            return self.getToken(vhdlParser.OF, 0)

        def entity_specification(self):
            return self.getTypedRuleContext(vhdlParser.Entity_specificationContext,0)


        def IS(self):
            return self.getToken(vhdlParser.IS, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_attribute_specification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribute_specification" ):
                listener.enterAttribute_specification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribute_specification" ):
                listener.exitAttribute_specification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribute_specification" ):
                return visitor.visitAttribute_specification(self)
            else:
                return visitor.visitChildren(self)




    def attribute_specification(self):

        localctx = vhdlParser.Attribute_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_attribute_specification)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 684
            self.match(vhdlParser.ATTRIBUTE)
            self.state = 685
            self.attribute_designator()
            self.state = 686
            self.match(vhdlParser.OF)
            self.state = 687
            self.entity_specification()
            self.state = 688
            self.match(vhdlParser.IS)
            self.state = 689
            self.expression()
            self.state = 690
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Base_unit_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_base_unit_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBase_unit_declaration" ):
                listener.enterBase_unit_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBase_unit_declaration" ):
                listener.exitBase_unit_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBase_unit_declaration" ):
                return visitor.visitBase_unit_declaration(self)
            else:
                return visitor.visitChildren(self)




    def base_unit_declaration(self):

        localctx = vhdlParser.Base_unit_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_base_unit_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 692
            self.identifier()
            self.state = 693
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Binding_indicationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USE(self):
            return self.getToken(vhdlParser.USE, 0)

        def entity_aspect(self):
            return self.getTypedRuleContext(vhdlParser.Entity_aspectContext,0)


        def generic_map_aspect(self):
            return self.getTypedRuleContext(vhdlParser.Generic_map_aspectContext,0)


        def port_map_aspect(self):
            return self.getTypedRuleContext(vhdlParser.Port_map_aspectContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_binding_indication

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinding_indication" ):
                listener.enterBinding_indication(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinding_indication" ):
                listener.exitBinding_indication(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinding_indication" ):
                return visitor.visitBinding_indication(self)
            else:
                return visitor.visitChildren(self)




    def binding_indication(self):

        localctx = vhdlParser.Binding_indicationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_binding_indication)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 697
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==104:
                self.state = 695
                self.match(vhdlParser.USE)
                self.state = 696
                self.entity_aspect()


            self.state = 700
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 699
                self.generic_map_aspect()


            self.state = 703
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==65:
                self.state = 702
                self.port_map_aspect()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Block_configurationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.FOR)
            else:
                return self.getToken(vhdlParser.FOR, i)

        def block_specification(self):
            return self.getTypedRuleContext(vhdlParser.Block_specificationContext,0)


        def END(self):
            return self.getToken(vhdlParser.END, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def use_clause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Use_clauseContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Use_clauseContext,i)


        def configuration_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Configuration_itemContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Configuration_itemContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_block_configuration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlock_configuration" ):
                listener.enterBlock_configuration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlock_configuration" ):
                listener.exitBlock_configuration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlock_configuration" ):
                return visitor.visitBlock_configuration(self)
            else:
                return visitor.visitChildren(self)




    def block_configuration(self):

        localctx = vhdlParser.Block_configurationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_block_configuration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 705
            self.match(vhdlParser.FOR)
            self.state = 706
            self.block_specification()
            self.state = 710
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==104:
                self.state = 707
                self.use_clause()
                self.state = 712
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 716
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==30:
                self.state = 713
                self.configuration_item()
                self.state = 718
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 719
            self.match(vhdlParser.END)
            self.state = 720
            self.match(vhdlParser.FOR)
            self.state = 721
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Block_declarative_itemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subprogram_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Subprogram_declarationContext,0)


        def subprogram_body(self):
            return self.getTypedRuleContext(vhdlParser.Subprogram_bodyContext,0)


        def type_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Type_declarationContext,0)


        def subtype_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_declarationContext,0)


        def constant_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Constant_declarationContext,0)


        def signal_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Signal_declarationContext,0)


        def variable_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Variable_declarationContext,0)


        def file_declaration(self):
            return self.getTypedRuleContext(vhdlParser.File_declarationContext,0)


        def alias_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Alias_declarationContext,0)


        def component_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Component_declarationContext,0)


        def attribute_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Attribute_declarationContext,0)


        def attribute_specification(self):
            return self.getTypedRuleContext(vhdlParser.Attribute_specificationContext,0)


        def configuration_specification(self):
            return self.getTypedRuleContext(vhdlParser.Configuration_specificationContext,0)


        def disconnection_specification(self):
            return self.getTypedRuleContext(vhdlParser.Disconnection_specificationContext,0)


        def step_limit_specification(self):
            return self.getTypedRuleContext(vhdlParser.Step_limit_specificationContext,0)


        def use_clause(self):
            return self.getTypedRuleContext(vhdlParser.Use_clauseContext,0)


        def group_template_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Group_template_declarationContext,0)


        def group_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Group_declarationContext,0)


        def nature_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Nature_declarationContext,0)


        def subnature_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Subnature_declarationContext,0)


        def quantity_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Quantity_declarationContext,0)


        def terminal_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Terminal_declarationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_block_declarative_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlock_declarative_item" ):
                listener.enterBlock_declarative_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlock_declarative_item" ):
                listener.exitBlock_declarative_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlock_declarative_item" ):
                return visitor.visitBlock_declarative_item(self)
            else:
                return visitor.visitChildren(self)




    def block_declarative_item(self):

        localctx = vhdlParser.Block_declarative_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_block_declarative_item)
        try:
            self.state = 745
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 723
                self.subprogram_declaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 724
                self.subprogram_body()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 725
                self.type_declaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 726
                self.subtype_declaration()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 727
                self.constant_declaration()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 728
                self.signal_declaration()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 729
                self.variable_declaration()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 730
                self.file_declaration()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 731
                self.alias_declaration()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 732
                self.component_declaration()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 733
                self.attribute_declaration()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 734
                self.attribute_specification()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 735
                self.configuration_specification()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 736
                self.disconnection_specification()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 737
                self.step_limit_specification()
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 738
                self.use_clause()
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 739
                self.group_template_declaration()
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 740
                self.group_declaration()
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 741
                self.nature_declaration()
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 742
                self.subnature_declaration()
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 743
                self.quantity_declaration()
                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 744
                self.terminal_declaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Block_declarative_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block_declarative_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Block_declarative_itemContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Block_declarative_itemContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_block_declarative_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlock_declarative_part" ):
                listener.enterBlock_declarative_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlock_declarative_part" ):
                listener.exitBlock_declarative_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlock_declarative_part" ):
                return visitor.visitBlock_declarative_part(self)
            else:
                return visitor.visitChildren(self)




    def block_declarative_part(self):

        localctx = vhdlParser.Block_declarative_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_block_declarative_part)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 750
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & 2269550383466528) != 0 or (((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & 210571231245) != 0:
                self.state = 747
                self.block_declarative_item()
                self.state = 752
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Block_headerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def generic_clause(self):
            return self.getTypedRuleContext(vhdlParser.Generic_clauseContext,0)


        def port_clause(self):
            return self.getTypedRuleContext(vhdlParser.Port_clauseContext,0)


        def generic_map_aspect(self):
            return self.getTypedRuleContext(vhdlParser.Generic_map_aspectContext,0)


        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.SEMI)
            else:
                return self.getToken(vhdlParser.SEMI, i)

        def port_map_aspect(self):
            return self.getTypedRuleContext(vhdlParser.Port_map_aspectContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_block_header

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlock_header" ):
                listener.enterBlock_header(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlock_header" ):
                listener.exitBlock_header(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlock_header" ):
                return visitor.visitBlock_header(self)
            else:
                return visitor.visitChildren(self)




    def block_header(self):

        localctx = vhdlParser.Block_headerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_block_header)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 759
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 753
                self.generic_clause()
                self.state = 757
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==33:
                    self.state = 754
                    self.generic_map_aspect()
                    self.state = 755
                    self.match(vhdlParser.SEMI)




            self.state = 767
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==65:
                self.state = 761
                self.port_clause()
                self.state = 765
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==65:
                    self.state = 762
                    self.port_map_aspect()
                    self.state = 763
                    self.match(vhdlParser.SEMI)




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Block_specificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def index_specification(self):
            return self.getTypedRuleContext(vhdlParser.Index_specificationContext,0)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def name(self):
            return self.getTypedRuleContext(vhdlParser.NameContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_block_specification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlock_specification" ):
                listener.enterBlock_specification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlock_specification" ):
                listener.exitBlock_specification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlock_specification" ):
                return visitor.visitBlock_specification(self)
            else:
                return visitor.visitChildren(self)




    def block_specification(self):

        localctx = vhdlParser.Block_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_block_specification)
        self._la = 0 # Token type
        try:
            self.state = 777
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 769
                self.identifier()
                self.state = 774
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==141:
                    self.state = 770
                    self.match(vhdlParser.LPAREN)
                    self.state = 771
                    self.index_specification()
                    self.state = 772
                    self.match(vhdlParser.RPAREN)


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 776
                self.name()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Block_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def BLOCK(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.BLOCK)
            else:
                return self.getToken(vhdlParser.BLOCK, i)

        def block_header(self):
            return self.getTypedRuleContext(vhdlParser.Block_headerContext,0)


        def block_declarative_part(self):
            return self.getTypedRuleContext(vhdlParser.Block_declarative_partContext,0)


        def BEGIN(self):
            return self.getToken(vhdlParser.BEGIN, 0)

        def block_statement_part(self):
            return self.getTypedRuleContext(vhdlParser.Block_statement_partContext,0)


        def END(self):
            return self.getToken(vhdlParser.END, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def IS(self):
            return self.getToken(vhdlParser.IS, 0)

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_block_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlock_statement" ):
                listener.enterBlock_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlock_statement" ):
                listener.exitBlock_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlock_statement" ):
                return visitor.visitBlock_statement(self)
            else:
                return visitor.visitChildren(self)




    def block_statement(self):

        localctx = vhdlParser.Block_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_block_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 779
            self.label_colon()
            self.state = 780
            self.match(vhdlParser.BLOCK)
            self.state = 785
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==141:
                self.state = 781
                self.match(vhdlParser.LPAREN)
                self.state = 782
                self.expression()
                self.state = 783
                self.match(vhdlParser.RPAREN)


            self.state = 788
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41:
                self.state = 787
                self.match(vhdlParser.IS)


            self.state = 790
            self.block_header()
            self.state = 791
            self.block_declarative_part()
            self.state = 792
            self.match(vhdlParser.BEGIN)
            self.state = 793
            self.block_statement_part()
            self.state = 794
            self.match(vhdlParser.END)
            self.state = 795
            self.match(vhdlParser.BLOCK)
            self.state = 797
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 796
                self.identifier()


            self.state = 799
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Block_statement_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def architecture_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Architecture_statementContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Architecture_statementContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_block_statement_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlock_statement_part" ):
                listener.enterBlock_statement_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlock_statement_part" ):
                listener.exitBlock_statement_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlock_statement_part" ):
                return visitor.visitBlock_statement_part(self)
            else:
                return visitor.visitChildren(self)




    def block_statement_part(self):

        localctx = vhdlParser.Block_statement_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_block_statement_part)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 804
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & 220676450460926978) != 0 or (((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & 3474740417772126219) != 0 or (((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & 131457) != 0:
                self.state = 801
                self.architecture_statement()
                self.state = 806
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Branch_quantity_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUANTITY(self):
            return self.getToken(vhdlParser.QUANTITY, 0)

        def terminal_aspect(self):
            return self.getTypedRuleContext(vhdlParser.Terminal_aspectContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def across_aspect(self):
            return self.getTypedRuleContext(vhdlParser.Across_aspectContext,0)


        def through_aspect(self):
            return self.getTypedRuleContext(vhdlParser.Through_aspectContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_branch_quantity_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBranch_quantity_declaration" ):
                listener.enterBranch_quantity_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBranch_quantity_declaration" ):
                listener.exitBranch_quantity_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBranch_quantity_declaration" ):
                return visitor.visitBranch_quantity_declaration(self)
            else:
                return visitor.visitChildren(self)




    def branch_quantity_declaration(self):

        localctx = vhdlParser.Branch_quantity_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_branch_quantity_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 807
            self.match(vhdlParser.QUANTITY)
            self.state = 809
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                self.state = 808
                self.across_aspect()


            self.state = 812
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
            if la_ == 1:
                self.state = 811
                self.through_aspect()


            self.state = 814
            self.terminal_aspect()
            self.state = 815
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Break_elementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(vhdlParser.NameContext,0)


        def ARROW(self):
            return self.getToken(vhdlParser.ARROW, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def break_selector_clause(self):
            return self.getTypedRuleContext(vhdlParser.Break_selector_clauseContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_break_element

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBreak_element" ):
                listener.enterBreak_element(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBreak_element" ):
                listener.exitBreak_element(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBreak_element" ):
                return visitor.visitBreak_element(self)
            else:
                return visitor.visitChildren(self)




    def break_element(self):

        localctx = vhdlParser.Break_elementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_break_element)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 818
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==30:
                self.state = 817
                self.break_selector_clause()


            self.state = 820
            self.name()
            self.state = 821
            self.match(vhdlParser.ARROW)
            self.state = 822
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Break_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def break_element(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Break_elementContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Break_elementContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.COMMA)
            else:
                return self.getToken(vhdlParser.COMMA, i)

        def getRuleIndex(self):
            return vhdlParser.RULE_break_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBreak_list" ):
                listener.enterBreak_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBreak_list" ):
                listener.exitBreak_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBreak_list" ):
                return visitor.visitBreak_list(self)
            else:
                return visitor.visitChildren(self)




    def break_list(self):

        localctx = vhdlParser.Break_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_break_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 824
            self.break_element()
            self.state = 829
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==139:
                self.state = 825
                self.match(vhdlParser.COMMA)
                self.state = 826
                self.break_element()
                self.state = 831
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Break_selector_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(vhdlParser.FOR, 0)

        def name(self):
            return self.getTypedRuleContext(vhdlParser.NameContext,0)


        def USE(self):
            return self.getToken(vhdlParser.USE, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_break_selector_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBreak_selector_clause" ):
                listener.enterBreak_selector_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBreak_selector_clause" ):
                listener.exitBreak_selector_clause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBreak_selector_clause" ):
                return visitor.visitBreak_selector_clause(self)
            else:
                return visitor.visitChildren(self)




    def break_selector_clause(self):

        localctx = vhdlParser.Break_selector_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_break_selector_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 832
            self.match(vhdlParser.FOR)
            self.state = 833
            self.name()
            self.state = 834
            self.match(vhdlParser.USE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Break_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BREAK(self):
            return self.getToken(vhdlParser.BREAK, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def break_list(self):
            return self.getTypedRuleContext(vhdlParser.Break_listContext,0)


        def WHEN(self):
            return self.getToken(vhdlParser.WHEN, 0)

        def condition(self):
            return self.getTypedRuleContext(vhdlParser.ConditionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_break_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBreak_statement" ):
                listener.enterBreak_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBreak_statement" ):
                listener.exitBreak_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBreak_statement" ):
                return visitor.visitBreak_statement(self)
            else:
                return visitor.visitChildren(self)




    def break_statement(self):

        localctx = vhdlParser.Break_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_break_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 837
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 836
                self.label_colon()


            self.state = 839
            self.match(vhdlParser.BREAK)
            self.state = 841
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==30 or (((_la - 118)) & ~0x3f) == 0 and ((1 << (_la - 118)) & 515) != 0:
                self.state = 840
                self.break_list()


            self.state = 845
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==108:
                self.state = 843
                self.match(vhdlParser.WHEN)
                self.state = 844
                self.condition()


            self.state = 847
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Case_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CASE(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.CASE)
            else:
                return self.getToken(vhdlParser.CASE, i)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def IS(self):
            return self.getToken(vhdlParser.IS, 0)

        def END(self):
            return self.getToken(vhdlParser.END, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def case_statement_alternative(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Case_statement_alternativeContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Case_statement_alternativeContext,i)


        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_case_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCase_statement" ):
                listener.enterCase_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCase_statement" ):
                listener.exitCase_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCase_statement" ):
                return visitor.visitCase_statement(self)
            else:
                return visitor.visitChildren(self)




    def case_statement(self):

        localctx = vhdlParser.Case_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_case_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 850
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 849
                self.label_colon()


            self.state = 852
            self.match(vhdlParser.CASE)
            self.state = 853
            self.expression()
            self.state = 854
            self.match(vhdlParser.IS)
            self.state = 856 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 855
                self.case_statement_alternative()
                self.state = 858 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==108):
                    break

            self.state = 860
            self.match(vhdlParser.END)
            self.state = 861
            self.match(vhdlParser.CASE)
            self.state = 863
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 862
                self.identifier()


            self.state = 865
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Case_statement_alternativeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHEN(self):
            return self.getToken(vhdlParser.WHEN, 0)

        def choices(self):
            return self.getTypedRuleContext(vhdlParser.ChoicesContext,0)


        def ARROW(self):
            return self.getToken(vhdlParser.ARROW, 0)

        def sequence_of_statements(self):
            return self.getTypedRuleContext(vhdlParser.Sequence_of_statementsContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_case_statement_alternative

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCase_statement_alternative" ):
                listener.enterCase_statement_alternative(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCase_statement_alternative" ):
                listener.exitCase_statement_alternative(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCase_statement_alternative" ):
                return visitor.visitCase_statement_alternative(self)
            else:
                return visitor.visitChildren(self)




    def case_statement_alternative(self):

        localctx = vhdlParser.Case_statement_alternativeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_case_statement_alternative)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 867
            self.match(vhdlParser.WHEN)
            self.state = 868
            self.choices()
            self.state = 869
            self.match(vhdlParser.ARROW)
            self.state = 870
            self.sequence_of_statements()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChoiceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def discrete_range(self):
            return self.getTypedRuleContext(vhdlParser.Discrete_rangeContext,0)


        def simple_expression(self):
            return self.getTypedRuleContext(vhdlParser.Simple_expressionContext,0)


        def OTHERS(self):
            return self.getToken(vhdlParser.OTHERS, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_choice

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChoice" ):
                listener.enterChoice(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChoice" ):
                listener.exitChoice(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChoice" ):
                return visitor.visitChoice(self)
            else:
                return visitor.visitChildren(self)




    def choice(self):

        localctx = vhdlParser.ChoiceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_choice)
        try:
            self.state = 876
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 872
                self.identifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 873
                self.discrete_range()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 874
                self.simple_expression()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 875
                self.match(vhdlParser.OTHERS)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChoicesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def choice(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.ChoiceContext)
            else:
                return self.getTypedRuleContext(vhdlParser.ChoiceContext,i)


        def BAR(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.BAR)
            else:
                return self.getToken(vhdlParser.BAR, i)

        def getRuleIndex(self):
            return vhdlParser.RULE_choices

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChoices" ):
                listener.enterChoices(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChoices" ):
                listener.exitChoices(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChoices" ):
                return visitor.visitChoices(self)
            else:
                return visitor.visitChildren(self)




    def choices(self):

        localctx = vhdlParser.ChoicesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_choices)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 878
            self.choice()
            self.state = 883
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==153:
                self.state = 879
                self.match(vhdlParser.BAR)
                self.state = 880
                self.choice()
                self.state = 885
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Component_configurationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.FOR)
            else:
                return self.getToken(vhdlParser.FOR, i)

        def component_specification(self):
            return self.getTypedRuleContext(vhdlParser.Component_specificationContext,0)


        def END(self):
            return self.getToken(vhdlParser.END, 0)

        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.SEMI)
            else:
                return self.getToken(vhdlParser.SEMI, i)

        def binding_indication(self):
            return self.getTypedRuleContext(vhdlParser.Binding_indicationContext,0)


        def block_configuration(self):
            return self.getTypedRuleContext(vhdlParser.Block_configurationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_component_configuration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComponent_configuration" ):
                listener.enterComponent_configuration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComponent_configuration" ):
                listener.exitComponent_configuration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComponent_configuration" ):
                return visitor.visitComponent_configuration(self)
            else:
                return visitor.visitChildren(self)




    def component_configuration(self):

        localctx = vhdlParser.Component_configurationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_component_configuration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 886
            self.match(vhdlParser.FOR)
            self.state = 887
            self.component_specification()
            self.state = 891
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33 or _la==65 or _la==104 or _la==138:
                self.state = 888
                self.binding_indication()
                self.state = 889
                self.match(vhdlParser.SEMI)


            self.state = 894
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==30:
                self.state = 893
                self.block_configuration()


            self.state = 896
            self.match(vhdlParser.END)
            self.state = 897
            self.match(vhdlParser.FOR)
            self.state = 898
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Component_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMPONENT(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.COMPONENT)
            else:
                return self.getToken(vhdlParser.COMPONENT, i)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(vhdlParser.IdentifierContext,i)


        def END(self):
            return self.getToken(vhdlParser.END, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def IS(self):
            return self.getToken(vhdlParser.IS, 0)

        def generic_clause(self):
            return self.getTypedRuleContext(vhdlParser.Generic_clauseContext,0)


        def port_clause(self):
            return self.getTypedRuleContext(vhdlParser.Port_clauseContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_component_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComponent_declaration" ):
                listener.enterComponent_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComponent_declaration" ):
                listener.exitComponent_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComponent_declaration" ):
                return visitor.visitComponent_declaration(self)
            else:
                return visitor.visitChildren(self)




    def component_declaration(self):

        localctx = vhdlParser.Component_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_component_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 900
            self.match(vhdlParser.COMPONENT)
            self.state = 901
            self.identifier()
            self.state = 903
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41:
                self.state = 902
                self.match(vhdlParser.IS)


            self.state = 906
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 905
                self.generic_clause()


            self.state = 909
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==65:
                self.state = 908
                self.port_clause()


            self.state = 911
            self.match(vhdlParser.END)
            self.state = 912
            self.match(vhdlParser.COMPONENT)
            self.state = 914
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 913
                self.identifier()


            self.state = 916
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Component_instantiation_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def instantiated_unit(self):
            return self.getTypedRuleContext(vhdlParser.Instantiated_unitContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def generic_map_aspect(self):
            return self.getTypedRuleContext(vhdlParser.Generic_map_aspectContext,0)


        def port_map_aspect(self):
            return self.getTypedRuleContext(vhdlParser.Port_map_aspectContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_component_instantiation_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComponent_instantiation_statement" ):
                listener.enterComponent_instantiation_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComponent_instantiation_statement" ):
                listener.exitComponent_instantiation_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComponent_instantiation_statement" ):
                return visitor.visitComponent_instantiation_statement(self)
            else:
                return visitor.visitChildren(self)




    def component_instantiation_statement(self):

        localctx = vhdlParser.Component_instantiation_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_component_instantiation_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 918
            self.label_colon()
            self.state = 919
            self.instantiated_unit()
            self.state = 921
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 920
                self.generic_map_aspect()


            self.state = 924
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==65:
                self.state = 923
                self.port_map_aspect()


            self.state = 926
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Component_specificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def instantiation_list(self):
            return self.getTypedRuleContext(vhdlParser.Instantiation_listContext,0)


        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def name(self):
            return self.getTypedRuleContext(vhdlParser.NameContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_component_specification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComponent_specification" ):
                listener.enterComponent_specification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComponent_specification" ):
                listener.exitComponent_specification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComponent_specification" ):
                return visitor.visitComponent_specification(self)
            else:
                return visitor.visitChildren(self)




    def component_specification(self):

        localctx = vhdlParser.Component_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_component_specification)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 928
            self.instantiation_list()
            self.state = 929
            self.match(vhdlParser.COLON)
            self.state = 930
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Composite_nature_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def array_nature_definition(self):
            return self.getTypedRuleContext(vhdlParser.Array_nature_definitionContext,0)


        def record_nature_definition(self):
            return self.getTypedRuleContext(vhdlParser.Record_nature_definitionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_composite_nature_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComposite_nature_definition" ):
                listener.enterComposite_nature_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComposite_nature_definition" ):
                listener.exitComposite_nature_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComposite_nature_definition" ):
                return visitor.visitComposite_nature_definition(self)
            else:
                return visitor.visitChildren(self)




    def composite_nature_definition(self):

        localctx = vhdlParser.Composite_nature_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_composite_nature_definition)
        try:
            self.state = 934
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [9]:
                self.enterOuterAlt(localctx, 1)
                self.state = 932
                self.array_nature_definition()
                pass
            elif token in [76]:
                self.enterOuterAlt(localctx, 2)
                self.state = 933
                self.record_nature_definition()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Composite_type_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def array_type_definition(self):
            return self.getTypedRuleContext(vhdlParser.Array_type_definitionContext,0)


        def record_type_definition(self):
            return self.getTypedRuleContext(vhdlParser.Record_type_definitionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_composite_type_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComposite_type_definition" ):
                listener.enterComposite_type_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComposite_type_definition" ):
                listener.exitComposite_type_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComposite_type_definition" ):
                return visitor.visitComposite_type_definition(self)
            else:
                return visitor.visitChildren(self)




    def composite_type_definition(self):

        localctx = vhdlParser.Composite_type_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_composite_type_definition)
        try:
            self.state = 938
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [9]:
                self.enterOuterAlt(localctx, 1)
                self.state = 936
                self.array_type_definition()
                pass
            elif token in [76]:
                self.enterOuterAlt(localctx, 2)
                self.state = 937
                self.record_type_definition()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Concurrent_assertion_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assertion(self):
            return self.getTypedRuleContext(vhdlParser.AssertionContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def POSTPONED(self):
            return self.getToken(vhdlParser.POSTPONED, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_concurrent_assertion_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConcurrent_assertion_statement" ):
                listener.enterConcurrent_assertion_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConcurrent_assertion_statement" ):
                listener.exitConcurrent_assertion_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConcurrent_assertion_statement" ):
                return visitor.visitConcurrent_assertion_statement(self)
            else:
                return visitor.visitChildren(self)




    def concurrent_assertion_statement(self):

        localctx = vhdlParser.Concurrent_assertion_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_concurrent_assertion_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 941
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 940
                self.label_colon()


            self.state = 944
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==66:
                self.state = 943
                self.match(vhdlParser.POSTPONED)


            self.state = 946
            self.assertion()
            self.state = 947
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Concurrent_break_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BREAK(self):
            return self.getToken(vhdlParser.BREAK, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def break_list(self):
            return self.getTypedRuleContext(vhdlParser.Break_listContext,0)


        def sensitivity_clause(self):
            return self.getTypedRuleContext(vhdlParser.Sensitivity_clauseContext,0)


        def WHEN(self):
            return self.getToken(vhdlParser.WHEN, 0)

        def condition(self):
            return self.getTypedRuleContext(vhdlParser.ConditionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_concurrent_break_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConcurrent_break_statement" ):
                listener.enterConcurrent_break_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConcurrent_break_statement" ):
                listener.exitConcurrent_break_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConcurrent_break_statement" ):
                return visitor.visitConcurrent_break_statement(self)
            else:
                return visitor.visitChildren(self)




    def concurrent_break_statement(self):

        localctx = vhdlParser.Concurrent_break_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_concurrent_break_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 950
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 949
                self.label_colon()


            self.state = 952
            self.match(vhdlParser.BREAK)
            self.state = 954
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==30 or (((_la - 118)) & ~0x3f) == 0 and ((1 << (_la - 118)) & 515) != 0:
                self.state = 953
                self.break_list()


            self.state = 957
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==59:
                self.state = 956
                self.sensitivity_clause()


            self.state = 961
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==108:
                self.state = 959
                self.match(vhdlParser.WHEN)
                self.state = 960
                self.condition()


            self.state = 963
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Concurrent_procedure_call_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def procedure_call(self):
            return self.getTypedRuleContext(vhdlParser.Procedure_callContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def POSTPONED(self):
            return self.getToken(vhdlParser.POSTPONED, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_concurrent_procedure_call_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConcurrent_procedure_call_statement" ):
                listener.enterConcurrent_procedure_call_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConcurrent_procedure_call_statement" ):
                listener.exitConcurrent_procedure_call_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConcurrent_procedure_call_statement" ):
                return visitor.visitConcurrent_procedure_call_statement(self)
            else:
                return visitor.visitChildren(self)




    def concurrent_procedure_call_statement(self):

        localctx = vhdlParser.Concurrent_procedure_call_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_concurrent_procedure_call_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 966
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,72,self._ctx)
            if la_ == 1:
                self.state = 965
                self.label_colon()


            self.state = 969
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==66:
                self.state = 968
                self.match(vhdlParser.POSTPONED)


            self.state = 971
            self.procedure_call()
            self.state = 972
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Concurrent_signal_assignment_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def conditional_signal_assignment(self):
            return self.getTypedRuleContext(vhdlParser.Conditional_signal_assignmentContext,0)


        def selected_signal_assignment(self):
            return self.getTypedRuleContext(vhdlParser.Selected_signal_assignmentContext,0)


        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def POSTPONED(self):
            return self.getToken(vhdlParser.POSTPONED, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_concurrent_signal_assignment_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConcurrent_signal_assignment_statement" ):
                listener.enterConcurrent_signal_assignment_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConcurrent_signal_assignment_statement" ):
                listener.exitConcurrent_signal_assignment_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConcurrent_signal_assignment_statement" ):
                return visitor.visitConcurrent_signal_assignment_statement(self)
            else:
                return visitor.visitChildren(self)




    def concurrent_signal_assignment_statement(self):

        localctx = vhdlParser.Concurrent_signal_assignment_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_concurrent_signal_assignment_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 975
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,74,self._ctx)
            if la_ == 1:
                self.state = 974
                self.label_colon()


            self.state = 978
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==66:
                self.state = 977
                self.match(vhdlParser.POSTPONED)


            self.state = 982
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [118, 119, 127, 141]:
                self.state = 980
                self.conditional_signal_assignment()
                pass
            elif token in [107]:
                self.state = 981
                self.selected_signal_assignment()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondition" ):
                return visitor.visitCondition(self)
            else:
                return visitor.visitChildren(self)




    def condition(self):

        localctx = vhdlParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_condition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 984
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Condition_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNTIL(self):
            return self.getToken(vhdlParser.UNTIL, 0)

        def condition(self):
            return self.getTypedRuleContext(vhdlParser.ConditionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_condition_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition_clause" ):
                listener.enterCondition_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition_clause" ):
                listener.exitCondition_clause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondition_clause" ):
                return visitor.visitCondition_clause(self)
            else:
                return visitor.visitChildren(self)




    def condition_clause(self):

        localctx = vhdlParser.Condition_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_condition_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 986
            self.match(vhdlParser.UNTIL)
            self.state = 987
            self.condition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Conditional_signal_assignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def target(self):
            return self.getTypedRuleContext(vhdlParser.TargetContext,0)


        def LE(self):
            return self.getToken(vhdlParser.LE, 0)

        def opts(self):
            return self.getTypedRuleContext(vhdlParser.OptsContext,0)


        def conditional_waveforms(self):
            return self.getTypedRuleContext(vhdlParser.Conditional_waveformsContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_conditional_signal_assignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditional_signal_assignment" ):
                listener.enterConditional_signal_assignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditional_signal_assignment" ):
                listener.exitConditional_signal_assignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditional_signal_assignment" ):
                return visitor.visitConditional_signal_assignment(self)
            else:
                return visitor.visitChildren(self)




    def conditional_signal_assignment(self):

        localctx = vhdlParser.Conditional_signal_assignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_conditional_signal_assignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 989
            self.target()
            self.state = 990
            self.match(vhdlParser.LE)
            self.state = 991
            self.opts()
            self.state = 992
            self.conditional_waveforms()
            self.state = 993
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Conditional_waveformsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def waveform(self):
            return self.getTypedRuleContext(vhdlParser.WaveformContext,0)


        def WHEN(self):
            return self.getToken(vhdlParser.WHEN, 0)

        def condition(self):
            return self.getTypedRuleContext(vhdlParser.ConditionContext,0)


        def ELSE(self):
            return self.getToken(vhdlParser.ELSE, 0)

        def conditional_waveforms(self):
            return self.getTypedRuleContext(vhdlParser.Conditional_waveformsContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_conditional_waveforms

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditional_waveforms" ):
                listener.enterConditional_waveforms(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditional_waveforms" ):
                listener.exitConditional_waveforms(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditional_waveforms" ):
                return visitor.visitConditional_waveforms(self)
            else:
                return visitor.visitChildren(self)




    def conditional_waveforms(self):

        localctx = vhdlParser.Conditional_waveformsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_conditional_waveforms)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 995
            self.waveform()
            self.state = 1002
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==108:
                self.state = 996
                self.match(vhdlParser.WHEN)
                self.state = 997
                self.condition()
                self.state = 1000
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==26:
                    self.state = 998
                    self.match(vhdlParser.ELSE)
                    self.state = 999
                    self.conditional_waveforms()




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Configuration_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONFIGURATION(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.CONFIGURATION)
            else:
                return self.getToken(vhdlParser.CONFIGURATION, i)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(vhdlParser.IdentifierContext,i)


        def OF(self):
            return self.getToken(vhdlParser.OF, 0)

        def name(self):
            return self.getTypedRuleContext(vhdlParser.NameContext,0)


        def IS(self):
            return self.getToken(vhdlParser.IS, 0)

        def configuration_declarative_part(self):
            return self.getTypedRuleContext(vhdlParser.Configuration_declarative_partContext,0)


        def block_configuration(self):
            return self.getTypedRuleContext(vhdlParser.Block_configurationContext,0)


        def END(self):
            return self.getToken(vhdlParser.END, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_configuration_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConfiguration_declaration" ):
                listener.enterConfiguration_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConfiguration_declaration" ):
                listener.exitConfiguration_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConfiguration_declaration" ):
                return visitor.visitConfiguration_declaration(self)
            else:
                return visitor.visitChildren(self)




    def configuration_declaration(self):

        localctx = vhdlParser.Configuration_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_configuration_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1004
            self.match(vhdlParser.CONFIGURATION)
            self.state = 1005
            self.identifier()
            self.state = 1006
            self.match(vhdlParser.OF)
            self.state = 1007
            self.name()
            self.state = 1008
            self.match(vhdlParser.IS)
            self.state = 1009
            self.configuration_declarative_part()
            self.state = 1010
            self.block_configuration()
            self.state = 1011
            self.match(vhdlParser.END)
            self.state = 1013
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==20:
                self.state = 1012
                self.match(vhdlParser.CONFIGURATION)


            self.state = 1016
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 1015
                self.identifier()


            self.state = 1018
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Configuration_declarative_itemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def use_clause(self):
            return self.getTypedRuleContext(vhdlParser.Use_clauseContext,0)


        def attribute_specification(self):
            return self.getTypedRuleContext(vhdlParser.Attribute_specificationContext,0)


        def group_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Group_declarationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_configuration_declarative_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConfiguration_declarative_item" ):
                listener.enterConfiguration_declarative_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConfiguration_declarative_item" ):
                listener.exitConfiguration_declarative_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConfiguration_declarative_item" ):
                return visitor.visitConfiguration_declarative_item(self)
            else:
                return visitor.visitChildren(self)




    def configuration_declarative_item(self):

        localctx = vhdlParser.Configuration_declarative_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_configuration_declarative_item)
        try:
            self.state = 1023
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [104]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1020
                self.use_clause()
                pass
            elif token in [11]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1021
                self.attribute_specification()
                pass
            elif token in [34]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1022
                self.group_declaration()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Configuration_declarative_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def configuration_declarative_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Configuration_declarative_itemContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Configuration_declarative_itemContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_configuration_declarative_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConfiguration_declarative_part" ):
                listener.enterConfiguration_declarative_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConfiguration_declarative_part" ):
                listener.exitConfiguration_declarative_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConfiguration_declarative_part" ):
                return visitor.visitConfiguration_declarative_part(self)
            else:
                return visitor.visitChildren(self)




    def configuration_declarative_part(self):

        localctx = vhdlParser.Configuration_declarative_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_configuration_declarative_part)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1028
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11 or _la==34 or _la==104:
                self.state = 1025
                self.configuration_declarative_item()
                self.state = 1030
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Configuration_itemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block_configuration(self):
            return self.getTypedRuleContext(vhdlParser.Block_configurationContext,0)


        def component_configuration(self):
            return self.getTypedRuleContext(vhdlParser.Component_configurationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_configuration_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConfiguration_item" ):
                listener.enterConfiguration_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConfiguration_item" ):
                listener.exitConfiguration_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConfiguration_item" ):
                return visitor.visitConfiguration_item(self)
            else:
                return visitor.visitChildren(self)




    def configuration_item(self):

        localctx = vhdlParser.Configuration_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_configuration_item)
        try:
            self.state = 1033
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1031
                self.block_configuration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1032
                self.component_configuration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Configuration_specificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(vhdlParser.FOR, 0)

        def component_specification(self):
            return self.getTypedRuleContext(vhdlParser.Component_specificationContext,0)


        def binding_indication(self):
            return self.getTypedRuleContext(vhdlParser.Binding_indicationContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_configuration_specification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConfiguration_specification" ):
                listener.enterConfiguration_specification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConfiguration_specification" ):
                listener.exitConfiguration_specification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConfiguration_specification" ):
                return visitor.visitConfiguration_specification(self)
            else:
                return visitor.visitChildren(self)




    def configuration_specification(self):

        localctx = vhdlParser.Configuration_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_configuration_specification)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1035
            self.match(vhdlParser.FOR)
            self.state = 1036
            self.component_specification()
            self.state = 1037
            self.binding_indication()
            self.state = 1038
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Constant_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONSTANT(self):
            return self.getToken(vhdlParser.CONSTANT, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(vhdlParser.Identifier_listContext,0)


        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def VARASGN(self):
            return self.getToken(vhdlParser.VARASGN, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_constant_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant_declaration" ):
                listener.enterConstant_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant_declaration" ):
                listener.exitConstant_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstant_declaration" ):
                return visitor.visitConstant_declaration(self)
            else:
                return visitor.visitChildren(self)




    def constant_declaration(self):

        localctx = vhdlParser.Constant_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_constant_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1040
            self.match(vhdlParser.CONSTANT)
            self.state = 1041
            self.identifier_list()
            self.state = 1042
            self.match(vhdlParser.COLON)
            self.state = 1043
            self.subtype_indication()
            self.state = 1046
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==135:
                self.state = 1044
                self.match(vhdlParser.VARASGN)
                self.state = 1045
                self.expression()


            self.state = 1048
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Constrained_array_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ARRAY(self):
            return self.getToken(vhdlParser.ARRAY, 0)

        def index_constraint(self):
            return self.getTypedRuleContext(vhdlParser.Index_constraintContext,0)


        def OF(self):
            return self.getToken(vhdlParser.OF, 0)

        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_constrained_array_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstrained_array_definition" ):
                listener.enterConstrained_array_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstrained_array_definition" ):
                listener.exitConstrained_array_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstrained_array_definition" ):
                return visitor.visitConstrained_array_definition(self)
            else:
                return visitor.visitChildren(self)




    def constrained_array_definition(self):

        localctx = vhdlParser.Constrained_array_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_constrained_array_definition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1050
            self.match(vhdlParser.ARRAY)
            self.state = 1051
            self.index_constraint()
            self.state = 1052
            self.match(vhdlParser.OF)
            self.state = 1053
            self.subtype_indication()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Constrained_nature_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ARRAY(self):
            return self.getToken(vhdlParser.ARRAY, 0)

        def index_constraint(self):
            return self.getTypedRuleContext(vhdlParser.Index_constraintContext,0)


        def OF(self):
            return self.getToken(vhdlParser.OF, 0)

        def subnature_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subnature_indicationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_constrained_nature_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstrained_nature_definition" ):
                listener.enterConstrained_nature_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstrained_nature_definition" ):
                listener.exitConstrained_nature_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstrained_nature_definition" ):
                return visitor.visitConstrained_nature_definition(self)
            else:
                return visitor.visitChildren(self)




    def constrained_nature_definition(self):

        localctx = vhdlParser.Constrained_nature_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_constrained_nature_definition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1055
            self.match(vhdlParser.ARRAY)
            self.state = 1056
            self.index_constraint()
            self.state = 1057
            self.match(vhdlParser.OF)
            self.state = 1058
            self.subnature_indication()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def range_constraint(self):
            return self.getTypedRuleContext(vhdlParser.Range_constraintContext,0)


        def index_constraint(self):
            return self.getTypedRuleContext(vhdlParser.Index_constraintContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_constraint

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstraint" ):
                listener.enterConstraint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstraint" ):
                listener.exitConstraint(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstraint" ):
                return visitor.visitConstraint(self)
            else:
                return visitor.visitChildren(self)




    def constraint(self):

        localctx = vhdlParser.ConstraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_constraint)
        try:
            self.state = 1062
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [72]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1060
                self.range_constraint()
                pass
            elif token in [141]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1061
                self.index_constraint()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Context_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def context_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Context_itemContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Context_itemContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_context_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContext_clause" ):
                listener.enterContext_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContext_clause" ):
                listener.exitContext_clause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitContext_clause" ):
                return visitor.visitContext_clause(self)
            else:
                return visitor.visitChildren(self)




    def context_clause(self):

        localctx = vhdlParser.Context_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_context_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1067
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==43 or _la==104:
                self.state = 1064
                self.context_item()
                self.state = 1069
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Context_itemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def library_clause(self):
            return self.getTypedRuleContext(vhdlParser.Library_clauseContext,0)


        def use_clause(self):
            return self.getTypedRuleContext(vhdlParser.Use_clauseContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_context_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContext_item" ):
                listener.enterContext_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContext_item" ):
                listener.exitContext_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitContext_item" ):
                return visitor.visitContext_item(self)
            else:
                return visitor.visitChildren(self)




    def context_item(self):

        localctx = vhdlParser.Context_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_context_item)
        try:
            self.state = 1072
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [43]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1070
                self.library_clause()
                pass
            elif token in [104]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1071
                self.use_clause()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Delay_mechanismContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRANSPORT(self):
            return self.getToken(vhdlParser.TRANSPORT, 0)

        def INERTIAL(self):
            return self.getToken(vhdlParser.INERTIAL, 0)

        def REJECT(self):
            return self.getToken(vhdlParser.REJECT, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_delay_mechanism

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDelay_mechanism" ):
                listener.enterDelay_mechanism(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDelay_mechanism" ):
                listener.exitDelay_mechanism(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDelay_mechanism" ):
                return visitor.visitDelay_mechanism(self)
            else:
                return visitor.visitChildren(self)




    def delay_mechanism(self):

        localctx = vhdlParser.Delay_mechanismContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_delay_mechanism)
        self._la = 0 # Token type
        try:
            self.state = 1080
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [99]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1074
                self.match(vhdlParser.TRANSPORT)
                pass
            elif token in [39, 74]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1077
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==74:
                    self.state = 1075
                    self.match(vhdlParser.REJECT)
                    self.state = 1076
                    self.expression()


                self.state = 1079
                self.match(vhdlParser.INERTIAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Design_fileContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(vhdlParser.EOF, 0)

        def design_unit(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Design_unitContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Design_unitContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_design_file

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDesign_file" ):
                listener.enterDesign_file(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDesign_file" ):
                listener.exitDesign_file(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDesign_file" ):
                return visitor.visitDesign_file(self)
            else:
                return visitor.visitChildren(self)




    def design_file(self):

        localctx = vhdlParser.Design_fileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_design_file)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1085
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & 8796127625472) != 0 or _la==64 or _la==104:
                self.state = 1082
                self.design_unit()
                self.state = 1087
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1088
            self.match(vhdlParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Design_unitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def context_clause(self):
            return self.getTypedRuleContext(vhdlParser.Context_clauseContext,0)


        def library_unit(self):
            return self.getTypedRuleContext(vhdlParser.Library_unitContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_design_unit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDesign_unit" ):
                listener.enterDesign_unit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDesign_unit" ):
                listener.exitDesign_unit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDesign_unit" ):
                return visitor.visitDesign_unit(self)
            else:
                return visitor.visitChildren(self)




    def design_unit(self):

        localctx = vhdlParser.Design_unitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_design_unit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1090
            self.context_clause()
            self.state = 1091
            self.library_unit()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DesignatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def STRING_LITERAL(self):
            return self.getToken(vhdlParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_designator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDesignator" ):
                listener.enterDesignator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDesignator" ):
                listener.exitDesignator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDesignator" ):
                return visitor.visitDesignator(self)
            else:
                return visitor.visitChildren(self)




    def designator(self):

        localctx = vhdlParser.DesignatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_designator)
        try:
            self.state = 1095
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [118, 119]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1093
                self.identifier()
                pass
            elif token in [127]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1094
                self.match(vhdlParser.STRING_LITERAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DirectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TO(self):
            return self.getToken(vhdlParser.TO, 0)

        def DOWNTO(self):
            return self.getToken(vhdlParser.DOWNTO, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_direction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirection" ):
                listener.enterDirection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirection" ):
                listener.exitDirection(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDirection" ):
                return visitor.visitDirection(self)
            else:
                return visitor.visitChildren(self)




    def direction(self):

        localctx = vhdlParser.DirectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_direction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1097
            _la = self._input.LA(1)
            if not(_la==23 or _la==97):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Disconnection_specificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISCONNECT(self):
            return self.getToken(vhdlParser.DISCONNECT, 0)

        def guarded_signal_specification(self):
            return self.getTypedRuleContext(vhdlParser.Guarded_signal_specificationContext,0)


        def AFTER(self):
            return self.getToken(vhdlParser.AFTER, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_disconnection_specification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDisconnection_specification" ):
                listener.enterDisconnection_specification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDisconnection_specification" ):
                listener.exitDisconnection_specification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDisconnection_specification" ):
                return visitor.visitDisconnection_specification(self)
            else:
                return visitor.visitChildren(self)




    def disconnection_specification(self):

        localctx = vhdlParser.Disconnection_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_disconnection_specification)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1099
            self.match(vhdlParser.DISCONNECT)
            self.state = 1100
            self.guarded_signal_specification()
            self.state = 1101
            self.match(vhdlParser.AFTER)
            self.state = 1102
            self.expression()
            self.state = 1103
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Discrete_rangeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def range_decl(self):
            return self.getTypedRuleContext(vhdlParser.Range_declContext,0)


        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_discrete_range

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDiscrete_range" ):
                listener.enterDiscrete_range(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDiscrete_range" ):
                listener.exitDiscrete_range(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDiscrete_range" ):
                return visitor.visitDiscrete_range(self)
            else:
                return visitor.visitChildren(self)




    def discrete_range(self):

        localctx = vhdlParser.Discrete_rangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_discrete_range)
        try:
            self.state = 1107
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,92,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1105
                self.range_decl()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1106
                self.subtype_indication()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Element_associationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def choices(self):
            return self.getTypedRuleContext(vhdlParser.ChoicesContext,0)


        def ARROW(self):
            return self.getToken(vhdlParser.ARROW, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_element_association

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElement_association" ):
                listener.enterElement_association(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElement_association" ):
                listener.exitElement_association(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElement_association" ):
                return visitor.visitElement_association(self)
            else:
                return visitor.visitChildren(self)




    def element_association(self):

        localctx = vhdlParser.Element_associationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_element_association)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1112
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,93,self._ctx)
            if la_ == 1:
                self.state = 1109
                self.choices()
                self.state = 1110
                self.match(vhdlParser.ARROW)


            self.state = 1114
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Element_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier_list(self):
            return self.getTypedRuleContext(vhdlParser.Identifier_listContext,0)


        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def element_subtype_definition(self):
            return self.getTypedRuleContext(vhdlParser.Element_subtype_definitionContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_element_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElement_declaration" ):
                listener.enterElement_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElement_declaration" ):
                listener.exitElement_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElement_declaration" ):
                return visitor.visitElement_declaration(self)
            else:
                return visitor.visitChildren(self)




    def element_declaration(self):

        localctx = vhdlParser.Element_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_element_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1116
            self.identifier_list()
            self.state = 1117
            self.match(vhdlParser.COLON)
            self.state = 1118
            self.element_subtype_definition()
            self.state = 1119
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Element_subnature_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subnature_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subnature_indicationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_element_subnature_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElement_subnature_definition" ):
                listener.enterElement_subnature_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElement_subnature_definition" ):
                listener.exitElement_subnature_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElement_subnature_definition" ):
                return visitor.visitElement_subnature_definition(self)
            else:
                return visitor.visitChildren(self)




    def element_subnature_definition(self):

        localctx = vhdlParser.Element_subnature_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_element_subnature_definition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1121
            self.subnature_indication()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Element_subtype_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_element_subtype_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElement_subtype_definition" ):
                listener.enterElement_subtype_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElement_subtype_definition" ):
                listener.exitElement_subtype_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElement_subtype_definition" ):
                return visitor.visitElement_subtype_definition(self)
            else:
                return visitor.visitChildren(self)




    def element_subtype_definition(self):

        localctx = vhdlParser.Element_subtype_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_element_subtype_definition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1123
            self.subtype_indication()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Entity_aspectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENTITY(self):
            return self.getToken(vhdlParser.ENTITY, 0)

        def name(self):
            return self.getTypedRuleContext(vhdlParser.NameContext,0)


        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def CONFIGURATION(self):
            return self.getToken(vhdlParser.CONFIGURATION, 0)

        def OPEN(self):
            return self.getToken(vhdlParser.OPEN, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_entity_aspect

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntity_aspect" ):
                listener.enterEntity_aspect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntity_aspect" ):
                listener.exitEntity_aspect(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEntity_aspect" ):
                return visitor.visitEntity_aspect(self)
            else:
                return visitor.visitChildren(self)




    def entity_aspect(self):

        localctx = vhdlParser.Entity_aspectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_entity_aspect)
        self._la = 0 # Token type
        try:
            self.state = 1136
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [25]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1125
                self.match(vhdlParser.ENTITY)
                self.state = 1126
                self.name()
                self.state = 1131
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==141:
                    self.state = 1127
                    self.match(vhdlParser.LPAREN)
                    self.state = 1128
                    self.identifier()
                    self.state = 1129
                    self.match(vhdlParser.RPAREN)


                pass
            elif token in [20]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1133
                self.match(vhdlParser.CONFIGURATION)
                self.state = 1134
                self.name()
                pass
            elif token in [60]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1135
                self.match(vhdlParser.OPEN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Entity_classContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENTITY(self):
            return self.getToken(vhdlParser.ENTITY, 0)

        def ARCHITECTURE(self):
            return self.getToken(vhdlParser.ARCHITECTURE, 0)

        def CONFIGURATION(self):
            return self.getToken(vhdlParser.CONFIGURATION, 0)

        def PROCEDURE(self):
            return self.getToken(vhdlParser.PROCEDURE, 0)

        def FUNCTION(self):
            return self.getToken(vhdlParser.FUNCTION, 0)

        def PACKAGE(self):
            return self.getToken(vhdlParser.PACKAGE, 0)

        def TYPE(self):
            return self.getToken(vhdlParser.TYPE, 0)

        def SUBTYPE(self):
            return self.getToken(vhdlParser.SUBTYPE, 0)

        def CONSTANT(self):
            return self.getToken(vhdlParser.CONSTANT, 0)

        def SIGNAL(self):
            return self.getToken(vhdlParser.SIGNAL, 0)

        def VARIABLE(self):
            return self.getToken(vhdlParser.VARIABLE, 0)

        def COMPONENT(self):
            return self.getToken(vhdlParser.COMPONENT, 0)

        def LABEL(self):
            return self.getToken(vhdlParser.LABEL, 0)

        def LITERAL(self):
            return self.getToken(vhdlParser.LITERAL, 0)

        def UNITS(self):
            return self.getToken(vhdlParser.UNITS, 0)

        def GROUP(self):
            return self.getToken(vhdlParser.GROUP, 0)

        def FILE(self):
            return self.getToken(vhdlParser.FILE, 0)

        def NATURE(self):
            return self.getToken(vhdlParser.NATURE, 0)

        def SUBNATURE(self):
            return self.getToken(vhdlParser.SUBNATURE, 0)

        def QUANTITY(self):
            return self.getToken(vhdlParser.QUANTITY, 0)

        def TERMINAL(self):
            return self.getToken(vhdlParser.TERMINAL, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_entity_class

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntity_class" ):
                listener.enterEntity_class(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntity_class" ):
                listener.exitEntity_class(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEntity_class" ):
                return visitor.visitEntity_class(self)
            else:
                return visitor.visitChildren(self)




    def entity_class(self):

        localctx = vhdlParser.Entity_classContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_entity_class)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1138
            _la = self._input.LA(1)
            if not(((_la) & ~0x3f) == 0 and ((1 << _la) & 2326586505822464) != 0 or (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 2544503881873) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Entity_class_entryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def entity_class(self):
            return self.getTypedRuleContext(vhdlParser.Entity_classContext,0)


        def BOX(self):
            return self.getToken(vhdlParser.BOX, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_entity_class_entry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntity_class_entry" ):
                listener.enterEntity_class_entry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntity_class_entry" ):
                listener.exitEntity_class_entry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEntity_class_entry" ):
                return visitor.visitEntity_class_entry(self)
            else:
                return visitor.visitChildren(self)




    def entity_class_entry(self):

        localctx = vhdlParser.Entity_class_entryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_entity_class_entry)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1140
            self.entity_class()
            self.state = 1142
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==136:
                self.state = 1141
                self.match(vhdlParser.BOX)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Entity_class_entry_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def entity_class_entry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Entity_class_entryContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Entity_class_entryContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.COMMA)
            else:
                return self.getToken(vhdlParser.COMMA, i)

        def getRuleIndex(self):
            return vhdlParser.RULE_entity_class_entry_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntity_class_entry_list" ):
                listener.enterEntity_class_entry_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntity_class_entry_list" ):
                listener.exitEntity_class_entry_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEntity_class_entry_list" ):
                return visitor.visitEntity_class_entry_list(self)
            else:
                return visitor.visitChildren(self)




    def entity_class_entry_list(self):

        localctx = vhdlParser.Entity_class_entry_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_entity_class_entry_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1144
            self.entity_class_entry()
            self.state = 1149
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==139:
                self.state = 1145
                self.match(vhdlParser.COMMA)
                self.state = 1146
                self.entity_class_entry()
                self.state = 1151
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Entity_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENTITY(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.ENTITY)
            else:
                return self.getToken(vhdlParser.ENTITY, i)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(vhdlParser.IdentifierContext,i)


        def IS(self):
            return self.getToken(vhdlParser.IS, 0)

        def entity_header(self):
            return self.getTypedRuleContext(vhdlParser.Entity_headerContext,0)


        def entity_declarative_part(self):
            return self.getTypedRuleContext(vhdlParser.Entity_declarative_partContext,0)


        def END(self):
            return self.getToken(vhdlParser.END, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def BEGIN(self):
            return self.getToken(vhdlParser.BEGIN, 0)

        def entity_statement_part(self):
            return self.getTypedRuleContext(vhdlParser.Entity_statement_partContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_entity_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntity_declaration" ):
                listener.enterEntity_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntity_declaration" ):
                listener.exitEntity_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEntity_declaration" ):
                return visitor.visitEntity_declaration(self)
            else:
                return visitor.visitChildren(self)




    def entity_declaration(self):

        localctx = vhdlParser.Entity_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_entity_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1152
            self.match(vhdlParser.ENTITY)
            self.state = 1153
            self.identifier()
            self.state = 1154
            self.match(vhdlParser.IS)
            self.state = 1155
            self.entity_header()
            self.state = 1156
            self.entity_declarative_part()
            self.state = 1159
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 1157
                self.match(vhdlParser.BEGIN)
                self.state = 1158
                self.entity_statement_part()


            self.state = 1161
            self.match(vhdlParser.END)
            self.state = 1163
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==25:
                self.state = 1162
                self.match(vhdlParser.ENTITY)


            self.state = 1166
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 1165
                self.identifier()


            self.state = 1168
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Entity_declarative_itemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subprogram_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Subprogram_declarationContext,0)


        def subprogram_body(self):
            return self.getTypedRuleContext(vhdlParser.Subprogram_bodyContext,0)


        def type_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Type_declarationContext,0)


        def subtype_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_declarationContext,0)


        def constant_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Constant_declarationContext,0)


        def signal_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Signal_declarationContext,0)


        def variable_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Variable_declarationContext,0)


        def file_declaration(self):
            return self.getTypedRuleContext(vhdlParser.File_declarationContext,0)


        def alias_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Alias_declarationContext,0)


        def attribute_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Attribute_declarationContext,0)


        def attribute_specification(self):
            return self.getTypedRuleContext(vhdlParser.Attribute_specificationContext,0)


        def disconnection_specification(self):
            return self.getTypedRuleContext(vhdlParser.Disconnection_specificationContext,0)


        def step_limit_specification(self):
            return self.getTypedRuleContext(vhdlParser.Step_limit_specificationContext,0)


        def use_clause(self):
            return self.getTypedRuleContext(vhdlParser.Use_clauseContext,0)


        def group_template_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Group_template_declarationContext,0)


        def group_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Group_declarationContext,0)


        def nature_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Nature_declarationContext,0)


        def subnature_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Subnature_declarationContext,0)


        def quantity_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Quantity_declarationContext,0)


        def terminal_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Terminal_declarationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_entity_declarative_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntity_declarative_item" ):
                listener.enterEntity_declarative_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntity_declarative_item" ):
                listener.exitEntity_declarative_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEntity_declarative_item" ):
                return visitor.visitEntity_declarative_item(self)
            else:
                return visitor.visitChildren(self)




    def entity_declarative_item(self):

        localctx = vhdlParser.Entity_declarative_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_entity_declarative_item)
        try:
            self.state = 1190
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,101,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1170
                self.subprogram_declaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1171
                self.subprogram_body()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1172
                self.type_declaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1173
                self.subtype_declaration()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1174
                self.constant_declaration()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1175
                self.signal_declaration()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1176
                self.variable_declaration()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1177
                self.file_declaration()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1178
                self.alias_declaration()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 1179
                self.attribute_declaration()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 1180
                self.attribute_specification()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 1181
                self.disconnection_specification()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 1182
                self.step_limit_specification()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 1183
                self.use_clause()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 1184
                self.group_template_declaration()
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 1185
                self.group_declaration()
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 1186
                self.nature_declaration()
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 1187
                self.subnature_declaration()
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 1188
                self.quantity_declaration()
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 1189
                self.terminal_declaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Entity_declarative_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def entity_declarative_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Entity_declarative_itemContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Entity_declarative_itemContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_entity_declarative_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntity_declarative_part" ):
                listener.enterEntity_declarative_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntity_declarative_part" ):
                listener.exitEntity_declarative_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEntity_declarative_part" ):
                return visitor.visitEntity_declarative_part(self)
            else:
                return visitor.visitChildren(self)




    def entity_declarative_part(self):

        localctx = vhdlParser.Entity_declarative_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_entity_declarative_part)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1195
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & 2269549309200416) != 0 or (((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & 210571231245) != 0:
                self.state = 1192
                self.entity_declarative_item()
                self.state = 1197
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Entity_designatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def entity_tag(self):
            return self.getTypedRuleContext(vhdlParser.Entity_tagContext,0)


        def signature(self):
            return self.getTypedRuleContext(vhdlParser.SignatureContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_entity_designator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntity_designator" ):
                listener.enterEntity_designator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntity_designator" ):
                listener.exitEntity_designator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEntity_designator" ):
                return visitor.visitEntity_designator(self)
            else:
                return visitor.visitChildren(self)




    def entity_designator(self):

        localctx = vhdlParser.Entity_designatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_entity_designator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1198
            self.entity_tag()
            self.state = 1200
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==143:
                self.state = 1199
                self.signature()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Entity_headerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def generic_clause(self):
            return self.getTypedRuleContext(vhdlParser.Generic_clauseContext,0)


        def port_clause(self):
            return self.getTypedRuleContext(vhdlParser.Port_clauseContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_entity_header

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntity_header" ):
                listener.enterEntity_header(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntity_header" ):
                listener.exitEntity_header(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEntity_header" ):
                return visitor.visitEntity_header(self)
            else:
                return visitor.visitChildren(self)




    def entity_header(self):

        localctx = vhdlParser.Entity_headerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_entity_header)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1203
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 1202
                self.generic_clause()


            self.state = 1206
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==65:
                self.state = 1205
                self.port_clause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Entity_name_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def entity_designator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Entity_designatorContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Entity_designatorContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.COMMA)
            else:
                return self.getToken(vhdlParser.COMMA, i)

        def OTHERS(self):
            return self.getToken(vhdlParser.OTHERS, 0)

        def ALL(self):
            return self.getToken(vhdlParser.ALL, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_entity_name_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntity_name_list" ):
                listener.enterEntity_name_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntity_name_list" ):
                listener.exitEntity_name_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEntity_name_list" ):
                return visitor.visitEntity_name_list(self)
            else:
                return visitor.visitChildren(self)




    def entity_name_list(self):

        localctx = vhdlParser.Entity_name_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_entity_name_list)
        self._la = 0 # Token type
        try:
            self.state = 1218
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [118, 119, 126, 127]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1208
                self.entity_designator()
                self.state = 1213
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==139:
                    self.state = 1209
                    self.match(vhdlParser.COMMA)
                    self.state = 1210
                    self.entity_designator()
                    self.state = 1215
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [62]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1216
                self.match(vhdlParser.OTHERS)
                pass
            elif token in [6]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1217
                self.match(vhdlParser.ALL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Entity_specificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def entity_name_list(self):
            return self.getTypedRuleContext(vhdlParser.Entity_name_listContext,0)


        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def entity_class(self):
            return self.getTypedRuleContext(vhdlParser.Entity_classContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_entity_specification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntity_specification" ):
                listener.enterEntity_specification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntity_specification" ):
                listener.exitEntity_specification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEntity_specification" ):
                return visitor.visitEntity_specification(self)
            else:
                return visitor.visitChildren(self)




    def entity_specification(self):

        localctx = vhdlParser.Entity_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_entity_specification)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1220
            self.entity_name_list()
            self.state = 1221
            self.match(vhdlParser.COLON)
            self.state = 1222
            self.entity_class()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Entity_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def concurrent_assertion_statement(self):
            return self.getTypedRuleContext(vhdlParser.Concurrent_assertion_statementContext,0)


        def process_statement(self):
            return self.getTypedRuleContext(vhdlParser.Process_statementContext,0)


        def concurrent_procedure_call_statement(self):
            return self.getTypedRuleContext(vhdlParser.Concurrent_procedure_call_statementContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_entity_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntity_statement" ):
                listener.enterEntity_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntity_statement" ):
                listener.exitEntity_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEntity_statement" ):
                return visitor.visitEntity_statement(self)
            else:
                return visitor.visitChildren(self)




    def entity_statement(self):

        localctx = vhdlParser.Entity_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_entity_statement)
        try:
            self.state = 1227
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,108,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1224
                self.concurrent_assertion_statement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1225
                self.process_statement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1226
                self.concurrent_procedure_call_statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Entity_statement_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def entity_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Entity_statementContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Entity_statementContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_entity_statement_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntity_statement_part" ):
                listener.enterEntity_statement_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntity_statement_part" ):
                listener.exitEntity_statement_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEntity_statement_part" ):
                return visitor.visitEntity_statement_part(self)
            else:
                return visitor.visitChildren(self)




    def entity_statement_part(self):

        localctx = vhdlParser.Entity_statement_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_entity_statement_part)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1232
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==10 or (((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & 13510798882111491) != 0:
                self.state = 1229
                self.entity_statement()
                self.state = 1234
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Entity_tagContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def CHARACTER_LITERAL(self):
            return self.getToken(vhdlParser.CHARACTER_LITERAL, 0)

        def STRING_LITERAL(self):
            return self.getToken(vhdlParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_entity_tag

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntity_tag" ):
                listener.enterEntity_tag(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntity_tag" ):
                listener.exitEntity_tag(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEntity_tag" ):
                return visitor.visitEntity_tag(self)
            else:
                return visitor.visitChildren(self)




    def entity_tag(self):

        localctx = vhdlParser.Entity_tagContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_entity_tag)
        try:
            self.state = 1238
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [118, 119]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1235
                self.identifier()
                pass
            elif token in [126]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1236
                self.match(vhdlParser.CHARACTER_LITERAL)
                pass
            elif token in [127]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1237
                self.match(vhdlParser.STRING_LITERAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Enumeration_literalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def CHARACTER_LITERAL(self):
            return self.getToken(vhdlParser.CHARACTER_LITERAL, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_enumeration_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumeration_literal" ):
                listener.enterEnumeration_literal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumeration_literal" ):
                listener.exitEnumeration_literal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumeration_literal" ):
                return visitor.visitEnumeration_literal(self)
            else:
                return visitor.visitChildren(self)




    def enumeration_literal(self):

        localctx = vhdlParser.Enumeration_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_enumeration_literal)
        try:
            self.state = 1242
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [118, 119]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1240
                self.identifier()
                pass
            elif token in [126]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1241
                self.match(vhdlParser.CHARACTER_LITERAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Enumeration_type_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def enumeration_literal(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Enumeration_literalContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Enumeration_literalContext,i)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.COMMA)
            else:
                return self.getToken(vhdlParser.COMMA, i)

        def getRuleIndex(self):
            return vhdlParser.RULE_enumeration_type_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumeration_type_definition" ):
                listener.enterEnumeration_type_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumeration_type_definition" ):
                listener.exitEnumeration_type_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumeration_type_definition" ):
                return visitor.visitEnumeration_type_definition(self)
            else:
                return visitor.visitChildren(self)




    def enumeration_type_definition(self):

        localctx = vhdlParser.Enumeration_type_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_enumeration_type_definition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1244
            self.match(vhdlParser.LPAREN)
            self.state = 1245
            self.enumeration_literal()
            self.state = 1250
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==139:
                self.state = 1246
                self.match(vhdlParser.COMMA)
                self.state = 1247
                self.enumeration_literal()
                self.state = 1252
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1253
            self.match(vhdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Exit_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXIT(self):
            return self.getToken(vhdlParser.EXIT, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def WHEN(self):
            return self.getToken(vhdlParser.WHEN, 0)

        def condition(self):
            return self.getTypedRuleContext(vhdlParser.ConditionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_exit_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExit_statement" ):
                listener.enterExit_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExit_statement" ):
                listener.exitExit_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExit_statement" ):
                return visitor.visitExit_statement(self)
            else:
                return visitor.visitChildren(self)




    def exit_statement(self):

        localctx = vhdlParser.Exit_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_exit_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1256
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 1255
                self.label_colon()


            self.state = 1258
            self.match(vhdlParser.EXIT)
            self.state = 1260
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 1259
                self.identifier()


            self.state = 1264
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==108:
                self.state = 1262
                self.match(vhdlParser.WHEN)
                self.state = 1263
                self.condition()


            self.state = 1266
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def relation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.RelationContext)
            else:
                return self.getTypedRuleContext(vhdlParser.RelationContext,i)


        def logical_operator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Logical_operatorContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Logical_operatorContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = vhdlParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1268
            self.relation()
            self.state = 1274
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,116,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1269
                    self.logical_operator()
                    self.state = 1270
                    self.relation() 
                self.state = 1276
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,116,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FactorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primary(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.PrimaryContext)
            else:
                return self.getTypedRuleContext(vhdlParser.PrimaryContext,i)


        def DOUBLESTAR(self):
            return self.getToken(vhdlParser.DOUBLESTAR, 0)

        def ABS(self):
            return self.getToken(vhdlParser.ABS, 0)

        def NOT(self):
            return self.getToken(vhdlParser.NOT, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_factor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactor" ):
                listener.enterFactor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactor" ):
                listener.exitFactor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactor" ):
                return visitor.visitFactor(self)
            else:
                return visitor.visitChildren(self)




    def factor(self):

        localctx = vhdlParser.FactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_factor)
        try:
            self.state = 1286
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [52, 57, 112, 113, 117, 118, 119, 126, 127, 141, 158]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1277
                self.primary()
                self.state = 1280
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,117,self._ctx)
                if la_ == 1:
                    self.state = 1278
                    self.match(vhdlParser.DOUBLESTAR)
                    self.state = 1279
                    self.primary()


                pass
            elif token in [1]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1282
                self.match(vhdlParser.ABS)
                self.state = 1283
                self.primary()
                pass
            elif token in [56]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1284
                self.match(vhdlParser.NOT)
                self.state = 1285
                self.primary()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class File_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FILE(self):
            return self.getToken(vhdlParser.FILE, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(vhdlParser.Identifier_listContext,0)


        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def file_open_information(self):
            return self.getTypedRuleContext(vhdlParser.File_open_informationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_file_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFile_declaration" ):
                listener.enterFile_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFile_declaration" ):
                listener.exitFile_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFile_declaration" ):
                return visitor.visitFile_declaration(self)
            else:
                return visitor.visitChildren(self)




    def file_declaration(self):

        localctx = vhdlParser.File_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_file_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1288
            self.match(vhdlParser.FILE)
            self.state = 1289
            self.identifier_list()
            self.state = 1290
            self.match(vhdlParser.COLON)
            self.state = 1291
            self.subtype_indication()
            self.state = 1293
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41 or _la==60:
                self.state = 1292
                self.file_open_information()


            self.state = 1295
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class File_logical_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_file_logical_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFile_logical_name" ):
                listener.enterFile_logical_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFile_logical_name" ):
                listener.exitFile_logical_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFile_logical_name" ):
                return visitor.visitFile_logical_name(self)
            else:
                return visitor.visitChildren(self)




    def file_logical_name(self):

        localctx = vhdlParser.File_logical_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_file_logical_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1297
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class File_open_informationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IS(self):
            return self.getToken(vhdlParser.IS, 0)

        def file_logical_name(self):
            return self.getTypedRuleContext(vhdlParser.File_logical_nameContext,0)


        def OPEN(self):
            return self.getToken(vhdlParser.OPEN, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_file_open_information

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFile_open_information" ):
                listener.enterFile_open_information(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFile_open_information" ):
                listener.exitFile_open_information(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFile_open_information" ):
                return visitor.visitFile_open_information(self)
            else:
                return visitor.visitChildren(self)




    def file_open_information(self):

        localctx = vhdlParser.File_open_informationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_file_open_information)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1301
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==60:
                self.state = 1299
                self.match(vhdlParser.OPEN)
                self.state = 1300
                self.expression()


            self.state = 1303
            self.match(vhdlParser.IS)
            self.state = 1304
            self.file_logical_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class File_type_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FILE(self):
            return self.getToken(vhdlParser.FILE, 0)

        def OF(self):
            return self.getToken(vhdlParser.OF, 0)

        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_file_type_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFile_type_definition" ):
                listener.enterFile_type_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFile_type_definition" ):
                listener.exitFile_type_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFile_type_definition" ):
                return visitor.visitFile_type_definition(self)
            else:
                return visitor.visitChildren(self)




    def file_type_definition(self):

        localctx = vhdlParser.File_type_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_file_type_definition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1306
            self.match(vhdlParser.FILE)
            self.state = 1307
            self.match(vhdlParser.OF)
            self.state = 1308
            self.subtype_indication()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Formal_parameter_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def interface_list(self):
            return self.getTypedRuleContext(vhdlParser.Interface_listContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_formal_parameter_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormal_parameter_list" ):
                listener.enterFormal_parameter_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormal_parameter_list" ):
                listener.exitFormal_parameter_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormal_parameter_list" ):
                return visitor.visitFormal_parameter_list(self)
            else:
                return visitor.visitChildren(self)




    def formal_parameter_list(self):

        localctx = vhdlParser.Formal_parameter_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_formal_parameter_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1310
            self.interface_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Formal_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def explicit_range(self):
            return self.getTypedRuleContext(vhdlParser.Explicit_rangeContext,0)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_formal_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormal_part" ):
                listener.enterFormal_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormal_part" ):
                listener.exitFormal_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormal_part" ):
                return visitor.visitFormal_part(self)
            else:
                return visitor.visitChildren(self)




    def formal_part(self):

        localctx = vhdlParser.Formal_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_formal_part)
        try:
            self.state = 1318
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,121,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1312
                self.identifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1313
                self.identifier()
                self.state = 1314
                self.match(vhdlParser.LPAREN)
                self.state = 1315
                self.explicit_range()
                self.state = 1316
                self.match(vhdlParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Free_quantity_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUANTITY(self):
            return self.getToken(vhdlParser.QUANTITY, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(vhdlParser.Identifier_listContext,0)


        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def VARASGN(self):
            return self.getToken(vhdlParser.VARASGN, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_free_quantity_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFree_quantity_declaration" ):
                listener.enterFree_quantity_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFree_quantity_declaration" ):
                listener.exitFree_quantity_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFree_quantity_declaration" ):
                return visitor.visitFree_quantity_declaration(self)
            else:
                return visitor.visitChildren(self)




    def free_quantity_declaration(self):

        localctx = vhdlParser.Free_quantity_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_free_quantity_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1320
            self.match(vhdlParser.QUANTITY)
            self.state = 1321
            self.identifier_list()
            self.state = 1322
            self.match(vhdlParser.COLON)
            self.state = 1323
            self.subtype_indication()
            self.state = 1326
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==135:
                self.state = 1324
                self.match(vhdlParser.VARASGN)
                self.state = 1325
                self.expression()


            self.state = 1328
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Generate_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def generation_scheme(self):
            return self.getTypedRuleContext(vhdlParser.Generation_schemeContext,0)


        def GENERATE(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.GENERATE)
            else:
                return self.getToken(vhdlParser.GENERATE, i)

        def END(self):
            return self.getToken(vhdlParser.END, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def BEGIN(self):
            return self.getToken(vhdlParser.BEGIN, 0)

        def architecture_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Architecture_statementContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Architecture_statementContext,i)


        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def block_declarative_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Block_declarative_itemContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Block_declarative_itemContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_generate_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenerate_statement" ):
                listener.enterGenerate_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenerate_statement" ):
                listener.exitGenerate_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenerate_statement" ):
                return visitor.visitGenerate_statement(self)
            else:
                return visitor.visitChildren(self)




    def generate_statement(self):

        localctx = vhdlParser.Generate_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_generate_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1330
            self.label_colon()
            self.state = 1331
            self.generation_scheme()
            self.state = 1332
            self.match(vhdlParser.GENERATE)
            self.state = 1340
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((_la) & ~0x3f) == 0 and ((1 << _la) & 2269550383470624) != 0 or (((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & 210571231245) != 0:
                self.state = 1336
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((_la) & ~0x3f) == 0 and ((1 << _la) & 2269550383466528) != 0 or (((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & 210571231245) != 0:
                    self.state = 1333
                    self.block_declarative_item()
                    self.state = 1338
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1339
                self.match(vhdlParser.BEGIN)


            self.state = 1345
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & 220676450460926978) != 0 or (((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & 3474740417772126219) != 0 or (((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & 131457) != 0:
                self.state = 1342
                self.architecture_statement()
                self.state = 1347
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1348
            self.match(vhdlParser.END)
            self.state = 1349
            self.match(vhdlParser.GENERATE)
            self.state = 1351
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 1350
                self.identifier()


            self.state = 1353
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Generation_schemeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(vhdlParser.FOR, 0)

        def parameter_specification(self):
            return self.getTypedRuleContext(vhdlParser.Parameter_specificationContext,0)


        def IF(self):
            return self.getToken(vhdlParser.IF, 0)

        def condition(self):
            return self.getTypedRuleContext(vhdlParser.ConditionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_generation_scheme

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneration_scheme" ):
                listener.enterGeneration_scheme(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneration_scheme" ):
                listener.exitGeneration_scheme(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGeneration_scheme" ):
                return visitor.visitGeneration_scheme(self)
            else:
                return visitor.visitChildren(self)




    def generation_scheme(self):

        localctx = vhdlParser.Generation_schemeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_generation_scheme)
        try:
            self.state = 1359
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [30]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1355
                self.match(vhdlParser.FOR)
                self.state = 1356
                self.parameter_specification()
                pass
            elif token in [36]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1357
                self.match(vhdlParser.IF)
                self.state = 1358
                self.condition()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Generic_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GENERIC(self):
            return self.getToken(vhdlParser.GENERIC, 0)

        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def generic_list(self):
            return self.getTypedRuleContext(vhdlParser.Generic_listContext,0)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_generic_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneric_clause" ):
                listener.enterGeneric_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneric_clause" ):
                listener.exitGeneric_clause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGeneric_clause" ):
                return visitor.visitGeneric_clause(self)
            else:
                return visitor.visitChildren(self)




    def generic_clause(self):

        localctx = vhdlParser.Generic_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_generic_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1361
            self.match(vhdlParser.GENERIC)
            self.state = 1362
            self.match(vhdlParser.LPAREN)
            self.state = 1363
            self.generic_list()
            self.state = 1364
            self.match(vhdlParser.RPAREN)
            self.state = 1365
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Generic_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def interface_constant_declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Interface_constant_declarationContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Interface_constant_declarationContext,i)


        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.SEMI)
            else:
                return self.getToken(vhdlParser.SEMI, i)

        def getRuleIndex(self):
            return vhdlParser.RULE_generic_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneric_list" ):
                listener.enterGeneric_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneric_list" ):
                listener.exitGeneric_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGeneric_list" ):
                return visitor.visitGeneric_list(self)
            else:
                return visitor.visitChildren(self)




    def generic_list(self):

        localctx = vhdlParser.Generic_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_generic_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1367
            self.interface_constant_declaration()
            self.state = 1372
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==138:
                self.state = 1368
                self.match(vhdlParser.SEMI)
                self.state = 1369
                self.interface_constant_declaration()
                self.state = 1374
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Generic_map_aspectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GENERIC(self):
            return self.getToken(vhdlParser.GENERIC, 0)

        def MAP(self):
            return self.getToken(vhdlParser.MAP, 0)

        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def association_list(self):
            return self.getTypedRuleContext(vhdlParser.Association_listContext,0)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_generic_map_aspect

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneric_map_aspect" ):
                listener.enterGeneric_map_aspect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneric_map_aspect" ):
                listener.exitGeneric_map_aspect(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGeneric_map_aspect" ):
                return visitor.visitGeneric_map_aspect(self)
            else:
                return visitor.visitChildren(self)




    def generic_map_aspect(self):

        localctx = vhdlParser.Generic_map_aspectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_generic_map_aspect)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1375
            self.match(vhdlParser.GENERIC)
            self.state = 1376
            self.match(vhdlParser.MAP)
            self.state = 1377
            self.match(vhdlParser.LPAREN)
            self.state = 1378
            self.association_list()
            self.state = 1379
            self.match(vhdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Group_constituentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(vhdlParser.NameContext,0)


        def CHARACTER_LITERAL(self):
            return self.getToken(vhdlParser.CHARACTER_LITERAL, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_group_constituent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroup_constituent" ):
                listener.enterGroup_constituent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroup_constituent" ):
                listener.exitGroup_constituent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroup_constituent" ):
                return visitor.visitGroup_constituent(self)
            else:
                return visitor.visitChildren(self)




    def group_constituent(self):

        localctx = vhdlParser.Group_constituentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_group_constituent)
        try:
            self.state = 1383
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [118, 119, 127]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1381
                self.name()
                pass
            elif token in [126]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1382
                self.match(vhdlParser.CHARACTER_LITERAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Group_constituent_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def group_constituent(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Group_constituentContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Group_constituentContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.COMMA)
            else:
                return self.getToken(vhdlParser.COMMA, i)

        def getRuleIndex(self):
            return vhdlParser.RULE_group_constituent_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroup_constituent_list" ):
                listener.enterGroup_constituent_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroup_constituent_list" ):
                listener.exitGroup_constituent_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroup_constituent_list" ):
                return visitor.visitGroup_constituent_list(self)
            else:
                return visitor.visitChildren(self)




    def group_constituent_list(self):

        localctx = vhdlParser.Group_constituent_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_group_constituent_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1385
            self.group_constituent()
            self.state = 1390
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==139:
                self.state = 1386
                self.match(vhdlParser.COMMA)
                self.state = 1387
                self.group_constituent()
                self.state = 1392
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Group_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GROUP(self):
            return self.getToken(vhdlParser.GROUP, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def name(self):
            return self.getTypedRuleContext(vhdlParser.NameContext,0)


        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def group_constituent_list(self):
            return self.getTypedRuleContext(vhdlParser.Group_constituent_listContext,0)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_group_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroup_declaration" ):
                listener.enterGroup_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroup_declaration" ):
                listener.exitGroup_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroup_declaration" ):
                return visitor.visitGroup_declaration(self)
            else:
                return visitor.visitChildren(self)




    def group_declaration(self):

        localctx = vhdlParser.Group_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_group_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1393
            self.match(vhdlParser.GROUP)
            self.state = 1394
            self.label_colon()
            self.state = 1395
            self.name()
            self.state = 1396
            self.match(vhdlParser.LPAREN)
            self.state = 1397
            self.group_constituent_list()
            self.state = 1398
            self.match(vhdlParser.RPAREN)
            self.state = 1399
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Group_template_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GROUP(self):
            return self.getToken(vhdlParser.GROUP, 0)

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def IS(self):
            return self.getToken(vhdlParser.IS, 0)

        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def entity_class_entry_list(self):
            return self.getTypedRuleContext(vhdlParser.Entity_class_entry_listContext,0)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_group_template_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroup_template_declaration" ):
                listener.enterGroup_template_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroup_template_declaration" ):
                listener.exitGroup_template_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroup_template_declaration" ):
                return visitor.visitGroup_template_declaration(self)
            else:
                return visitor.visitChildren(self)




    def group_template_declaration(self):

        localctx = vhdlParser.Group_template_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_group_template_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1401
            self.match(vhdlParser.GROUP)
            self.state = 1402
            self.identifier()
            self.state = 1403
            self.match(vhdlParser.IS)
            self.state = 1404
            self.match(vhdlParser.LPAREN)
            self.state = 1405
            self.entity_class_entry_list()
            self.state = 1406
            self.match(vhdlParser.RPAREN)
            self.state = 1407
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Guarded_signal_specificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def signal_list(self):
            return self.getTypedRuleContext(vhdlParser.Signal_listContext,0)


        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def name(self):
            return self.getTypedRuleContext(vhdlParser.NameContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_guarded_signal_specification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGuarded_signal_specification" ):
                listener.enterGuarded_signal_specification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGuarded_signal_specification" ):
                listener.exitGuarded_signal_specification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGuarded_signal_specification" ):
                return visitor.visitGuarded_signal_specification(self)
            else:
                return visitor.visitChildren(self)




    def guarded_signal_specification(self):

        localctx = vhdlParser.Guarded_signal_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_guarded_signal_specification)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1409
            self.signal_list()
            self.state = 1410
            self.match(vhdlParser.COLON)
            self.state = 1411
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BASIC_IDENTIFIER(self):
            return self.getToken(vhdlParser.BASIC_IDENTIFIER, 0)

        def EXTENDED_IDENTIFIER(self):
            return self.getToken(vhdlParser.EXTENDED_IDENTIFIER, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifier" ):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = vhdlParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_identifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1413
            _la = self._input.LA(1)
            if not(_la==118 or _la==119):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Identifier_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(vhdlParser.IdentifierContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.COMMA)
            else:
                return self.getToken(vhdlParser.COMMA, i)

        def getRuleIndex(self):
            return vhdlParser.RULE_identifier_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier_list" ):
                listener.enterIdentifier_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier_list" ):
                listener.exitIdentifier_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifier_list" ):
                return visitor.visitIdentifier_list(self)
            else:
                return visitor.visitChildren(self)




    def identifier_list(self):

        localctx = vhdlParser.Identifier_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_identifier_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1415
            self.identifier()
            self.state = 1420
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==139:
                self.state = 1416
                self.match(vhdlParser.COMMA)
                self.state = 1417
                self.identifier()
                self.state = 1422
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class If_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.IF)
            else:
                return self.getToken(vhdlParser.IF, i)

        def condition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.ConditionContext)
            else:
                return self.getTypedRuleContext(vhdlParser.ConditionContext,i)


        def THEN(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.THEN)
            else:
                return self.getToken(vhdlParser.THEN, i)

        def sequence_of_statements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Sequence_of_statementsContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Sequence_of_statementsContext,i)


        def END(self):
            return self.getToken(vhdlParser.END, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def ELSIF(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.ELSIF)
            else:
                return self.getToken(vhdlParser.ELSIF, i)

        def ELSE(self):
            return self.getToken(vhdlParser.ELSE, 0)

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_if_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIf_statement" ):
                listener.enterIf_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIf_statement" ):
                listener.exitIf_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIf_statement" ):
                return visitor.visitIf_statement(self)
            else:
                return visitor.visitChildren(self)




    def if_statement(self):

        localctx = vhdlParser.If_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_if_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1424
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 1423
                self.label_colon()


            self.state = 1426
            self.match(vhdlParser.IF)
            self.state = 1427
            self.condition()
            self.state = 1428
            self.match(vhdlParser.THEN)
            self.state = 1429
            self.sequence_of_statements()
            self.state = 1437
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==27:
                self.state = 1430
                self.match(vhdlParser.ELSIF)
                self.state = 1431
                self.condition()
                self.state = 1432
                self.match(vhdlParser.THEN)
                self.state = 1433
                self.sequence_of_statements()
                self.state = 1439
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1442
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==26:
                self.state = 1440
                self.match(vhdlParser.ELSE)
                self.state = 1441
                self.sequence_of_statements()


            self.state = 1444
            self.match(vhdlParser.END)
            self.state = 1445
            self.match(vhdlParser.IF)
            self.state = 1447
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 1446
                self.identifier()


            self.state = 1449
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Index_constraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def discrete_range(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Discrete_rangeContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Discrete_rangeContext,i)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.COMMA)
            else:
                return self.getToken(vhdlParser.COMMA, i)

        def getRuleIndex(self):
            return vhdlParser.RULE_index_constraint

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndex_constraint" ):
                listener.enterIndex_constraint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndex_constraint" ):
                listener.exitIndex_constraint(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndex_constraint" ):
                return visitor.visitIndex_constraint(self)
            else:
                return visitor.visitChildren(self)




    def index_constraint(self):

        localctx = vhdlParser.Index_constraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_index_constraint)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1451
            self.match(vhdlParser.LPAREN)
            self.state = 1452
            self.discrete_range()
            self.state = 1457
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==139:
                self.state = 1453
                self.match(vhdlParser.COMMA)
                self.state = 1454
                self.discrete_range()
                self.state = 1459
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1460
            self.match(vhdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Index_specificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def discrete_range(self):
            return self.getTypedRuleContext(vhdlParser.Discrete_rangeContext,0)


        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_index_specification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndex_specification" ):
                listener.enterIndex_specification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndex_specification" ):
                listener.exitIndex_specification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndex_specification" ):
                return visitor.visitIndex_specification(self)
            else:
                return visitor.visitChildren(self)




    def index_specification(self):

        localctx = vhdlParser.Index_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_index_specification)
        try:
            self.state = 1464
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,137,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1462
                self.discrete_range()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1463
                self.expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Index_subtype_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(vhdlParser.NameContext,0)


        def RANGE(self):
            return self.getToken(vhdlParser.RANGE, 0)

        def BOX(self):
            return self.getToken(vhdlParser.BOX, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_index_subtype_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndex_subtype_definition" ):
                listener.enterIndex_subtype_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndex_subtype_definition" ):
                listener.exitIndex_subtype_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndex_subtype_definition" ):
                return visitor.visitIndex_subtype_definition(self)
            else:
                return visitor.visitChildren(self)




    def index_subtype_definition(self):

        localctx = vhdlParser.Index_subtype_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_index_subtype_definition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1466
            self.name()
            self.state = 1467
            self.match(vhdlParser.RANGE)
            self.state = 1468
            self.match(vhdlParser.BOX)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Instantiated_unitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(vhdlParser.NameContext,0)


        def COMPONENT(self):
            return self.getToken(vhdlParser.COMPONENT, 0)

        def ENTITY(self):
            return self.getToken(vhdlParser.ENTITY, 0)

        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def CONFIGURATION(self):
            return self.getToken(vhdlParser.CONFIGURATION, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_instantiated_unit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstantiated_unit" ):
                listener.enterInstantiated_unit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstantiated_unit" ):
                listener.exitInstantiated_unit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInstantiated_unit" ):
                return visitor.visitInstantiated_unit(self)
            else:
                return visitor.visitChildren(self)




    def instantiated_unit(self):

        localctx = vhdlParser.Instantiated_unitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_instantiated_unit)
        self._la = 0 # Token type
        try:
            self.state = 1484
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [19, 118, 119, 127]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1471
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==19:
                    self.state = 1470
                    self.match(vhdlParser.COMPONENT)


                self.state = 1473
                self.name()
                pass
            elif token in [25]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1474
                self.match(vhdlParser.ENTITY)
                self.state = 1475
                self.name()
                self.state = 1480
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==141:
                    self.state = 1476
                    self.match(vhdlParser.LPAREN)
                    self.state = 1477
                    self.identifier()
                    self.state = 1478
                    self.match(vhdlParser.RPAREN)


                pass
            elif token in [20]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1482
                self.match(vhdlParser.CONFIGURATION)
                self.state = 1483
                self.name()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Instantiation_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(vhdlParser.IdentifierContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.COMMA)
            else:
                return self.getToken(vhdlParser.COMMA, i)

        def OTHERS(self):
            return self.getToken(vhdlParser.OTHERS, 0)

        def ALL(self):
            return self.getToken(vhdlParser.ALL, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_instantiation_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstantiation_list" ):
                listener.enterInstantiation_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstantiation_list" ):
                listener.exitInstantiation_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInstantiation_list" ):
                return visitor.visitInstantiation_list(self)
            else:
                return visitor.visitChildren(self)




    def instantiation_list(self):

        localctx = vhdlParser.Instantiation_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 244, self.RULE_instantiation_list)
        self._la = 0 # Token type
        try:
            self.state = 1496
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [118, 119]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1486
                self.identifier()
                self.state = 1491
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==139:
                    self.state = 1487
                    self.match(vhdlParser.COMMA)
                    self.state = 1488
                    self.identifier()
                    self.state = 1493
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [62]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1494
                self.match(vhdlParser.OTHERS)
                pass
            elif token in [6]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1495
                self.match(vhdlParser.ALL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Interface_constant_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier_list(self):
            return self.getTypedRuleContext(vhdlParser.Identifier_listContext,0)


        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def CONSTANT(self):
            return self.getToken(vhdlParser.CONSTANT, 0)

        def IN(self):
            return self.getToken(vhdlParser.IN, 0)

        def VARASGN(self):
            return self.getToken(vhdlParser.VARASGN, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_interface_constant_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterface_constant_declaration" ):
                listener.enterInterface_constant_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterface_constant_declaration" ):
                listener.exitInterface_constant_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterface_constant_declaration" ):
                return visitor.visitInterface_constant_declaration(self)
            else:
                return visitor.visitChildren(self)




    def interface_constant_declaration(self):

        localctx = vhdlParser.Interface_constant_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_interface_constant_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1499
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==21:
                self.state = 1498
                self.match(vhdlParser.CONSTANT)


            self.state = 1501
            self.identifier_list()
            self.state = 1502
            self.match(vhdlParser.COLON)
            self.state = 1504
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==38:
                self.state = 1503
                self.match(vhdlParser.IN)


            self.state = 1506
            self.subtype_indication()
            self.state = 1509
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==135:
                self.state = 1507
                self.match(vhdlParser.VARASGN)
                self.state = 1508
                self.expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Interface_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def interface_constant_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Interface_constant_declarationContext,0)


        def interface_signal_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Interface_signal_declarationContext,0)


        def interface_variable_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Interface_variable_declarationContext,0)


        def interface_file_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Interface_file_declarationContext,0)


        def interface_terminal_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Interface_terminal_declarationContext,0)


        def interface_quantity_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Interface_quantity_declarationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_interface_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterface_declaration" ):
                listener.enterInterface_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterface_declaration" ):
                listener.exitInterface_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterface_declaration" ):
                return visitor.visitInterface_declaration(self)
            else:
                return visitor.visitChildren(self)




    def interface_declaration(self):

        localctx = vhdlParser.Interface_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_interface_declaration)
        try:
            self.state = 1517
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,146,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1511
                self.interface_constant_declaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1512
                self.interface_signal_declaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1513
                self.interface_variable_declaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1514
                self.interface_file_declaration()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1515
                self.interface_terminal_declaration()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1516
                self.interface_quantity_declaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Interface_elementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def interface_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Interface_declarationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_interface_element

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterface_element" ):
                listener.enterInterface_element(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterface_element" ):
                listener.exitInterface_element(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterface_element" ):
                return visitor.visitInterface_element(self)
            else:
                return visitor.visitChildren(self)




    def interface_element(self):

        localctx = vhdlParser.Interface_elementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 250, self.RULE_interface_element)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1519
            self.interface_declaration()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Interface_file_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FILE(self):
            return self.getToken(vhdlParser.FILE, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(vhdlParser.Identifier_listContext,0)


        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_interface_file_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterface_file_declaration" ):
                listener.enterInterface_file_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterface_file_declaration" ):
                listener.exitInterface_file_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterface_file_declaration" ):
                return visitor.visitInterface_file_declaration(self)
            else:
                return visitor.visitChildren(self)




    def interface_file_declaration(self):

        localctx = vhdlParser.Interface_file_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 252, self.RULE_interface_file_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1521
            self.match(vhdlParser.FILE)
            self.state = 1522
            self.identifier_list()
            self.state = 1523
            self.match(vhdlParser.COLON)
            self.state = 1524
            self.subtype_indication()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Interface_signal_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def interface_signal_declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Interface_signal_declarationContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Interface_signal_declarationContext,i)


        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.SEMI)
            else:
                return self.getToken(vhdlParser.SEMI, i)

        def getRuleIndex(self):
            return vhdlParser.RULE_interface_signal_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterface_signal_list" ):
                listener.enterInterface_signal_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterface_signal_list" ):
                listener.exitInterface_signal_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterface_signal_list" ):
                return visitor.visitInterface_signal_list(self)
            else:
                return visitor.visitChildren(self)




    def interface_signal_list(self):

        localctx = vhdlParser.Interface_signal_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 254, self.RULE_interface_signal_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1526
            self.interface_signal_declaration()
            self.state = 1531
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==138:
                self.state = 1527
                self.match(vhdlParser.SEMI)
                self.state = 1528
                self.interface_signal_declaration()
                self.state = 1533
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Interface_port_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def interface_port_declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Interface_port_declarationContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Interface_port_declarationContext,i)


        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.SEMI)
            else:
                return self.getToken(vhdlParser.SEMI, i)

        def getRuleIndex(self):
            return vhdlParser.RULE_interface_port_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterface_port_list" ):
                listener.enterInterface_port_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterface_port_list" ):
                listener.exitInterface_port_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterface_port_list" ):
                return visitor.visitInterface_port_list(self)
            else:
                return visitor.visitChildren(self)




    def interface_port_list(self):

        localctx = vhdlParser.Interface_port_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 256, self.RULE_interface_port_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1534
            self.interface_port_declaration()
            self.state = 1539
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==138:
                self.state = 1535
                self.match(vhdlParser.SEMI)
                self.state = 1536
                self.interface_port_declaration()
                self.state = 1541
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Interface_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def interface_element(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Interface_elementContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Interface_elementContext,i)


        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.SEMI)
            else:
                return self.getToken(vhdlParser.SEMI, i)

        def getRuleIndex(self):
            return vhdlParser.RULE_interface_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterface_list" ):
                listener.enterInterface_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterface_list" ):
                listener.exitInterface_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterface_list" ):
                return visitor.visitInterface_list(self)
            else:
                return visitor.visitChildren(self)




    def interface_list(self):

        localctx = vhdlParser.Interface_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 258, self.RULE_interface_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1542
            self.interface_element()
            self.state = 1547
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==138:
                self.state = 1543
                self.match(vhdlParser.SEMI)
                self.state = 1544
                self.interface_element()
                self.state = 1549
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Interface_quantity_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUANTITY(self):
            return self.getToken(vhdlParser.QUANTITY, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(vhdlParser.Identifier_listContext,0)


        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def VARASGN(self):
            return self.getToken(vhdlParser.VARASGN, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def IN(self):
            return self.getToken(vhdlParser.IN, 0)

        def OUT(self):
            return self.getToken(vhdlParser.OUT, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_interface_quantity_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterface_quantity_declaration" ):
                listener.enterInterface_quantity_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterface_quantity_declaration" ):
                listener.exitInterface_quantity_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterface_quantity_declaration" ):
                return visitor.visitInterface_quantity_declaration(self)
            else:
                return visitor.visitChildren(self)




    def interface_quantity_declaration(self):

        localctx = vhdlParser.Interface_quantity_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 260, self.RULE_interface_quantity_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1550
            self.match(vhdlParser.QUANTITY)
            self.state = 1551
            self.identifier_list()
            self.state = 1552
            self.match(vhdlParser.COLON)
            self.state = 1554
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==38 or _la==63:
                self.state = 1553
                _la = self._input.LA(1)
                if not(_la==38 or _la==63):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1556
            self.subtype_indication()
            self.state = 1559
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==135:
                self.state = 1557
                self.match(vhdlParser.VARASGN)
                self.state = 1558
                self.expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Interface_port_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier_list(self):
            return self.getTypedRuleContext(vhdlParser.Identifier_listContext,0)


        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def signal_mode(self):
            return self.getTypedRuleContext(vhdlParser.Signal_modeContext,0)


        def BUS(self):
            return self.getToken(vhdlParser.BUS, 0)

        def VARASGN(self):
            return self.getToken(vhdlParser.VARASGN, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_interface_port_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterface_port_declaration" ):
                listener.enterInterface_port_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterface_port_declaration" ):
                listener.exitInterface_port_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterface_port_declaration" ):
                return visitor.visitInterface_port_declaration(self)
            else:
                return visitor.visitChildren(self)




    def interface_port_declaration(self):

        localctx = vhdlParser.Interface_port_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 262, self.RULE_interface_port_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1561
            self.identifier_list()
            self.state = 1562
            self.match(vhdlParser.COLON)
            self.state = 1564
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((_la) & ~0x3f) == 0 and ((1 << _la) & -9223335478093086720) != 0:
                self.state = 1563
                self.signal_mode()


            self.state = 1566
            self.subtype_indication()
            self.state = 1568
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==17:
                self.state = 1567
                self.match(vhdlParser.BUS)


            self.state = 1572
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==135:
                self.state = 1570
                self.match(vhdlParser.VARASGN)
                self.state = 1571
                self.expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Interface_signal_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNAL(self):
            return self.getToken(vhdlParser.SIGNAL, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(vhdlParser.Identifier_listContext,0)


        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def signal_mode(self):
            return self.getTypedRuleContext(vhdlParser.Signal_modeContext,0)


        def BUS(self):
            return self.getToken(vhdlParser.BUS, 0)

        def VARASGN(self):
            return self.getToken(vhdlParser.VARASGN, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_interface_signal_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterface_signal_declaration" ):
                listener.enterInterface_signal_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterface_signal_declaration" ):
                listener.exitInterface_signal_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterface_signal_declaration" ):
                return visitor.visitInterface_signal_declaration(self)
            else:
                return visitor.visitChildren(self)




    def interface_signal_declaration(self):

        localctx = vhdlParser.Interface_signal_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 264, self.RULE_interface_signal_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1574
            self.match(vhdlParser.SIGNAL)
            self.state = 1575
            self.identifier_list()
            self.state = 1576
            self.match(vhdlParser.COLON)
            self.state = 1578
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((_la) & ~0x3f) == 0 and ((1 << _la) & -9223335478093086720) != 0:
                self.state = 1577
                self.signal_mode()


            self.state = 1580
            self.subtype_indication()
            self.state = 1582
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==17:
                self.state = 1581
                self.match(vhdlParser.BUS)


            self.state = 1586
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==135:
                self.state = 1584
                self.match(vhdlParser.VARASGN)
                self.state = 1585
                self.expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Interface_terminal_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TERMINAL(self):
            return self.getToken(vhdlParser.TERMINAL, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(vhdlParser.Identifier_listContext,0)


        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def subnature_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subnature_indicationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_interface_terminal_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterface_terminal_declaration" ):
                listener.enterInterface_terminal_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterface_terminal_declaration" ):
                listener.exitInterface_terminal_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterface_terminal_declaration" ):
                return visitor.visitInterface_terminal_declaration(self)
            else:
                return visitor.visitChildren(self)




    def interface_terminal_declaration(self):

        localctx = vhdlParser.Interface_terminal_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 266, self.RULE_interface_terminal_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1588
            self.match(vhdlParser.TERMINAL)
            self.state = 1589
            self.identifier_list()
            self.state = 1590
            self.match(vhdlParser.COLON)
            self.state = 1591
            self.subnature_indication()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Interface_variable_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier_list(self):
            return self.getTypedRuleContext(vhdlParser.Identifier_listContext,0)


        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def VARIABLE(self):
            return self.getToken(vhdlParser.VARIABLE, 0)

        def signal_mode(self):
            return self.getTypedRuleContext(vhdlParser.Signal_modeContext,0)


        def VARASGN(self):
            return self.getToken(vhdlParser.VARASGN, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_interface_variable_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterface_variable_declaration" ):
                listener.enterInterface_variable_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterface_variable_declaration" ):
                listener.exitInterface_variable_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterface_variable_declaration" ):
                return visitor.visitInterface_variable_declaration(self)
            else:
                return visitor.visitChildren(self)




    def interface_variable_declaration(self):

        localctx = vhdlParser.Interface_variable_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 268, self.RULE_interface_variable_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1594
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==105:
                self.state = 1593
                self.match(vhdlParser.VARIABLE)


            self.state = 1596
            self.identifier_list()
            self.state = 1597
            self.match(vhdlParser.COLON)
            self.state = 1599
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((_la) & ~0x3f) == 0 and ((1 << _la) & -9223335478093086720) != 0:
                self.state = 1598
                self.signal_mode()


            self.state = 1601
            self.subtype_indication()
            self.state = 1604
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==135:
                self.state = 1602
                self.match(vhdlParser.VARASGN)
                self.state = 1603
                self.expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Iteration_schemeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(vhdlParser.WHILE, 0)

        def condition(self):
            return self.getTypedRuleContext(vhdlParser.ConditionContext,0)


        def FOR(self):
            return self.getToken(vhdlParser.FOR, 0)

        def parameter_specification(self):
            return self.getTypedRuleContext(vhdlParser.Parameter_specificationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_iteration_scheme

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIteration_scheme" ):
                listener.enterIteration_scheme(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIteration_scheme" ):
                listener.exitIteration_scheme(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIteration_scheme" ):
                return visitor.visitIteration_scheme(self)
            else:
                return visitor.visitChildren(self)




    def iteration_scheme(self):

        localctx = vhdlParser.Iteration_schemeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 270, self.RULE_iteration_scheme)
        try:
            self.state = 1610
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [109]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1606
                self.match(vhdlParser.WHILE)
                self.state = 1607
                self.condition()
                pass
            elif token in [30]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1608
                self.match(vhdlParser.FOR)
                self.state = 1609
                self.parameter_specification()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Label_colonContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_label_colon

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabel_colon" ):
                listener.enterLabel_colon(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabel_colon" ):
                listener.exitLabel_colon(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabel_colon" ):
                return visitor.visitLabel_colon(self)
            else:
                return visitor.visitChildren(self)




    def label_colon(self):

        localctx = vhdlParser.Label_colonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 272, self.RULE_label_colon)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1612
            self.identifier()
            self.state = 1613
            self.match(vhdlParser.COLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Library_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIBRARY(self):
            return self.getToken(vhdlParser.LIBRARY, 0)

        def logical_name_list(self):
            return self.getTypedRuleContext(vhdlParser.Logical_name_listContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_library_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLibrary_clause" ):
                listener.enterLibrary_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLibrary_clause" ):
                listener.exitLibrary_clause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLibrary_clause" ):
                return visitor.visitLibrary_clause(self)
            else:
                return visitor.visitChildren(self)




    def library_clause(self):

        localctx = vhdlParser.Library_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 274, self.RULE_library_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1615
            self.match(vhdlParser.LIBRARY)
            self.state = 1616
            self.logical_name_list()
            self.state = 1617
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Library_unitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def secondary_unit(self):
            return self.getTypedRuleContext(vhdlParser.Secondary_unitContext,0)


        def primary_unit(self):
            return self.getTypedRuleContext(vhdlParser.Primary_unitContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_library_unit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLibrary_unit" ):
                listener.enterLibrary_unit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLibrary_unit" ):
                listener.exitLibrary_unit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLibrary_unit" ):
                return visitor.visitLibrary_unit(self)
            else:
                return visitor.visitChildren(self)




    def library_unit(self):

        localctx = vhdlParser.Library_unitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 276, self.RULE_library_unit)
        try:
            self.state = 1621
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,162,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1619
                self.secondary_unit()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1620
                self.primary_unit()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NULL_(self):
            return self.getToken(vhdlParser.NULL_, 0)

        def BIT_STRING_LITERAL(self):
            return self.getToken(vhdlParser.BIT_STRING_LITERAL, 0)

        def STRING_LITERAL(self):
            return self.getToken(vhdlParser.STRING_LITERAL, 0)

        def enumeration_literal(self):
            return self.getTypedRuleContext(vhdlParser.Enumeration_literalContext,0)


        def numeric_literal(self):
            return self.getTypedRuleContext(vhdlParser.Numeric_literalContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteral" ):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)




    def literal(self):

        localctx = vhdlParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 278, self.RULE_literal)
        try:
            self.state = 1628
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [57]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1623
                self.match(vhdlParser.NULL_)
                pass
            elif token in [113]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1624
                self.match(vhdlParser.BIT_STRING_LITERAL)
                pass
            elif token in [127]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1625
                self.match(vhdlParser.STRING_LITERAL)
                pass
            elif token in [118, 119, 126]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1626
                self.enumeration_literal()
                pass
            elif token in [112, 117, 158]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1627
                self.numeric_literal()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Logical_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_logical_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogical_name" ):
                listener.enterLogical_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogical_name" ):
                listener.exitLogical_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogical_name" ):
                return visitor.visitLogical_name(self)
            else:
                return visitor.visitChildren(self)




    def logical_name(self):

        localctx = vhdlParser.Logical_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 280, self.RULE_logical_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1630
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Logical_name_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logical_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Logical_nameContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Logical_nameContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.COMMA)
            else:
                return self.getToken(vhdlParser.COMMA, i)

        def getRuleIndex(self):
            return vhdlParser.RULE_logical_name_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogical_name_list" ):
                listener.enterLogical_name_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogical_name_list" ):
                listener.exitLogical_name_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogical_name_list" ):
                return visitor.visitLogical_name_list(self)
            else:
                return visitor.visitChildren(self)




    def logical_name_list(self):

        localctx = vhdlParser.Logical_name_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 282, self.RULE_logical_name_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1632
            self.logical_name()
            self.state = 1637
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==139:
                self.state = 1633
                self.match(vhdlParser.COMMA)
                self.state = 1634
                self.logical_name()
                self.state = 1639
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Logical_operatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AND(self):
            return self.getToken(vhdlParser.AND, 0)

        def OR(self):
            return self.getToken(vhdlParser.OR, 0)

        def NAND(self):
            return self.getToken(vhdlParser.NAND, 0)

        def NOR(self):
            return self.getToken(vhdlParser.NOR, 0)

        def XOR(self):
            return self.getToken(vhdlParser.XOR, 0)

        def XNOR(self):
            return self.getToken(vhdlParser.XNOR, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_logical_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogical_operator" ):
                listener.enterLogical_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogical_operator" ):
                listener.exitLogical_operator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogical_operator" ):
                return visitor.visitLogical_operator(self)
            else:
                return visitor.visitChildren(self)




    def logical_operator(self):

        localctx = vhdlParser.Logical_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 284, self.RULE_logical_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1640
            _la = self._input.LA(1)
            if not(((_la) & ~0x3f) == 0 and ((1 << _la) & 2342997706139500672) != 0 or _la==110 or _la==111):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Loop_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOOP(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.LOOP)
            else:
                return self.getToken(vhdlParser.LOOP, i)

        def sequence_of_statements(self):
            return self.getTypedRuleContext(vhdlParser.Sequence_of_statementsContext,0)


        def END(self):
            return self.getToken(vhdlParser.END, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def iteration_scheme(self):
            return self.getTypedRuleContext(vhdlParser.Iteration_schemeContext,0)


        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_loop_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoop_statement" ):
                listener.enterLoop_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoop_statement" ):
                listener.exitLoop_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoop_statement" ):
                return visitor.visitLoop_statement(self)
            else:
                return visitor.visitChildren(self)




    def loop_statement(self):

        localctx = vhdlParser.Loop_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 286, self.RULE_loop_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1643
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 1642
                self.label_colon()


            self.state = 1646
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==30 or _la==109:
                self.state = 1645
                self.iteration_scheme()


            self.state = 1648
            self.match(vhdlParser.LOOP)
            self.state = 1649
            self.sequence_of_statements()
            self.state = 1650
            self.match(vhdlParser.END)
            self.state = 1651
            self.match(vhdlParser.LOOP)
            self.state = 1653
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 1652
                self.identifier()


            self.state = 1655
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Signal_modeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IN(self):
            return self.getToken(vhdlParser.IN, 0)

        def OUT(self):
            return self.getToken(vhdlParser.OUT, 0)

        def INOUT(self):
            return self.getToken(vhdlParser.INOUT, 0)

        def BUFFER(self):
            return self.getToken(vhdlParser.BUFFER, 0)

        def LINKAGE(self):
            return self.getToken(vhdlParser.LINKAGE, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_signal_mode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSignal_mode" ):
                listener.enterSignal_mode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSignal_mode" ):
                listener.exitSignal_mode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSignal_mode" ):
                return visitor.visitSignal_mode(self)
            else:
                return visitor.visitChildren(self)




    def signal_mode(self):

        localctx = vhdlParser.Signal_modeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 288, self.RULE_signal_mode)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1657
            _la = self._input.LA(1)
            if not(((_la) & ~0x3f) == 0 and ((1 << _la) & -9223335478093086720) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Multiplying_operatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MUL(self):
            return self.getToken(vhdlParser.MUL, 0)

        def DIV(self):
            return self.getToken(vhdlParser.DIV, 0)

        def MOD(self):
            return self.getToken(vhdlParser.MOD, 0)

        def REM(self):
            return self.getToken(vhdlParser.REM, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_multiplying_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplying_operator" ):
                listener.enterMultiplying_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplying_operator" ):
                listener.exitMultiplying_operator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplying_operator" ):
                return visitor.visitMultiplying_operator(self)
            else:
                return visitor.visitChildren(self)




    def multiplying_operator(self):

        localctx = vhdlParser.Multiplying_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 290, self.RULE_multiplying_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1659
            _la = self._input.LA(1)
            if not(_la==49 or _la==75 or _la==146 or _la==147):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def STRING_LITERAL(self):
            return self.getToken(vhdlParser.STRING_LITERAL, 0)

        def name_part(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Name_partContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Name_partContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterName" ):
                listener.enterName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitName" ):
                listener.exitName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitName" ):
                return visitor.visitName(self)
            else:
                return visitor.visitChildren(self)




    def name(self):

        localctx = vhdlParser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 292, self.RULE_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1663
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [118, 119]:
                self.state = 1661
                self.identifier()
                pass
            elif token in [127]:
                self.state = 1662
                self.match(vhdlParser.STRING_LITERAL)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1668
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,169,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1665
                    self.name_part() 
                self.state = 1670
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,169,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Name_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def selected_name_part(self):
            return self.getTypedRuleContext(vhdlParser.Selected_name_partContext,0)


        def function_call_or_indexed_name_part(self):
            return self.getTypedRuleContext(vhdlParser.Function_call_or_indexed_name_partContext,0)


        def slice_name_part(self):
            return self.getTypedRuleContext(vhdlParser.Slice_name_partContext,0)


        def attribute_name_part(self):
            return self.getTypedRuleContext(vhdlParser.Attribute_name_partContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_name_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterName_part" ):
                listener.enterName_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitName_part" ):
                listener.exitName_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitName_part" ):
                return visitor.visitName_part(self)
            else:
                return visitor.visitChildren(self)




    def name_part(self):

        localctx = vhdlParser.Name_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 294, self.RULE_name_part)
        try:
            self.state = 1675
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,170,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1671
                self.selected_name_part()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1672
                self.function_call_or_indexed_name_part()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1673
                self.slice_name_part()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1674
                self.attribute_name_part()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Selected_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.DOT)
            else:
                return self.getToken(vhdlParser.DOT, i)

        def suffix(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.SuffixContext)
            else:
                return self.getTypedRuleContext(vhdlParser.SuffixContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_selected_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelected_name" ):
                listener.enterSelected_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelected_name" ):
                listener.exitSelected_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelected_name" ):
                return visitor.visitSelected_name(self)
            else:
                return visitor.visitChildren(self)




    def selected_name(self):

        localctx = vhdlParser.Selected_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 296, self.RULE_selected_name)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1677
            self.identifier()
            self.state = 1682
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==154:
                self.state = 1678
                self.match(vhdlParser.DOT)
                self.state = 1679
                self.suffix()
                self.state = 1684
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Selected_name_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.DOT)
            else:
                return self.getToken(vhdlParser.DOT, i)

        def suffix(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.SuffixContext)
            else:
                return self.getTypedRuleContext(vhdlParser.SuffixContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_selected_name_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelected_name_part" ):
                listener.enterSelected_name_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelected_name_part" ):
                listener.exitSelected_name_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelected_name_part" ):
                return visitor.visitSelected_name_part(self)
            else:
                return visitor.visitChildren(self)




    def selected_name_part(self):

        localctx = vhdlParser.Selected_name_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 298, self.RULE_selected_name_part)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1687 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1685
                    self.match(vhdlParser.DOT)
                    self.state = 1686
                    self.suffix()

                else:
                    raise NoViableAltException(self)
                self.state = 1689 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,172,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_call_or_indexed_name_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def actual_parameter_part(self):
            return self.getTypedRuleContext(vhdlParser.Actual_parameter_partContext,0)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_function_call_or_indexed_name_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_call_or_indexed_name_part" ):
                listener.enterFunction_call_or_indexed_name_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_call_or_indexed_name_part" ):
                listener.exitFunction_call_or_indexed_name_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunction_call_or_indexed_name_part" ):
                return visitor.visitFunction_call_or_indexed_name_part(self)
            else:
                return visitor.visitChildren(self)




    def function_call_or_indexed_name_part(self):

        localctx = vhdlParser.Function_call_or_indexed_name_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 300, self.RULE_function_call_or_indexed_name_part)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1691
            self.match(vhdlParser.LPAREN)
            self.state = 1692
            self.actual_parameter_part()
            self.state = 1693
            self.match(vhdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Slice_name_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def discrete_range(self):
            return self.getTypedRuleContext(vhdlParser.Discrete_rangeContext,0)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_slice_name_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSlice_name_part" ):
                listener.enterSlice_name_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSlice_name_part" ):
                listener.exitSlice_name_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSlice_name_part" ):
                return visitor.visitSlice_name_part(self)
            else:
                return visitor.visitChildren(self)




    def slice_name_part(self):

        localctx = vhdlParser.Slice_name_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 302, self.RULE_slice_name_part)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1695
            self.match(vhdlParser.LPAREN)
            self.state = 1696
            self.discrete_range()
            self.state = 1697
            self.match(vhdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Attribute_name_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def APOSTROPHE(self):
            return self.getToken(vhdlParser.APOSTROPHE, 0)

        def attribute_designator(self):
            return self.getTypedRuleContext(vhdlParser.Attribute_designatorContext,0)


        def signature(self):
            return self.getTypedRuleContext(vhdlParser.SignatureContext,0)


        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_attribute_name_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribute_name_part" ):
                listener.enterAttribute_name_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribute_name_part" ):
                listener.exitAttribute_name_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribute_name_part" ):
                return visitor.visitAttribute_name_part(self)
            else:
                return visitor.visitChildren(self)




    def attribute_name_part(self):

        localctx = vhdlParser.Attribute_name_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 304, self.RULE_attribute_name_part)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1700
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==143:
                self.state = 1699
                self.signature()


            self.state = 1702
            self.match(vhdlParser.APOSTROPHE)
            self.state = 1703
            self.attribute_designator()
            self.state = 1708
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,174,self._ctx)
            if la_ == 1:
                self.state = 1704
                self.match(vhdlParser.LPAREN)
                self.state = 1705
                self.expression()
                self.state = 1706
                self.match(vhdlParser.RPAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Nature_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NATURE(self):
            return self.getToken(vhdlParser.NATURE, 0)

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def IS(self):
            return self.getToken(vhdlParser.IS, 0)

        def nature_definition(self):
            return self.getTypedRuleContext(vhdlParser.Nature_definitionContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_nature_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNature_declaration" ):
                listener.enterNature_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNature_declaration" ):
                listener.exitNature_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNature_declaration" ):
                return visitor.visitNature_declaration(self)
            else:
                return visitor.visitChildren(self)




    def nature_declaration(self):

        localctx = vhdlParser.Nature_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 306, self.RULE_nature_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1710
            self.match(vhdlParser.NATURE)
            self.state = 1711
            self.identifier()
            self.state = 1712
            self.match(vhdlParser.IS)
            self.state = 1713
            self.nature_definition()
            self.state = 1714
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Nature_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def scalar_nature_definition(self):
            return self.getTypedRuleContext(vhdlParser.Scalar_nature_definitionContext,0)


        def composite_nature_definition(self):
            return self.getTypedRuleContext(vhdlParser.Composite_nature_definitionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_nature_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNature_definition" ):
                listener.enterNature_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNature_definition" ):
                listener.exitNature_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNature_definition" ):
                return visitor.visitNature_definition(self)
            else:
                return visitor.visitChildren(self)




    def nature_definition(self):

        localctx = vhdlParser.Nature_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 308, self.RULE_nature_definition)
        try:
            self.state = 1718
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [118, 119, 127]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1716
                self.scalar_nature_definition()
                pass
            elif token in [9, 76]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1717
                self.composite_nature_definition()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Nature_element_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier_list(self):
            return self.getTypedRuleContext(vhdlParser.Identifier_listContext,0)


        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def element_subnature_definition(self):
            return self.getTypedRuleContext(vhdlParser.Element_subnature_definitionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_nature_element_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNature_element_declaration" ):
                listener.enterNature_element_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNature_element_declaration" ):
                listener.exitNature_element_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNature_element_declaration" ):
                return visitor.visitNature_element_declaration(self)
            else:
                return visitor.visitChildren(self)




    def nature_element_declaration(self):

        localctx = vhdlParser.Nature_element_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 310, self.RULE_nature_element_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1720
            self.identifier_list()
            self.state = 1721
            self.match(vhdlParser.COLON)
            self.state = 1722
            self.element_subnature_definition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Next_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEXT(self):
            return self.getToken(vhdlParser.NEXT, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def WHEN(self):
            return self.getToken(vhdlParser.WHEN, 0)

        def condition(self):
            return self.getTypedRuleContext(vhdlParser.ConditionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_next_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNext_statement" ):
                listener.enterNext_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNext_statement" ):
                listener.exitNext_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNext_statement" ):
                return visitor.visitNext_statement(self)
            else:
                return visitor.visitChildren(self)




    def next_statement(self):

        localctx = vhdlParser.Next_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 312, self.RULE_next_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1725
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 1724
                self.label_colon()


            self.state = 1727
            self.match(vhdlParser.NEXT)
            self.state = 1729
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 1728
                self.identifier()


            self.state = 1733
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==108:
                self.state = 1731
                self.match(vhdlParser.WHEN)
                self.state = 1732
                self.condition()


            self.state = 1735
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_literalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def abstract_literal(self):
            return self.getTypedRuleContext(vhdlParser.Abstract_literalContext,0)


        def physical_literal(self):
            return self.getTypedRuleContext(vhdlParser.Physical_literalContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_numeric_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_literal" ):
                listener.enterNumeric_literal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_literal" ):
                listener.exitNumeric_literal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeric_literal" ):
                return visitor.visitNumeric_literal(self)
            else:
                return visitor.visitChildren(self)




    def numeric_literal(self):

        localctx = vhdlParser.Numeric_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 314, self.RULE_numeric_literal)
        try:
            self.state = 1739
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,179,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1737
                self.abstract_literal()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1738
                self.physical_literal()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Object_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Constant_declarationContext,0)


        def signal_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Signal_declarationContext,0)


        def variable_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Variable_declarationContext,0)


        def file_declaration(self):
            return self.getTypedRuleContext(vhdlParser.File_declarationContext,0)


        def terminal_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Terminal_declarationContext,0)


        def quantity_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Quantity_declarationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_object_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObject_declaration" ):
                listener.enterObject_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObject_declaration" ):
                listener.exitObject_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObject_declaration" ):
                return visitor.visitObject_declaration(self)
            else:
                return visitor.visitChildren(self)




    def object_declaration(self):

        localctx = vhdlParser.Object_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 316, self.RULE_object_declaration)
        try:
            self.state = 1747
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1741
                self.constant_declaration()
                pass
            elif token in [86]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1742
                self.signal_declaration()
                pass
            elif token in [85, 105]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1743
                self.variable_declaration()
                pass
            elif token in [29]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1744
                self.file_declaration()
                pass
            elif token in [94]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1745
                self.terminal_declaration()
                pass
            elif token in [71]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1746
                self.quantity_declaration()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GUARDED(self):
            return self.getToken(vhdlParser.GUARDED, 0)

        def delay_mechanism(self):
            return self.getTypedRuleContext(vhdlParser.Delay_mechanismContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_opts

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpts" ):
                listener.enterOpts(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpts" ):
                listener.exitOpts(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpts" ):
                return visitor.visitOpts(self)
            else:
                return visitor.visitChildren(self)




    def opts(self):

        localctx = vhdlParser.OptsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 318, self.RULE_opts)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1750
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==35:
                self.state = 1749
                self.match(vhdlParser.GUARDED)


            self.state = 1753
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la - 39)) & ~0x3f) == 0 and ((1 << (_la - 39)) & 1152921538966585345) != 0:
                self.state = 1752
                self.delay_mechanism()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Package_bodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PACKAGE(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.PACKAGE)
            else:
                return self.getToken(vhdlParser.PACKAGE, i)

        def BODY(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.BODY)
            else:
                return self.getToken(vhdlParser.BODY, i)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(vhdlParser.IdentifierContext,i)


        def IS(self):
            return self.getToken(vhdlParser.IS, 0)

        def package_body_declarative_part(self):
            return self.getTypedRuleContext(vhdlParser.Package_body_declarative_partContext,0)


        def END(self):
            return self.getToken(vhdlParser.END, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_package_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPackage_body" ):
                listener.enterPackage_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPackage_body" ):
                listener.exitPackage_body(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPackage_body" ):
                return visitor.visitPackage_body(self)
            else:
                return visitor.visitChildren(self)




    def package_body(self):

        localctx = vhdlParser.Package_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 320, self.RULE_package_body)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1755
            self.match(vhdlParser.PACKAGE)
            self.state = 1756
            self.match(vhdlParser.BODY)
            self.state = 1757
            self.identifier()
            self.state = 1758
            self.match(vhdlParser.IS)
            self.state = 1759
            self.package_body_declarative_part()
            self.state = 1760
            self.match(vhdlParser.END)
            self.state = 1763
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==64:
                self.state = 1761
                self.match(vhdlParser.PACKAGE)
                self.state = 1762
                self.match(vhdlParser.BODY)


            self.state = 1766
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 1765
                self.identifier()


            self.state = 1768
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Package_body_declarative_itemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subprogram_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Subprogram_declarationContext,0)


        def subprogram_body(self):
            return self.getTypedRuleContext(vhdlParser.Subprogram_bodyContext,0)


        def type_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Type_declarationContext,0)


        def subtype_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_declarationContext,0)


        def constant_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Constant_declarationContext,0)


        def variable_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Variable_declarationContext,0)


        def file_declaration(self):
            return self.getTypedRuleContext(vhdlParser.File_declarationContext,0)


        def alias_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Alias_declarationContext,0)


        def use_clause(self):
            return self.getTypedRuleContext(vhdlParser.Use_clauseContext,0)


        def group_template_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Group_template_declarationContext,0)


        def group_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Group_declarationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_package_body_declarative_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPackage_body_declarative_item" ):
                listener.enterPackage_body_declarative_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPackage_body_declarative_item" ):
                listener.exitPackage_body_declarative_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPackage_body_declarative_item" ):
                return visitor.visitPackage_body_declarative_item(self)
            else:
                return visitor.visitChildren(self)




    def package_body_declarative_item(self):

        localctx = vhdlParser.Package_body_declarative_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 322, self.RULE_package_body_declarative_item)
        try:
            self.state = 1781
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,185,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1770
                self.subprogram_declaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1771
                self.subprogram_body()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1772
                self.type_declaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1773
                self.subtype_declaration()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1774
                self.constant_declaration()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1775
                self.variable_declaration()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1776
                self.file_declaration()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1777
                self.alias_declaration()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1778
                self.use_clause()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 1779
                self.group_template_declaration()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 1780
                self.group_declaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Package_body_declarative_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def package_body_declarative_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Package_body_declarative_itemContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Package_body_declarative_itemContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_package_body_declarative_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPackage_body_declarative_part" ):
                listener.enterPackage_body_declarative_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPackage_body_declarative_part" ):
                listener.exitPackage_body_declarative_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPackage_body_declarative_part" ):
                return visitor.visitPackage_body_declarative_part(self)
            else:
                return visitor.visitChildren(self)




    def package_body_declarative_part(self):

        localctx = vhdlParser.Package_body_declarative_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 324, self.RULE_package_body_declarative_part)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1786
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & 157305274400) != 0 or (((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & 210487083013) != 0:
                self.state = 1783
                self.package_body_declarative_item()
                self.state = 1788
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Package_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PACKAGE(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.PACKAGE)
            else:
                return self.getToken(vhdlParser.PACKAGE, i)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(vhdlParser.IdentifierContext,i)


        def IS(self):
            return self.getToken(vhdlParser.IS, 0)

        def package_declarative_part(self):
            return self.getTypedRuleContext(vhdlParser.Package_declarative_partContext,0)


        def END(self):
            return self.getToken(vhdlParser.END, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_package_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPackage_declaration" ):
                listener.enterPackage_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPackage_declaration" ):
                listener.exitPackage_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPackage_declaration" ):
                return visitor.visitPackage_declaration(self)
            else:
                return visitor.visitChildren(self)




    def package_declaration(self):

        localctx = vhdlParser.Package_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 326, self.RULE_package_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1789
            self.match(vhdlParser.PACKAGE)
            self.state = 1790
            self.identifier()
            self.state = 1791
            self.match(vhdlParser.IS)
            self.state = 1792
            self.package_declarative_part()
            self.state = 1793
            self.match(vhdlParser.END)
            self.state = 1795
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==64:
                self.state = 1794
                self.match(vhdlParser.PACKAGE)


            self.state = 1798
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 1797
                self.identifier()


            self.state = 1800
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Package_declarative_itemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subprogram_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Subprogram_declarationContext,0)


        def subprogram_body(self):
            return self.getTypedRuleContext(vhdlParser.Subprogram_bodyContext,0)


        def type_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Type_declarationContext,0)


        def subtype_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_declarationContext,0)


        def constant_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Constant_declarationContext,0)


        def signal_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Signal_declarationContext,0)


        def variable_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Variable_declarationContext,0)


        def file_declaration(self):
            return self.getTypedRuleContext(vhdlParser.File_declarationContext,0)


        def alias_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Alias_declarationContext,0)


        def component_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Component_declarationContext,0)


        def attribute_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Attribute_declarationContext,0)


        def attribute_specification(self):
            return self.getTypedRuleContext(vhdlParser.Attribute_specificationContext,0)


        def disconnection_specification(self):
            return self.getTypedRuleContext(vhdlParser.Disconnection_specificationContext,0)


        def use_clause(self):
            return self.getTypedRuleContext(vhdlParser.Use_clauseContext,0)


        def group_template_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Group_template_declarationContext,0)


        def group_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Group_declarationContext,0)


        def nature_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Nature_declarationContext,0)


        def subnature_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Subnature_declarationContext,0)


        def terminal_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Terminal_declarationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_package_declarative_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPackage_declarative_item" ):
                listener.enterPackage_declarative_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPackage_declarative_item" ):
                listener.exitPackage_declarative_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPackage_declarative_item" ):
                return visitor.visitPackage_declarative_item(self)
            else:
                return visitor.visitChildren(self)




    def package_declarative_item(self):

        localctx = vhdlParser.Package_declarative_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 328, self.RULE_package_declarative_item)
        try:
            self.state = 1821
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,189,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1802
                self.subprogram_declaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1803
                self.subprogram_body()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1804
                self.type_declaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1805
                self.subtype_declaration()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1806
                self.constant_declaration()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1807
                self.signal_declaration()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1808
                self.variable_declaration()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1809
                self.file_declaration()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1810
                self.alias_declaration()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 1811
                self.component_declaration()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 1812
                self.attribute_declaration()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 1813
                self.attribute_specification()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 1814
                self.disconnection_specification()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 1815
                self.use_clause()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 1816
                self.group_template_declaration()
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 1817
                self.group_declaration()
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 1818
                self.nature_declaration()
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 1819
                self.subnature_declaration()
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 1820
                self.terminal_declaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Package_declarative_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def package_declarative_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Package_declarative_itemContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Package_declarative_itemContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_package_declarative_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPackage_declarative_part" ):
                listener.enterPackage_declarative_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPackage_declarative_part" ):
                listener.exitPackage_declarative_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPackage_declarative_part" ):
                return visitor.visitPackage_declarative_part(self)
            else:
                return visitor.visitChildren(self)




    def package_declarative_part(self):

        localctx = vhdlParser.Package_declarative_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 330, self.RULE_package_declarative_part)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1826
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & 2251957123680288) != 0 or (((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & 210571231237) != 0:
                self.state = 1823
                self.package_declarative_item()
                self.state = 1828
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Parameter_specificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def IN(self):
            return self.getToken(vhdlParser.IN, 0)

        def discrete_range(self):
            return self.getTypedRuleContext(vhdlParser.Discrete_rangeContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_parameter_specification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter_specification" ):
                listener.enterParameter_specification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter_specification" ):
                listener.exitParameter_specification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter_specification" ):
                return visitor.visitParameter_specification(self)
            else:
                return visitor.visitChildren(self)




    def parameter_specification(self):

        localctx = vhdlParser.Parameter_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 332, self.RULE_parameter_specification)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1829
            self.identifier()
            self.state = 1830
            self.match(vhdlParser.IN)
            self.state = 1831
            self.discrete_range()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Physical_literalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def abstract_literal(self):
            return self.getTypedRuleContext(vhdlParser.Abstract_literalContext,0)


        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_physical_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPhysical_literal" ):
                listener.enterPhysical_literal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPhysical_literal" ):
                listener.exitPhysical_literal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPhysical_literal" ):
                return visitor.visitPhysical_literal(self)
            else:
                return visitor.visitChildren(self)




    def physical_literal(self):

        localctx = vhdlParser.Physical_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 334, self.RULE_physical_literal)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1833
            self.abstract_literal()

            self.state = 1834
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Physical_type_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def range_constraint(self):
            return self.getTypedRuleContext(vhdlParser.Range_constraintContext,0)


        def UNITS(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.UNITS)
            else:
                return self.getToken(vhdlParser.UNITS, i)

        def base_unit_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Base_unit_declarationContext,0)


        def END(self):
            return self.getToken(vhdlParser.END, 0)

        def secondary_unit_declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Secondary_unit_declarationContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Secondary_unit_declarationContext,i)


        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_physical_type_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPhysical_type_definition" ):
                listener.enterPhysical_type_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPhysical_type_definition" ):
                listener.exitPhysical_type_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPhysical_type_definition" ):
                return visitor.visitPhysical_type_definition(self)
            else:
                return visitor.visitChildren(self)




    def physical_type_definition(self):

        localctx = vhdlParser.Physical_type_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 336, self.RULE_physical_type_definition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1836
            self.range_constraint()
            self.state = 1837
            self.match(vhdlParser.UNITS)
            self.state = 1838
            self.base_unit_declaration()
            self.state = 1842
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==118 or _la==119:
                self.state = 1839
                self.secondary_unit_declaration()
                self.state = 1844
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1845
            self.match(vhdlParser.END)
            self.state = 1846
            self.match(vhdlParser.UNITS)
            self.state = 1848
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 1847
                self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Port_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PORT(self):
            return self.getToken(vhdlParser.PORT, 0)

        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def port_list(self):
            return self.getTypedRuleContext(vhdlParser.Port_listContext,0)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_port_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPort_clause" ):
                listener.enterPort_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPort_clause" ):
                listener.exitPort_clause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPort_clause" ):
                return visitor.visitPort_clause(self)
            else:
                return visitor.visitChildren(self)




    def port_clause(self):

        localctx = vhdlParser.Port_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 338, self.RULE_port_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1850
            self.match(vhdlParser.PORT)
            self.state = 1851
            self.match(vhdlParser.LPAREN)
            self.state = 1852
            self.port_list()
            self.state = 1853
            self.match(vhdlParser.RPAREN)
            self.state = 1854
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Port_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def interface_port_list(self):
            return self.getTypedRuleContext(vhdlParser.Interface_port_listContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_port_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPort_list" ):
                listener.enterPort_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPort_list" ):
                listener.exitPort_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPort_list" ):
                return visitor.visitPort_list(self)
            else:
                return visitor.visitChildren(self)




    def port_list(self):

        localctx = vhdlParser.Port_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 340, self.RULE_port_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1856
            self.interface_port_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Port_map_aspectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PORT(self):
            return self.getToken(vhdlParser.PORT, 0)

        def MAP(self):
            return self.getToken(vhdlParser.MAP, 0)

        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def association_list(self):
            return self.getTypedRuleContext(vhdlParser.Association_listContext,0)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_port_map_aspect

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPort_map_aspect" ):
                listener.enterPort_map_aspect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPort_map_aspect" ):
                listener.exitPort_map_aspect(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPort_map_aspect" ):
                return visitor.visitPort_map_aspect(self)
            else:
                return visitor.visitChildren(self)




    def port_map_aspect(self):

        localctx = vhdlParser.Port_map_aspectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 342, self.RULE_port_map_aspect)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1858
            self.match(vhdlParser.PORT)
            self.state = 1859
            self.match(vhdlParser.MAP)
            self.state = 1860
            self.match(vhdlParser.LPAREN)
            self.state = 1861
            self.association_list()
            self.state = 1862
            self.match(vhdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrimaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal(self):
            return self.getTypedRuleContext(vhdlParser.LiteralContext,0)


        def qualified_expression(self):
            return self.getTypedRuleContext(vhdlParser.Qualified_expressionContext,0)


        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def allocator(self):
            return self.getTypedRuleContext(vhdlParser.AllocatorContext,0)


        def aggregate(self):
            return self.getTypedRuleContext(vhdlParser.AggregateContext,0)


        def name(self):
            return self.getTypedRuleContext(vhdlParser.NameContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_primary

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimary" ):
                listener.enterPrimary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimary" ):
                listener.exitPrimary(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimary" ):
                return visitor.visitPrimary(self)
            else:
                return visitor.visitChildren(self)




    def primary(self):

        localctx = vhdlParser.PrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 344, self.RULE_primary)
        try:
            self.state = 1873
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,193,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1864
                self.literal()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1865
                self.qualified_expression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1866
                self.match(vhdlParser.LPAREN)
                self.state = 1867
                self.expression()
                self.state = 1868
                self.match(vhdlParser.RPAREN)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1870
                self.allocator()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1871
                self.aggregate()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1872
                self.name()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Primary_unitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def entity_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Entity_declarationContext,0)


        def configuration_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Configuration_declarationContext,0)


        def package_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Package_declarationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_primary_unit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimary_unit" ):
                listener.enterPrimary_unit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimary_unit" ):
                listener.exitPrimary_unit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimary_unit" ):
                return visitor.visitPrimary_unit(self)
            else:
                return visitor.visitChildren(self)




    def primary_unit(self):

        localctx = vhdlParser.Primary_unitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 346, self.RULE_primary_unit)
        try:
            self.state = 1878
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [25]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1875
                self.entity_declaration()
                pass
            elif token in [20]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1876
                self.configuration_declaration()
                pass
            elif token in [64]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1877
                self.package_declaration()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Procedural_declarative_itemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subprogram_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Subprogram_declarationContext,0)


        def subprogram_body(self):
            return self.getTypedRuleContext(vhdlParser.Subprogram_bodyContext,0)


        def type_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Type_declarationContext,0)


        def subtype_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_declarationContext,0)


        def constant_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Constant_declarationContext,0)


        def variable_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Variable_declarationContext,0)


        def alias_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Alias_declarationContext,0)


        def attribute_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Attribute_declarationContext,0)


        def attribute_specification(self):
            return self.getTypedRuleContext(vhdlParser.Attribute_specificationContext,0)


        def use_clause(self):
            return self.getTypedRuleContext(vhdlParser.Use_clauseContext,0)


        def group_template_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Group_template_declarationContext,0)


        def group_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Group_declarationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_procedural_declarative_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcedural_declarative_item" ):
                listener.enterProcedural_declarative_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcedural_declarative_item" ):
                listener.exitProcedural_declarative_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcedural_declarative_item" ):
                return visitor.visitProcedural_declarative_item(self)
            else:
                return visitor.visitChildren(self)




    def procedural_declarative_item(self):

        localctx = vhdlParser.Procedural_declarative_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 348, self.RULE_procedural_declarative_item)
        try:
            self.state = 1892
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,195,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1880
                self.subprogram_declaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1881
                self.subprogram_body()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1882
                self.type_declaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1883
                self.subtype_declaration()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1884
                self.constant_declaration()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1885
                self.variable_declaration()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1886
                self.alias_declaration()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1887
                self.attribute_declaration()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1888
                self.attribute_specification()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 1889
                self.use_clause()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 1890
                self.group_template_declaration()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 1891
                self.group_declaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Procedural_declarative_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def procedural_declarative_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Procedural_declarative_itemContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Procedural_declarative_itemContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_procedural_declarative_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcedural_declarative_part" ):
                listener.enterProcedural_declarative_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcedural_declarative_part" ):
                listener.exitProcedural_declarative_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcedural_declarative_part" ):
                return visitor.visitProcedural_declarative_part(self)
            else:
                return visitor.visitChildren(self)




    def procedural_declarative_part(self):

        localctx = vhdlParser.Procedural_declarative_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 350, self.RULE_procedural_declarative_part)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1897
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & 156768405536) != 0 or (((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & 210487083013) != 0:
                self.state = 1894
                self.procedural_declarative_item()
                self.state = 1899
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Procedural_statement_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sequential_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Sequential_statementContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Sequential_statementContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_procedural_statement_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcedural_statement_part" ):
                listener.enterProcedural_statement_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcedural_statement_part" ):
                listener.exitProcedural_statement_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcedural_statement_part" ):
                return visitor.visitProcedural_statement_part(self)
            else:
                return visitor.visitChildren(self)




    def procedural_statement_part(self):

        localctx = vhdlParser.Procedural_statement_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 352, self.RULE_procedural_statement_part)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1903
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & 153263194880902144) != 0 or (((_la - 79)) & ~0x3f) == 0 and ((1 << (_la - 79)) & 4611969143879499779) != 0:
                self.state = 1900
                self.sequential_statement()
                self.state = 1905
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Procedure_callContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def selected_name(self):
            return self.getTypedRuleContext(vhdlParser.Selected_nameContext,0)


        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def actual_parameter_part(self):
            return self.getTypedRuleContext(vhdlParser.Actual_parameter_partContext,0)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_procedure_call

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcedure_call" ):
                listener.enterProcedure_call(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcedure_call" ):
                listener.exitProcedure_call(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcedure_call" ):
                return visitor.visitProcedure_call(self)
            else:
                return visitor.visitChildren(self)




    def procedure_call(self):

        localctx = vhdlParser.Procedure_callContext(self, self._ctx, self.state)
        self.enterRule(localctx, 354, self.RULE_procedure_call)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1906
            self.selected_name()
            self.state = 1911
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==141:
                self.state = 1907
                self.match(vhdlParser.LPAREN)
                self.state = 1908
                self.actual_parameter_part()
                self.state = 1909
                self.match(vhdlParser.RPAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Procedure_call_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def procedure_call(self):
            return self.getTypedRuleContext(vhdlParser.Procedure_callContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_procedure_call_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcedure_call_statement" ):
                listener.enterProcedure_call_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcedure_call_statement" ):
                listener.exitProcedure_call_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcedure_call_statement" ):
                return visitor.visitProcedure_call_statement(self)
            else:
                return visitor.visitChildren(self)




    def procedure_call_statement(self):

        localctx = vhdlParser.Procedure_call_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 356, self.RULE_procedure_call_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1914
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,199,self._ctx)
            if la_ == 1:
                self.state = 1913
                self.label_colon()


            self.state = 1916
            self.procedure_call()
            self.state = 1917
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Process_declarative_itemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subprogram_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Subprogram_declarationContext,0)


        def subprogram_body(self):
            return self.getTypedRuleContext(vhdlParser.Subprogram_bodyContext,0)


        def type_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Type_declarationContext,0)


        def subtype_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_declarationContext,0)


        def constant_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Constant_declarationContext,0)


        def variable_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Variable_declarationContext,0)


        def file_declaration(self):
            return self.getTypedRuleContext(vhdlParser.File_declarationContext,0)


        def alias_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Alias_declarationContext,0)


        def attribute_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Attribute_declarationContext,0)


        def attribute_specification(self):
            return self.getTypedRuleContext(vhdlParser.Attribute_specificationContext,0)


        def use_clause(self):
            return self.getTypedRuleContext(vhdlParser.Use_clauseContext,0)


        def group_template_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Group_template_declarationContext,0)


        def group_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Group_declarationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_process_declarative_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcess_declarative_item" ):
                listener.enterProcess_declarative_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcess_declarative_item" ):
                listener.exitProcess_declarative_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcess_declarative_item" ):
                return visitor.visitProcess_declarative_item(self)
            else:
                return visitor.visitChildren(self)




    def process_declarative_item(self):

        localctx = vhdlParser.Process_declarative_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 358, self.RULE_process_declarative_item)
        try:
            self.state = 1932
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,200,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1919
                self.subprogram_declaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1920
                self.subprogram_body()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1921
                self.type_declaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1922
                self.subtype_declaration()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1923
                self.constant_declaration()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1924
                self.variable_declaration()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1925
                self.file_declaration()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1926
                self.alias_declaration()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1927
                self.attribute_declaration()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 1928
                self.attribute_specification()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 1929
                self.use_clause()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 1930
                self.group_template_declaration()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 1931
                self.group_declaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Process_declarative_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def process_declarative_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Process_declarative_itemContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Process_declarative_itemContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_process_declarative_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcess_declarative_part" ):
                listener.enterProcess_declarative_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcess_declarative_part" ):
                listener.exitProcess_declarative_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcess_declarative_part" ):
                return visitor.visitProcess_declarative_part(self)
            else:
                return visitor.visitChildren(self)




    def process_declarative_part(self):

        localctx = vhdlParser.Process_declarative_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 360, self.RULE_process_declarative_part)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1937
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & 157305276448) != 0 or (((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & 210487083013) != 0:
                self.state = 1934
                self.process_declarative_item()
                self.state = 1939
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Process_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROCESS(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.PROCESS)
            else:
                return self.getToken(vhdlParser.PROCESS, i)

        def process_declarative_part(self):
            return self.getTypedRuleContext(vhdlParser.Process_declarative_partContext,0)


        def BEGIN(self):
            return self.getToken(vhdlParser.BEGIN, 0)

        def process_statement_part(self):
            return self.getTypedRuleContext(vhdlParser.Process_statement_partContext,0)


        def END(self):
            return self.getToken(vhdlParser.END, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def POSTPONED(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.POSTPONED)
            else:
                return self.getToken(vhdlParser.POSTPONED, i)

        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def sensitivity_list(self):
            return self.getTypedRuleContext(vhdlParser.Sensitivity_listContext,0)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def IS(self):
            return self.getToken(vhdlParser.IS, 0)

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_process_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcess_statement" ):
                listener.enterProcess_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcess_statement" ):
                listener.exitProcess_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcess_statement" ):
                return visitor.visitProcess_statement(self)
            else:
                return visitor.visitChildren(self)




    def process_statement(self):

        localctx = vhdlParser.Process_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 362, self.RULE_process_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1941
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 1940
                self.label_colon()


            self.state = 1944
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==66:
                self.state = 1943
                self.match(vhdlParser.POSTPONED)


            self.state = 1946
            self.match(vhdlParser.PROCESS)
            self.state = 1951
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==141:
                self.state = 1947
                self.match(vhdlParser.LPAREN)
                self.state = 1948
                self.sensitivity_list()
                self.state = 1949
                self.match(vhdlParser.RPAREN)


            self.state = 1954
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41:
                self.state = 1953
                self.match(vhdlParser.IS)


            self.state = 1956
            self.process_declarative_part()
            self.state = 1957
            self.match(vhdlParser.BEGIN)
            self.state = 1958
            self.process_statement_part()
            self.state = 1959
            self.match(vhdlParser.END)
            self.state = 1961
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==66:
                self.state = 1960
                self.match(vhdlParser.POSTPONED)


            self.state = 1963
            self.match(vhdlParser.PROCESS)
            self.state = 1965
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 1964
                self.identifier()


            self.state = 1967
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Process_statement_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sequential_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Sequential_statementContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Sequential_statementContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_process_statement_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcess_statement_part" ):
                listener.enterProcess_statement_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcess_statement_part" ):
                listener.exitProcess_statement_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcess_statement_part" ):
                return visitor.visitProcess_statement_part(self)
            else:
                return visitor.visitChildren(self)




    def process_statement_part(self):

        localctx = vhdlParser.Process_statement_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 364, self.RULE_process_statement_part)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1972
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & 153263194880902144) != 0 or (((_la - 79)) & ~0x3f) == 0 and ((1 << (_la - 79)) & 4611969143879499779) != 0:
                self.state = 1969
                self.sequential_statement()
                self.state = 1974
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Qualified_expressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def APOSTROPHE(self):
            return self.getToken(vhdlParser.APOSTROPHE, 0)

        def aggregate(self):
            return self.getTypedRuleContext(vhdlParser.AggregateContext,0)


        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_qualified_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQualified_expression" ):
                listener.enterQualified_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQualified_expression" ):
                listener.exitQualified_expression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQualified_expression" ):
                return visitor.visitQualified_expression(self)
            else:
                return visitor.visitChildren(self)




    def qualified_expression(self):

        localctx = vhdlParser.Qualified_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 366, self.RULE_qualified_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1975
            self.subtype_indication()
            self.state = 1976
            self.match(vhdlParser.APOSTROPHE)
            self.state = 1982
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,209,self._ctx)
            if la_ == 1:
                self.state = 1977
                self.aggregate()
                pass

            elif la_ == 2:
                self.state = 1978
                self.match(vhdlParser.LPAREN)
                self.state = 1979
                self.expression()
                self.state = 1980
                self.match(vhdlParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Quantity_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def free_quantity_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Free_quantity_declarationContext,0)


        def branch_quantity_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Branch_quantity_declarationContext,0)


        def source_quantity_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Source_quantity_declarationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_quantity_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuantity_declaration" ):
                listener.enterQuantity_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuantity_declaration" ):
                listener.exitQuantity_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuantity_declaration" ):
                return visitor.visitQuantity_declaration(self)
            else:
                return visitor.visitChildren(self)




    def quantity_declaration(self):

        localctx = vhdlParser.Quantity_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 368, self.RULE_quantity_declaration)
        try:
            self.state = 1987
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,210,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1984
                self.free_quantity_declaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1985
                self.branch_quantity_declaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1986
                self.source_quantity_declaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Quantity_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.NameContext)
            else:
                return self.getTypedRuleContext(vhdlParser.NameContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.COMMA)
            else:
                return self.getToken(vhdlParser.COMMA, i)

        def OTHERS(self):
            return self.getToken(vhdlParser.OTHERS, 0)

        def ALL(self):
            return self.getToken(vhdlParser.ALL, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_quantity_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuantity_list" ):
                listener.enterQuantity_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuantity_list" ):
                listener.exitQuantity_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuantity_list" ):
                return visitor.visitQuantity_list(self)
            else:
                return visitor.visitChildren(self)




    def quantity_list(self):

        localctx = vhdlParser.Quantity_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 370, self.RULE_quantity_list)
        self._la = 0 # Token type
        try:
            self.state = 1999
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [118, 119, 127]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1989
                self.name()
                self.state = 1994
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==139:
                    self.state = 1990
                    self.match(vhdlParser.COMMA)
                    self.state = 1991
                    self.name()
                    self.state = 1996
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [62]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1997
                self.match(vhdlParser.OTHERS)
                pass
            elif token in [6]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1998
                self.match(vhdlParser.ALL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Quantity_specificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def quantity_list(self):
            return self.getTypedRuleContext(vhdlParser.Quantity_listContext,0)


        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def name(self):
            return self.getTypedRuleContext(vhdlParser.NameContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_quantity_specification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuantity_specification" ):
                listener.enterQuantity_specification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuantity_specification" ):
                listener.exitQuantity_specification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuantity_specification" ):
                return visitor.visitQuantity_specification(self)
            else:
                return visitor.visitChildren(self)




    def quantity_specification(self):

        localctx = vhdlParser.Quantity_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 372, self.RULE_quantity_specification)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2001
            self.quantity_list()
            self.state = 2002
            self.match(vhdlParser.COLON)
            self.state = 2003
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Range_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def explicit_range(self):
            return self.getTypedRuleContext(vhdlParser.Explicit_rangeContext,0)


        def name(self):
            return self.getTypedRuleContext(vhdlParser.NameContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_range_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRange_decl" ):
                listener.enterRange_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRange_decl" ):
                listener.exitRange_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRange_decl" ):
                return visitor.visitRange_decl(self)
            else:
                return visitor.visitChildren(self)




    def range_decl(self):

        localctx = vhdlParser.Range_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 374, self.RULE_range_decl)
        try:
            self.state = 2007
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,213,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2005
                self.explicit_range()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2006
                self.name()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Explicit_rangeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simple_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Simple_expressionContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Simple_expressionContext,i)


        def direction(self):
            return self.getTypedRuleContext(vhdlParser.DirectionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_explicit_range

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExplicit_range" ):
                listener.enterExplicit_range(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExplicit_range" ):
                listener.exitExplicit_range(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExplicit_range" ):
                return visitor.visitExplicit_range(self)
            else:
                return visitor.visitChildren(self)




    def explicit_range(self):

        localctx = vhdlParser.Explicit_rangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 376, self.RULE_explicit_range)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2009
            self.simple_expression()
            self.state = 2013
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,214,self._ctx)
            if la_ == 1:
                self.state = 2010
                self.direction()
                self.state = 2011
                self.simple_expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Range_constraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RANGE(self):
            return self.getToken(vhdlParser.RANGE, 0)

        def range_decl(self):
            return self.getTypedRuleContext(vhdlParser.Range_declContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_range_constraint

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRange_constraint" ):
                listener.enterRange_constraint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRange_constraint" ):
                listener.exitRange_constraint(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRange_constraint" ):
                return visitor.visitRange_constraint(self)
            else:
                return visitor.visitChildren(self)




    def range_constraint(self):

        localctx = vhdlParser.Range_constraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 378, self.RULE_range_constraint)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2015
            self.match(vhdlParser.RANGE)
            self.state = 2016
            self.range_decl()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Record_nature_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RECORD(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.RECORD)
            else:
                return self.getToken(vhdlParser.RECORD, i)

        def END(self):
            return self.getToken(vhdlParser.END, 0)

        def nature_element_declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Nature_element_declarationContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Nature_element_declarationContext,i)


        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_record_nature_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRecord_nature_definition" ):
                listener.enterRecord_nature_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRecord_nature_definition" ):
                listener.exitRecord_nature_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRecord_nature_definition" ):
                return visitor.visitRecord_nature_definition(self)
            else:
                return visitor.visitChildren(self)




    def record_nature_definition(self):

        localctx = vhdlParser.Record_nature_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 380, self.RULE_record_nature_definition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2018
            self.match(vhdlParser.RECORD)
            self.state = 2020 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 2019
                self.nature_element_declaration()
                self.state = 2022 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==118 or _la==119):
                    break

            self.state = 2024
            self.match(vhdlParser.END)
            self.state = 2025
            self.match(vhdlParser.RECORD)
            self.state = 2027
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 2026
                self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Record_type_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RECORD(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.RECORD)
            else:
                return self.getToken(vhdlParser.RECORD, i)

        def END(self):
            return self.getToken(vhdlParser.END, 0)

        def element_declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Element_declarationContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Element_declarationContext,i)


        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_record_type_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRecord_type_definition" ):
                listener.enterRecord_type_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRecord_type_definition" ):
                listener.exitRecord_type_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRecord_type_definition" ):
                return visitor.visitRecord_type_definition(self)
            else:
                return visitor.visitChildren(self)




    def record_type_definition(self):

        localctx = vhdlParser.Record_type_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 382, self.RULE_record_type_definition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2029
            self.match(vhdlParser.RECORD)
            self.state = 2031 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 2030
                self.element_declaration()
                self.state = 2033 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==118 or _la==119):
                    break

            self.state = 2035
            self.match(vhdlParser.END)
            self.state = 2036
            self.match(vhdlParser.RECORD)
            self.state = 2038
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 2037
                self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shift_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Shift_expressionContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Shift_expressionContext,i)


        def relational_operator(self):
            return self.getTypedRuleContext(vhdlParser.Relational_operatorContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_relation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelation" ):
                listener.enterRelation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelation" ):
                listener.exitRelation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelation" ):
                return visitor.visitRelation(self)
            else:
                return visitor.visitChildren(self)




    def relation(self):

        localctx = vhdlParser.RelationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 384, self.RULE_relation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2040
            self.shift_expression()
            self.state = 2044
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,219,self._ctx)
            if la_ == 1:
                self.state = 2041
                self.relational_operator()
                self.state = 2042
                self.shift_expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Relational_operatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(vhdlParser.EQ, 0)

        def NEQ(self):
            return self.getToken(vhdlParser.NEQ, 0)

        def LOWERTHAN(self):
            return self.getToken(vhdlParser.LOWERTHAN, 0)

        def LE(self):
            return self.getToken(vhdlParser.LE, 0)

        def GREATERTHAN(self):
            return self.getToken(vhdlParser.GREATERTHAN, 0)

        def GE(self):
            return self.getToken(vhdlParser.GE, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_relational_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelational_operator" ):
                listener.enterRelational_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelational_operator" ):
                listener.exitRelational_operator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelational_operator" ):
                return visitor.visitRelational_operator(self)
            else:
                return visitor.visitChildren(self)




    def relational_operator(self):

        localctx = vhdlParser.Relational_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 386, self.RULE_relational_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2046
            _la = self._input.LA(1)
            if not((((_la - 131)) & ~0x3f) == 0 and ((1 << (_la - 131)) & 3670027) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Report_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPORT(self):
            return self.getToken(vhdlParser.REPORT, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(vhdlParser.ExpressionContext,i)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def SEVERITY(self):
            return self.getToken(vhdlParser.SEVERITY, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_report_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReport_statement" ):
                listener.enterReport_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReport_statement" ):
                listener.exitReport_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReport_statement" ):
                return visitor.visitReport_statement(self)
            else:
                return visitor.visitChildren(self)




    def report_statement(self):

        localctx = vhdlParser.Report_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 388, self.RULE_report_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2049
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 2048
                self.label_colon()


            self.state = 2051
            self.match(vhdlParser.REPORT)
            self.state = 2052
            self.expression()
            self.state = 2055
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==84:
                self.state = 2053
                self.match(vhdlParser.SEVERITY)
                self.state = 2054
                self.expression()


            self.state = 2057
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Return_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(vhdlParser.RETURN, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_return_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturn_statement" ):
                listener.enterReturn_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturn_statement" ):
                listener.exitReturn_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturn_statement" ):
                return visitor.visitReturn_statement(self)
            else:
                return visitor.visitChildren(self)




    def return_statement(self):

        localctx = vhdlParser.Return_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 390, self.RULE_return_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2060
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 2059
                self.label_colon()


            self.state = 2062
            self.match(vhdlParser.RETURN)
            self.state = 2064
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((_la) & ~0x3f) == 0 and ((1 << _la) & 220676381741154306) != 0 or (((_la - 112)) & ~0x3f) == 0 and ((1 << (_la - 112)) & 70575439528163) != 0:
                self.state = 2063
                self.expression()


            self.state = 2066
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Scalar_nature_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.NameContext)
            else:
                return self.getTypedRuleContext(vhdlParser.NameContext,i)


        def ACROSS(self):
            return self.getToken(vhdlParser.ACROSS, 0)

        def THROUGH(self):
            return self.getToken(vhdlParser.THROUGH, 0)

        def REFERENCE(self):
            return self.getToken(vhdlParser.REFERENCE, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_scalar_nature_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScalar_nature_definition" ):
                listener.enterScalar_nature_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScalar_nature_definition" ):
                listener.exitScalar_nature_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitScalar_nature_definition" ):
                return visitor.visitScalar_nature_definition(self)
            else:
                return visitor.visitChildren(self)




    def scalar_nature_definition(self):

        localctx = vhdlParser.Scalar_nature_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 392, self.RULE_scalar_nature_definition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2068
            self.name()
            self.state = 2069
            self.match(vhdlParser.ACROSS)
            self.state = 2070
            self.name()
            self.state = 2071
            self.match(vhdlParser.THROUGH)
            self.state = 2072
            self.name()
            self.state = 2073
            self.match(vhdlParser.REFERENCE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Scalar_type_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def physical_type_definition(self):
            return self.getTypedRuleContext(vhdlParser.Physical_type_definitionContext,0)


        def enumeration_type_definition(self):
            return self.getTypedRuleContext(vhdlParser.Enumeration_type_definitionContext,0)


        def range_constraint(self):
            return self.getTypedRuleContext(vhdlParser.Range_constraintContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_scalar_type_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScalar_type_definition" ):
                listener.enterScalar_type_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScalar_type_definition" ):
                listener.exitScalar_type_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitScalar_type_definition" ):
                return visitor.visitScalar_type_definition(self)
            else:
                return visitor.visitChildren(self)




    def scalar_type_definition(self):

        localctx = vhdlParser.Scalar_type_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 394, self.RULE_scalar_type_definition)
        try:
            self.state = 2078
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,224,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2075
                self.physical_type_definition()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2076
                self.enumeration_type_definition()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2077
                self.range_constraint()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Secondary_unitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def architecture_body(self):
            return self.getTypedRuleContext(vhdlParser.Architecture_bodyContext,0)


        def package_body(self):
            return self.getTypedRuleContext(vhdlParser.Package_bodyContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_secondary_unit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSecondary_unit" ):
                listener.enterSecondary_unit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSecondary_unit" ):
                listener.exitSecondary_unit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSecondary_unit" ):
                return visitor.visitSecondary_unit(self)
            else:
                return visitor.visitChildren(self)




    def secondary_unit(self):

        localctx = vhdlParser.Secondary_unitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 396, self.RULE_secondary_unit)
        try:
            self.state = 2082
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [8]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2080
                self.architecture_body()
                pass
            elif token in [64]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2081
                self.package_body()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Secondary_unit_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def EQ(self):
            return self.getToken(vhdlParser.EQ, 0)

        def physical_literal(self):
            return self.getTypedRuleContext(vhdlParser.Physical_literalContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_secondary_unit_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSecondary_unit_declaration" ):
                listener.enterSecondary_unit_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSecondary_unit_declaration" ):
                listener.exitSecondary_unit_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSecondary_unit_declaration" ):
                return visitor.visitSecondary_unit_declaration(self)
            else:
                return visitor.visitChildren(self)




    def secondary_unit_declaration(self):

        localctx = vhdlParser.Secondary_unit_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 398, self.RULE_secondary_unit_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2084
            self.identifier()
            self.state = 2085
            self.match(vhdlParser.EQ)
            self.state = 2086
            self.physical_literal()
            self.state = 2087
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Selected_signal_assignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH(self):
            return self.getToken(vhdlParser.WITH, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def SELECT(self):
            return self.getToken(vhdlParser.SELECT, 0)

        def target(self):
            return self.getTypedRuleContext(vhdlParser.TargetContext,0)


        def LE(self):
            return self.getToken(vhdlParser.LE, 0)

        def opts(self):
            return self.getTypedRuleContext(vhdlParser.OptsContext,0)


        def selected_waveforms(self):
            return self.getTypedRuleContext(vhdlParser.Selected_waveformsContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_selected_signal_assignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelected_signal_assignment" ):
                listener.enterSelected_signal_assignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelected_signal_assignment" ):
                listener.exitSelected_signal_assignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelected_signal_assignment" ):
                return visitor.visitSelected_signal_assignment(self)
            else:
                return visitor.visitChildren(self)




    def selected_signal_assignment(self):

        localctx = vhdlParser.Selected_signal_assignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 400, self.RULE_selected_signal_assignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2089
            self.match(vhdlParser.WITH)
            self.state = 2090
            self.expression()
            self.state = 2091
            self.match(vhdlParser.SELECT)
            self.state = 2092
            self.target()
            self.state = 2093
            self.match(vhdlParser.LE)
            self.state = 2094
            self.opts()
            self.state = 2095
            self.selected_waveforms()
            self.state = 2096
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Selected_waveformsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def waveform(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.WaveformContext)
            else:
                return self.getTypedRuleContext(vhdlParser.WaveformContext,i)


        def WHEN(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.WHEN)
            else:
                return self.getToken(vhdlParser.WHEN, i)

        def choices(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.ChoicesContext)
            else:
                return self.getTypedRuleContext(vhdlParser.ChoicesContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.COMMA)
            else:
                return self.getToken(vhdlParser.COMMA, i)

        def getRuleIndex(self):
            return vhdlParser.RULE_selected_waveforms

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelected_waveforms" ):
                listener.enterSelected_waveforms(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelected_waveforms" ):
                listener.exitSelected_waveforms(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelected_waveforms" ):
                return visitor.visitSelected_waveforms(self)
            else:
                return visitor.visitChildren(self)




    def selected_waveforms(self):

        localctx = vhdlParser.Selected_waveformsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 402, self.RULE_selected_waveforms)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2098
            self.waveform()
            self.state = 2099
            self.match(vhdlParser.WHEN)
            self.state = 2100
            self.choices()
            self.state = 2108
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==139:
                self.state = 2101
                self.match(vhdlParser.COMMA)
                self.state = 2102
                self.waveform()
                self.state = 2103
                self.match(vhdlParser.WHEN)
                self.state = 2104
                self.choices()
                self.state = 2110
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Sensitivity_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ON(self):
            return self.getToken(vhdlParser.ON, 0)

        def sensitivity_list(self):
            return self.getTypedRuleContext(vhdlParser.Sensitivity_listContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_sensitivity_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSensitivity_clause" ):
                listener.enterSensitivity_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSensitivity_clause" ):
                listener.exitSensitivity_clause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSensitivity_clause" ):
                return visitor.visitSensitivity_clause(self)
            else:
                return visitor.visitChildren(self)




    def sensitivity_clause(self):

        localctx = vhdlParser.Sensitivity_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 404, self.RULE_sensitivity_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2111
            self.match(vhdlParser.ON)
            self.state = 2112
            self.sensitivity_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Sensitivity_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.NameContext)
            else:
                return self.getTypedRuleContext(vhdlParser.NameContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.COMMA)
            else:
                return self.getToken(vhdlParser.COMMA, i)

        def getRuleIndex(self):
            return vhdlParser.RULE_sensitivity_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSensitivity_list" ):
                listener.enterSensitivity_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSensitivity_list" ):
                listener.exitSensitivity_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSensitivity_list" ):
                return visitor.visitSensitivity_list(self)
            else:
                return visitor.visitChildren(self)




    def sensitivity_list(self):

        localctx = vhdlParser.Sensitivity_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 406, self.RULE_sensitivity_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2114
            self.name()
            self.state = 2119
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==139:
                self.state = 2115
                self.match(vhdlParser.COMMA)
                self.state = 2116
                self.name()
                self.state = 2121
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Sequence_of_statementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sequential_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Sequential_statementContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Sequential_statementContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_sequence_of_statements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSequence_of_statements" ):
                listener.enterSequence_of_statements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSequence_of_statements" ):
                listener.exitSequence_of_statements(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSequence_of_statements" ):
                return visitor.visitSequence_of_statements(self)
            else:
                return visitor.visitChildren(self)




    def sequence_of_statements(self):

        localctx = vhdlParser.Sequence_of_statementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 408, self.RULE_sequence_of_statements)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2125
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & 153263194880902144) != 0 or (((_la - 79)) & ~0x3f) == 0 and ((1 << (_la - 79)) & 4611969143879499779) != 0:
                self.state = 2122
                self.sequential_statement()
                self.state = 2127
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Sequential_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def wait_statement(self):
            return self.getTypedRuleContext(vhdlParser.Wait_statementContext,0)


        def assertion_statement(self):
            return self.getTypedRuleContext(vhdlParser.Assertion_statementContext,0)


        def report_statement(self):
            return self.getTypedRuleContext(vhdlParser.Report_statementContext,0)


        def signal_assignment_statement(self):
            return self.getTypedRuleContext(vhdlParser.Signal_assignment_statementContext,0)


        def variable_assignment_statement(self):
            return self.getTypedRuleContext(vhdlParser.Variable_assignment_statementContext,0)


        def if_statement(self):
            return self.getTypedRuleContext(vhdlParser.If_statementContext,0)


        def case_statement(self):
            return self.getTypedRuleContext(vhdlParser.Case_statementContext,0)


        def loop_statement(self):
            return self.getTypedRuleContext(vhdlParser.Loop_statementContext,0)


        def next_statement(self):
            return self.getTypedRuleContext(vhdlParser.Next_statementContext,0)


        def exit_statement(self):
            return self.getTypedRuleContext(vhdlParser.Exit_statementContext,0)


        def return_statement(self):
            return self.getTypedRuleContext(vhdlParser.Return_statementContext,0)


        def NULL_(self):
            return self.getToken(vhdlParser.NULL_, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def break_statement(self):
            return self.getTypedRuleContext(vhdlParser.Break_statementContext,0)


        def procedure_call_statement(self):
            return self.getTypedRuleContext(vhdlParser.Procedure_call_statementContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_sequential_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSequential_statement" ):
                listener.enterSequential_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSequential_statement" ):
                listener.exitSequential_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSequential_statement" ):
                return visitor.visitSequential_statement(self)
            else:
                return visitor.visitChildren(self)




    def sequential_statement(self):

        localctx = vhdlParser.Sequential_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 410, self.RULE_sequential_statement)
        self._la = 0 # Token type
        try:
            self.state = 2146
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,230,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2128
                self.wait_statement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2129
                self.assertion_statement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2130
                self.report_statement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2131
                self.signal_assignment_statement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2132
                self.variable_assignment_statement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2133
                self.if_statement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2134
                self.case_statement()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 2135
                self.loop_statement()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 2136
                self.next_statement()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 2137
                self.exit_statement()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 2138
                self.return_statement()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 2140
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==118 or _la==119:
                    self.state = 2139
                    self.label_colon()


                self.state = 2142
                self.match(vhdlParser.NULL_)
                self.state = 2143
                self.match(vhdlParser.SEMI)
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 2144
                self.break_statement()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 2145
                self.procedure_call_statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Shift_expressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simple_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Simple_expressionContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Simple_expressionContext,i)


        def shift_operator(self):
            return self.getTypedRuleContext(vhdlParser.Shift_operatorContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_shift_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShift_expression" ):
                listener.enterShift_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShift_expression" ):
                listener.exitShift_expression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShift_expression" ):
                return visitor.visitShift_expression(self)
            else:
                return visitor.visitChildren(self)




    def shift_expression(self):

        localctx = vhdlParser.Shift_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 412, self.RULE_shift_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2148
            self.simple_expression()
            self.state = 2152
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,231,self._ctx)
            if la_ == 1:
                self.state = 2149
                self.shift_operator()
                self.state = 2150
                self.simple_expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Shift_operatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SLL(self):
            return self.getToken(vhdlParser.SLL, 0)

        def SRL(self):
            return self.getToken(vhdlParser.SRL, 0)

        def SLA(self):
            return self.getToken(vhdlParser.SLA, 0)

        def SRA(self):
            return self.getToken(vhdlParser.SRA, 0)

        def ROL(self):
            return self.getToken(vhdlParser.ROL, 0)

        def ROR(self):
            return self.getToken(vhdlParser.ROR, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_shift_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShift_operator" ):
                listener.enterShift_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShift_operator" ):
                listener.exitShift_operator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShift_operator" ):
                return visitor.visitShift_operator(self)
            else:
                return visitor.visitChildren(self)




    def shift_operator(self):

        localctx = vhdlParser.Shift_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 414, self.RULE_shift_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2154
            _la = self._input.LA(1)
            if not((((_la - 81)) & ~0x3f) == 0 and ((1 << (_la - 81)) & 1731) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Signal_assignment_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def target(self):
            return self.getTypedRuleContext(vhdlParser.TargetContext,0)


        def LE(self):
            return self.getToken(vhdlParser.LE, 0)

        def waveform(self):
            return self.getTypedRuleContext(vhdlParser.WaveformContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def delay_mechanism(self):
            return self.getTypedRuleContext(vhdlParser.Delay_mechanismContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_signal_assignment_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSignal_assignment_statement" ):
                listener.enterSignal_assignment_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSignal_assignment_statement" ):
                listener.exitSignal_assignment_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSignal_assignment_statement" ):
                return visitor.visitSignal_assignment_statement(self)
            else:
                return visitor.visitChildren(self)




    def signal_assignment_statement(self):

        localctx = vhdlParser.Signal_assignment_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 416, self.RULE_signal_assignment_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2157
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,232,self._ctx)
            if la_ == 1:
                self.state = 2156
                self.label_colon()


            self.state = 2159
            self.target()
            self.state = 2160
            self.match(vhdlParser.LE)
            self.state = 2162
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la - 39)) & ~0x3f) == 0 and ((1 << (_la - 39)) & 1152921538966585345) != 0:
                self.state = 2161
                self.delay_mechanism()


            self.state = 2164
            self.waveform()
            self.state = 2165
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Signal_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNAL(self):
            return self.getToken(vhdlParser.SIGNAL, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(vhdlParser.Identifier_listContext,0)


        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def signal_kind(self):
            return self.getTypedRuleContext(vhdlParser.Signal_kindContext,0)


        def VARASGN(self):
            return self.getToken(vhdlParser.VARASGN, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_signal_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSignal_declaration" ):
                listener.enterSignal_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSignal_declaration" ):
                listener.exitSignal_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSignal_declaration" ):
                return visitor.visitSignal_declaration(self)
            else:
                return visitor.visitChildren(self)




    def signal_declaration(self):

        localctx = vhdlParser.Signal_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 418, self.RULE_signal_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2167
            self.match(vhdlParser.SIGNAL)
            self.state = 2168
            self.identifier_list()
            self.state = 2169
            self.match(vhdlParser.COLON)
            self.state = 2170
            self.subtype_indication()
            self.state = 2172
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==17 or _la==78:
                self.state = 2171
                self.signal_kind()


            self.state = 2176
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==135:
                self.state = 2174
                self.match(vhdlParser.VARASGN)
                self.state = 2175
                self.expression()


            self.state = 2178
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Signal_kindContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REGISTER(self):
            return self.getToken(vhdlParser.REGISTER, 0)

        def BUS(self):
            return self.getToken(vhdlParser.BUS, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_signal_kind

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSignal_kind" ):
                listener.enterSignal_kind(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSignal_kind" ):
                listener.exitSignal_kind(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSignal_kind" ):
                return visitor.visitSignal_kind(self)
            else:
                return visitor.visitChildren(self)




    def signal_kind(self):

        localctx = vhdlParser.Signal_kindContext(self, self._ctx, self.state)
        self.enterRule(localctx, 420, self.RULE_signal_kind)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2180
            _la = self._input.LA(1)
            if not(_la==17 or _la==78):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Signal_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.NameContext)
            else:
                return self.getTypedRuleContext(vhdlParser.NameContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.COMMA)
            else:
                return self.getToken(vhdlParser.COMMA, i)

        def OTHERS(self):
            return self.getToken(vhdlParser.OTHERS, 0)

        def ALL(self):
            return self.getToken(vhdlParser.ALL, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_signal_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSignal_list" ):
                listener.enterSignal_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSignal_list" ):
                listener.exitSignal_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSignal_list" ):
                return visitor.visitSignal_list(self)
            else:
                return visitor.visitChildren(self)




    def signal_list(self):

        localctx = vhdlParser.Signal_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 422, self.RULE_signal_list)
        self._la = 0 # Token type
        try:
            self.state = 2192
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [118, 119, 127]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2182
                self.name()
                self.state = 2187
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==139:
                    self.state = 2183
                    self.match(vhdlParser.COMMA)
                    self.state = 2184
                    self.name()
                    self.state = 2189
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [62]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2190
                self.match(vhdlParser.OTHERS)
                pass
            elif token in [6]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2191
                self.match(vhdlParser.ALL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SignatureContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACKET(self):
            return self.getToken(vhdlParser.LBRACKET, 0)

        def RBRACKET(self):
            return self.getToken(vhdlParser.RBRACKET, 0)

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.NameContext)
            else:
                return self.getTypedRuleContext(vhdlParser.NameContext,i)


        def RETURN(self):
            return self.getToken(vhdlParser.RETURN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.COMMA)
            else:
                return self.getToken(vhdlParser.COMMA, i)

        def getRuleIndex(self):
            return vhdlParser.RULE_signature

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSignature" ):
                listener.enterSignature(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSignature" ):
                listener.exitSignature(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSignature" ):
                return visitor.visitSignature(self)
            else:
                return visitor.visitChildren(self)




    def signature(self):

        localctx = vhdlParser.SignatureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 424, self.RULE_signature)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2194
            self.match(vhdlParser.LBRACKET)
            self.state = 2203
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la - 118)) & ~0x3f) == 0 and ((1 << (_la - 118)) & 515) != 0:
                self.state = 2195
                self.name()
                self.state = 2200
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==139:
                    self.state = 2196
                    self.match(vhdlParser.COMMA)
                    self.state = 2197
                    self.name()
                    self.state = 2202
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 2207
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==80:
                self.state = 2205
                self.match(vhdlParser.RETURN)
                self.state = 2206
                self.name()


            self.state = 2209
            self.match(vhdlParser.RBRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Simple_expressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.TermContext)
            else:
                return self.getTypedRuleContext(vhdlParser.TermContext,i)


        def adding_operator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Adding_operatorContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Adding_operatorContext,i)


        def PLUS(self):
            return self.getToken(vhdlParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(vhdlParser.MINUS, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_simple_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimple_expression" ):
                listener.enterSimple_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimple_expression" ):
                listener.exitSimple_expression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimple_expression" ):
                return visitor.visitSimple_expression(self)
            else:
                return visitor.visitChildren(self)




    def simple_expression(self):

        localctx = vhdlParser.Simple_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 426, self.RULE_simple_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2212
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==148 or _la==149:
                self.state = 2211
                _la = self._input.LA(1)
                if not(_la==148 or _la==149):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 2214
            self.term()
            self.state = 2220
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,242,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2215
                    self.adding_operator()
                    self.state = 2216
                    self.term() 
                self.state = 2222
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,242,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Simple_simultaneous_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simple_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Simple_expressionContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Simple_expressionContext,i)


        def ASSIGN(self):
            return self.getToken(vhdlParser.ASSIGN, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def tolerance_aspect(self):
            return self.getTypedRuleContext(vhdlParser.Tolerance_aspectContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_simple_simultaneous_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimple_simultaneous_statement" ):
                listener.enterSimple_simultaneous_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimple_simultaneous_statement" ):
                listener.exitSimple_simultaneous_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimple_simultaneous_statement" ):
                return visitor.visitSimple_simultaneous_statement(self)
            else:
                return visitor.visitChildren(self)




    def simple_simultaneous_statement(self):

        localctx = vhdlParser.Simple_simultaneous_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 428, self.RULE_simple_simultaneous_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2224
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,243,self._ctx)
            if la_ == 1:
                self.state = 2223
                self.label_colon()


            self.state = 2226
            self.simple_expression()
            self.state = 2227
            self.match(vhdlParser.ASSIGN)
            self.state = 2228
            self.simple_expression()
            self.state = 2230
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==98:
                self.state = 2229
                self.tolerance_aspect()


            self.state = 2232
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Simultaneous_alternativeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHEN(self):
            return self.getToken(vhdlParser.WHEN, 0)

        def choices(self):
            return self.getTypedRuleContext(vhdlParser.ChoicesContext,0)


        def ARROW(self):
            return self.getToken(vhdlParser.ARROW, 0)

        def simultaneous_statement_part(self):
            return self.getTypedRuleContext(vhdlParser.Simultaneous_statement_partContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_simultaneous_alternative

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimultaneous_alternative" ):
                listener.enterSimultaneous_alternative(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimultaneous_alternative" ):
                listener.exitSimultaneous_alternative(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimultaneous_alternative" ):
                return visitor.visitSimultaneous_alternative(self)
            else:
                return visitor.visitChildren(self)




    def simultaneous_alternative(self):

        localctx = vhdlParser.Simultaneous_alternativeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 430, self.RULE_simultaneous_alternative)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2234
            self.match(vhdlParser.WHEN)
            self.state = 2235
            self.choices()
            self.state = 2236
            self.match(vhdlParser.ARROW)
            self.state = 2237
            self.simultaneous_statement_part()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Simultaneous_case_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CASE(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.CASE)
            else:
                return self.getToken(vhdlParser.CASE, i)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def USE(self):
            return self.getToken(vhdlParser.USE, 0)

        def END(self):
            return self.getToken(vhdlParser.END, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def simultaneous_alternative(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Simultaneous_alternativeContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Simultaneous_alternativeContext,i)


        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_simultaneous_case_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimultaneous_case_statement" ):
                listener.enterSimultaneous_case_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimultaneous_case_statement" ):
                listener.exitSimultaneous_case_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimultaneous_case_statement" ):
                return visitor.visitSimultaneous_case_statement(self)
            else:
                return visitor.visitChildren(self)




    def simultaneous_case_statement(self):

        localctx = vhdlParser.Simultaneous_case_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 432, self.RULE_simultaneous_case_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2240
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 2239
                self.label_colon()


            self.state = 2242
            self.match(vhdlParser.CASE)
            self.state = 2243
            self.expression()
            self.state = 2244
            self.match(vhdlParser.USE)
            self.state = 2246 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 2245
                self.simultaneous_alternative()
                self.state = 2248 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==108):
                    break

            self.state = 2250
            self.match(vhdlParser.END)
            self.state = 2251
            self.match(vhdlParser.CASE)
            self.state = 2253
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 2252
                self.identifier()


            self.state = 2255
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Simultaneous_if_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(vhdlParser.IF, 0)

        def condition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.ConditionContext)
            else:
                return self.getTypedRuleContext(vhdlParser.ConditionContext,i)


        def USE(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.USE)
            else:
                return self.getToken(vhdlParser.USE, i)

        def simultaneous_statement_part(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Simultaneous_statement_partContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Simultaneous_statement_partContext,i)


        def END(self):
            return self.getToken(vhdlParser.END, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def ELSIF(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.ELSIF)
            else:
                return self.getToken(vhdlParser.ELSIF, i)

        def ELSE(self):
            return self.getToken(vhdlParser.ELSE, 0)

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_simultaneous_if_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimultaneous_if_statement" ):
                listener.enterSimultaneous_if_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimultaneous_if_statement" ):
                listener.exitSimultaneous_if_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimultaneous_if_statement" ):
                return visitor.visitSimultaneous_if_statement(self)
            else:
                return visitor.visitChildren(self)




    def simultaneous_if_statement(self):

        localctx = vhdlParser.Simultaneous_if_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 434, self.RULE_simultaneous_if_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2258
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 2257
                self.label_colon()


            self.state = 2260
            self.match(vhdlParser.IF)
            self.state = 2261
            self.condition()
            self.state = 2262
            self.match(vhdlParser.USE)
            self.state = 2263
            self.simultaneous_statement_part()
            self.state = 2271
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==27:
                self.state = 2264
                self.match(vhdlParser.ELSIF)
                self.state = 2265
                self.condition()
                self.state = 2266
                self.match(vhdlParser.USE)
                self.state = 2267
                self.simultaneous_statement_part()
                self.state = 2273
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2276
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==26:
                self.state = 2274
                self.match(vhdlParser.ELSE)
                self.state = 2275
                self.simultaneous_statement_part()


            self.state = 2278
            self.match(vhdlParser.END)
            self.state = 2279
            self.match(vhdlParser.USE)
            self.state = 2281
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 2280
                self.identifier()


            self.state = 2283
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Simultaneous_procedural_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROCEDURAL(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.PROCEDURAL)
            else:
                return self.getToken(vhdlParser.PROCEDURAL, i)

        def procedural_declarative_part(self):
            return self.getTypedRuleContext(vhdlParser.Procedural_declarative_partContext,0)


        def BEGIN(self):
            return self.getToken(vhdlParser.BEGIN, 0)

        def procedural_statement_part(self):
            return self.getTypedRuleContext(vhdlParser.Procedural_statement_partContext,0)


        def END(self):
            return self.getToken(vhdlParser.END, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def IS(self):
            return self.getToken(vhdlParser.IS, 0)

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_simultaneous_procedural_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimultaneous_procedural_statement" ):
                listener.enterSimultaneous_procedural_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimultaneous_procedural_statement" ):
                listener.exitSimultaneous_procedural_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimultaneous_procedural_statement" ):
                return visitor.visitSimultaneous_procedural_statement(self)
            else:
                return visitor.visitChildren(self)




    def simultaneous_procedural_statement(self):

        localctx = vhdlParser.Simultaneous_procedural_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 436, self.RULE_simultaneous_procedural_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2286
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 2285
                self.label_colon()


            self.state = 2288
            self.match(vhdlParser.PROCEDURAL)
            self.state = 2290
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41:
                self.state = 2289
                self.match(vhdlParser.IS)


            self.state = 2292
            self.procedural_declarative_part()
            self.state = 2293
            self.match(vhdlParser.BEGIN)
            self.state = 2294
            self.procedural_statement_part()
            self.state = 2295
            self.match(vhdlParser.END)
            self.state = 2296
            self.match(vhdlParser.PROCEDURAL)
            self.state = 2298
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 2297
                self.identifier()


            self.state = 2300
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Simultaneous_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simple_simultaneous_statement(self):
            return self.getTypedRuleContext(vhdlParser.Simple_simultaneous_statementContext,0)


        def simultaneous_if_statement(self):
            return self.getTypedRuleContext(vhdlParser.Simultaneous_if_statementContext,0)


        def simultaneous_case_statement(self):
            return self.getTypedRuleContext(vhdlParser.Simultaneous_case_statementContext,0)


        def simultaneous_procedural_statement(self):
            return self.getTypedRuleContext(vhdlParser.Simultaneous_procedural_statementContext,0)


        def NULL_(self):
            return self.getToken(vhdlParser.NULL_, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_simultaneous_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimultaneous_statement" ):
                listener.enterSimultaneous_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimultaneous_statement" ):
                listener.exitSimultaneous_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimultaneous_statement" ):
                return visitor.visitSimultaneous_statement(self)
            else:
                return visitor.visitChildren(self)




    def simultaneous_statement(self):

        localctx = vhdlParser.Simultaneous_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 438, self.RULE_simultaneous_statement)
        self._la = 0 # Token type
        try:
            self.state = 2311
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,256,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2302
                self.simple_simultaneous_statement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2303
                self.simultaneous_if_statement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2304
                self.simultaneous_case_statement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2305
                self.simultaneous_procedural_statement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2307
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==118 or _la==119:
                    self.state = 2306
                    self.label_colon()


                self.state = 2309
                self.match(vhdlParser.NULL_)
                self.state = 2310
                self.match(vhdlParser.SEMI)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Simultaneous_statement_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simultaneous_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Simultaneous_statementContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Simultaneous_statementContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_simultaneous_statement_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimultaneous_statement_part" ):
                listener.enterSimultaneous_statement_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimultaneous_statement_part" ):
                listener.exitSimultaneous_statement_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimultaneous_statement_part" ):
                return visitor.visitSimultaneous_statement_part(self)
            else:
                return visitor.visitChildren(self)




    def simultaneous_statement_part(self):

        localctx = vhdlParser.Simultaneous_statement_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 440, self.RULE_simultaneous_statement_part)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2316
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & 220676450460893186) != 0 or (((_la - 69)) & ~0x3f) == 0 and ((1 << (_la - 69)) & 434342277343608833) != 0 or (((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & 131457) != 0:
                self.state = 2313
                self.simultaneous_statement()
                self.state = 2318
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Source_aspectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SPECTRUM(self):
            return self.getToken(vhdlParser.SPECTRUM, 0)

        def simple_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Simple_expressionContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Simple_expressionContext,i)


        def COMMA(self):
            return self.getToken(vhdlParser.COMMA, 0)

        def NOISE(self):
            return self.getToken(vhdlParser.NOISE, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_source_aspect

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSource_aspect" ):
                listener.enterSource_aspect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSource_aspect" ):
                listener.exitSource_aspect(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSource_aspect" ):
                return visitor.visitSource_aspect(self)
            else:
                return visitor.visitChildren(self)




    def source_aspect(self):

        localctx = vhdlParser.Source_aspectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 442, self.RULE_source_aspect)
        try:
            self.state = 2326
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [89]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2319
                self.match(vhdlParser.SPECTRUM)
                self.state = 2320
                self.simple_expression()
                self.state = 2321
                self.match(vhdlParser.COMMA)
                self.state = 2322
                self.simple_expression()
                pass
            elif token in [54]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2324
                self.match(vhdlParser.NOISE)
                self.state = 2325
                self.simple_expression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Source_quantity_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUANTITY(self):
            return self.getToken(vhdlParser.QUANTITY, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(vhdlParser.Identifier_listContext,0)


        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def source_aspect(self):
            return self.getTypedRuleContext(vhdlParser.Source_aspectContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_source_quantity_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSource_quantity_declaration" ):
                listener.enterSource_quantity_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSource_quantity_declaration" ):
                listener.exitSource_quantity_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSource_quantity_declaration" ):
                return visitor.visitSource_quantity_declaration(self)
            else:
                return visitor.visitChildren(self)




    def source_quantity_declaration(self):

        localctx = vhdlParser.Source_quantity_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 444, self.RULE_source_quantity_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2328
            self.match(vhdlParser.QUANTITY)
            self.state = 2329
            self.identifier_list()
            self.state = 2330
            self.match(vhdlParser.COLON)
            self.state = 2331
            self.subtype_indication()
            self.state = 2332
            self.source_aspect()
            self.state = 2333
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Step_limit_specificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIMIT(self):
            return self.getToken(vhdlParser.LIMIT, 0)

        def quantity_specification(self):
            return self.getTypedRuleContext(vhdlParser.Quantity_specificationContext,0)


        def WITH(self):
            return self.getToken(vhdlParser.WITH, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_step_limit_specification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStep_limit_specification" ):
                listener.enterStep_limit_specification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStep_limit_specification" ):
                listener.exitStep_limit_specification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStep_limit_specification" ):
                return visitor.visitStep_limit_specification(self)
            else:
                return visitor.visitChildren(self)




    def step_limit_specification(self):

        localctx = vhdlParser.Step_limit_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 446, self.RULE_step_limit_specification)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2335
            self.match(vhdlParser.LIMIT)
            self.state = 2336
            self.quantity_specification()
            self.state = 2337
            self.match(vhdlParser.WITH)
            self.state = 2338
            self.expression()
            self.state = 2339
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Subnature_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUBNATURE(self):
            return self.getToken(vhdlParser.SUBNATURE, 0)

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def IS(self):
            return self.getToken(vhdlParser.IS, 0)

        def subnature_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subnature_indicationContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_subnature_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubnature_declaration" ):
                listener.enterSubnature_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubnature_declaration" ):
                listener.exitSubnature_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubnature_declaration" ):
                return visitor.visitSubnature_declaration(self)
            else:
                return visitor.visitChildren(self)




    def subnature_declaration(self):

        localctx = vhdlParser.Subnature_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 448, self.RULE_subnature_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2341
            self.match(vhdlParser.SUBNATURE)
            self.state = 2342
            self.identifier()
            self.state = 2343
            self.match(vhdlParser.IS)
            self.state = 2344
            self.subnature_indication()
            self.state = 2345
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Subnature_indicationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(vhdlParser.NameContext,0)


        def index_constraint(self):
            return self.getTypedRuleContext(vhdlParser.Index_constraintContext,0)


        def TOLERANCE(self):
            return self.getToken(vhdlParser.TOLERANCE, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(vhdlParser.ExpressionContext,i)


        def ACROSS(self):
            return self.getToken(vhdlParser.ACROSS, 0)

        def THROUGH(self):
            return self.getToken(vhdlParser.THROUGH, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_subnature_indication

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubnature_indication" ):
                listener.enterSubnature_indication(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubnature_indication" ):
                listener.exitSubnature_indication(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubnature_indication" ):
                return visitor.visitSubnature_indication(self)
            else:
                return visitor.visitChildren(self)




    def subnature_indication(self):

        localctx = vhdlParser.Subnature_indicationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 450, self.RULE_subnature_indication)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2347
            self.name()
            self.state = 2349
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==141:
                self.state = 2348
                self.index_constraint()


            self.state = 2357
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==98:
                self.state = 2351
                self.match(vhdlParser.TOLERANCE)
                self.state = 2352
                self.expression()
                self.state = 2353
                self.match(vhdlParser.ACROSS)
                self.state = 2354
                self.expression()
                self.state = 2355
                self.match(vhdlParser.THROUGH)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Subprogram_bodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subprogram_specification(self):
            return self.getTypedRuleContext(vhdlParser.Subprogram_specificationContext,0)


        def IS(self):
            return self.getToken(vhdlParser.IS, 0)

        def subprogram_declarative_part(self):
            return self.getTypedRuleContext(vhdlParser.Subprogram_declarative_partContext,0)


        def BEGIN(self):
            return self.getToken(vhdlParser.BEGIN, 0)

        def subprogram_statement_part(self):
            return self.getTypedRuleContext(vhdlParser.Subprogram_statement_partContext,0)


        def END(self):
            return self.getToken(vhdlParser.END, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def subprogram_kind(self):
            return self.getTypedRuleContext(vhdlParser.Subprogram_kindContext,0)


        def designator(self):
            return self.getTypedRuleContext(vhdlParser.DesignatorContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_subprogram_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubprogram_body" ):
                listener.enterSubprogram_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubprogram_body" ):
                listener.exitSubprogram_body(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubprogram_body" ):
                return visitor.visitSubprogram_body(self)
            else:
                return visitor.visitChildren(self)




    def subprogram_body(self):

        localctx = vhdlParser.Subprogram_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 452, self.RULE_subprogram_body)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2359
            self.subprogram_specification()
            self.state = 2360
            self.match(vhdlParser.IS)
            self.state = 2361
            self.subprogram_declarative_part()
            self.state = 2362
            self.match(vhdlParser.BEGIN)
            self.state = 2363
            self.subprogram_statement_part()
            self.state = 2364
            self.match(vhdlParser.END)
            self.state = 2366
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==31 or _la==68:
                self.state = 2365
                self.subprogram_kind()


            self.state = 2369
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la - 118)) & ~0x3f) == 0 and ((1 << (_la - 118)) & 515) != 0:
                self.state = 2368
                self.designator()


            self.state = 2371
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Subprogram_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subprogram_specification(self):
            return self.getTypedRuleContext(vhdlParser.Subprogram_specificationContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_subprogram_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubprogram_declaration" ):
                listener.enterSubprogram_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubprogram_declaration" ):
                listener.exitSubprogram_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubprogram_declaration" ):
                return visitor.visitSubprogram_declaration(self)
            else:
                return visitor.visitChildren(self)




    def subprogram_declaration(self):

        localctx = vhdlParser.Subprogram_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 454, self.RULE_subprogram_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2373
            self.subprogram_specification()
            self.state = 2374
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Subprogram_declarative_itemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subprogram_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Subprogram_declarationContext,0)


        def subprogram_body(self):
            return self.getTypedRuleContext(vhdlParser.Subprogram_bodyContext,0)


        def type_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Type_declarationContext,0)


        def subtype_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_declarationContext,0)


        def constant_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Constant_declarationContext,0)


        def variable_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Variable_declarationContext,0)


        def file_declaration(self):
            return self.getTypedRuleContext(vhdlParser.File_declarationContext,0)


        def alias_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Alias_declarationContext,0)


        def attribute_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Attribute_declarationContext,0)


        def attribute_specification(self):
            return self.getTypedRuleContext(vhdlParser.Attribute_specificationContext,0)


        def use_clause(self):
            return self.getTypedRuleContext(vhdlParser.Use_clauseContext,0)


        def group_template_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Group_template_declarationContext,0)


        def group_declaration(self):
            return self.getTypedRuleContext(vhdlParser.Group_declarationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_subprogram_declarative_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubprogram_declarative_item" ):
                listener.enterSubprogram_declarative_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubprogram_declarative_item" ):
                listener.exitSubprogram_declarative_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubprogram_declarative_item" ):
                return visitor.visitSubprogram_declarative_item(self)
            else:
                return visitor.visitChildren(self)




    def subprogram_declarative_item(self):

        localctx = vhdlParser.Subprogram_declarative_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 456, self.RULE_subprogram_declarative_item)
        try:
            self.state = 2389
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,263,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2376
                self.subprogram_declaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2377
                self.subprogram_body()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2378
                self.type_declaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2379
                self.subtype_declaration()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2380
                self.constant_declaration()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2381
                self.variable_declaration()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2382
                self.file_declaration()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 2383
                self.alias_declaration()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 2384
                self.attribute_declaration()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 2385
                self.attribute_specification()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 2386
                self.use_clause()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 2387
                self.group_template_declaration()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 2388
                self.group_declaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Subprogram_declarative_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subprogram_declarative_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Subprogram_declarative_itemContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Subprogram_declarative_itemContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_subprogram_declarative_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubprogram_declarative_part" ):
                listener.enterSubprogram_declarative_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubprogram_declarative_part" ):
                listener.exitSubprogram_declarative_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubprogram_declarative_part" ):
                return visitor.visitSubprogram_declarative_part(self)
            else:
                return visitor.visitChildren(self)




    def subprogram_declarative_part(self):

        localctx = vhdlParser.Subprogram_declarative_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 458, self.RULE_subprogram_declarative_part)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2394
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & 157305276448) != 0 or (((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & 210487083013) != 0:
                self.state = 2391
                self.subprogram_declarative_item()
                self.state = 2396
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Subprogram_kindContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROCEDURE(self):
            return self.getToken(vhdlParser.PROCEDURE, 0)

        def FUNCTION(self):
            return self.getToken(vhdlParser.FUNCTION, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_subprogram_kind

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubprogram_kind" ):
                listener.enterSubprogram_kind(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubprogram_kind" ):
                listener.exitSubprogram_kind(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubprogram_kind" ):
                return visitor.visitSubprogram_kind(self)
            else:
                return visitor.visitChildren(self)




    def subprogram_kind(self):

        localctx = vhdlParser.Subprogram_kindContext(self, self._ctx, self.state)
        self.enterRule(localctx, 460, self.RULE_subprogram_kind)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2397
            _la = self._input.LA(1)
            if not(_la==31 or _la==68):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Subprogram_specificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def procedure_specification(self):
            return self.getTypedRuleContext(vhdlParser.Procedure_specificationContext,0)


        def function_specification(self):
            return self.getTypedRuleContext(vhdlParser.Function_specificationContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_subprogram_specification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubprogram_specification" ):
                listener.enterSubprogram_specification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubprogram_specification" ):
                listener.exitSubprogram_specification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubprogram_specification" ):
                return visitor.visitSubprogram_specification(self)
            else:
                return visitor.visitChildren(self)




    def subprogram_specification(self):

        localctx = vhdlParser.Subprogram_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 462, self.RULE_subprogram_specification)
        try:
            self.state = 2401
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [68]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2399
                self.procedure_specification()
                pass
            elif token in [31, 37, 70]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2400
                self.function_specification()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Procedure_specificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROCEDURE(self):
            return self.getToken(vhdlParser.PROCEDURE, 0)

        def designator(self):
            return self.getTypedRuleContext(vhdlParser.DesignatorContext,0)


        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def formal_parameter_list(self):
            return self.getTypedRuleContext(vhdlParser.Formal_parameter_listContext,0)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_procedure_specification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcedure_specification" ):
                listener.enterProcedure_specification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcedure_specification" ):
                listener.exitProcedure_specification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcedure_specification" ):
                return visitor.visitProcedure_specification(self)
            else:
                return visitor.visitChildren(self)




    def procedure_specification(self):

        localctx = vhdlParser.Procedure_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 464, self.RULE_procedure_specification)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2403
            self.match(vhdlParser.PROCEDURE)
            self.state = 2404
            self.designator()
            self.state = 2409
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==141:
                self.state = 2405
                self.match(vhdlParser.LPAREN)
                self.state = 2406
                self.formal_parameter_list()
                self.state = 2407
                self.match(vhdlParser.RPAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_specificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FUNCTION(self):
            return self.getToken(vhdlParser.FUNCTION, 0)

        def designator(self):
            return self.getTypedRuleContext(vhdlParser.DesignatorContext,0)


        def RETURN(self):
            return self.getToken(vhdlParser.RETURN, 0)

        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def formal_parameter_list(self):
            return self.getTypedRuleContext(vhdlParser.Formal_parameter_listContext,0)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def PURE(self):
            return self.getToken(vhdlParser.PURE, 0)

        def IMPURE(self):
            return self.getToken(vhdlParser.IMPURE, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_function_specification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_specification" ):
                listener.enterFunction_specification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_specification" ):
                listener.exitFunction_specification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunction_specification" ):
                return visitor.visitFunction_specification(self)
            else:
                return visitor.visitChildren(self)




    def function_specification(self):

        localctx = vhdlParser.Function_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 466, self.RULE_function_specification)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2412
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==37 or _la==70:
                self.state = 2411
                _la = self._input.LA(1)
                if not(_la==37 or _la==70):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 2414
            self.match(vhdlParser.FUNCTION)
            self.state = 2415
            self.designator()
            self.state = 2420
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==141:
                self.state = 2416
                self.match(vhdlParser.LPAREN)
                self.state = 2417
                self.formal_parameter_list()
                self.state = 2418
                self.match(vhdlParser.RPAREN)


            self.state = 2422
            self.match(vhdlParser.RETURN)
            self.state = 2423
            self.subtype_indication()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Subprogram_statement_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sequential_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Sequential_statementContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Sequential_statementContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_subprogram_statement_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubprogram_statement_part" ):
                listener.enterSubprogram_statement_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubprogram_statement_part" ):
                listener.exitSubprogram_statement_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubprogram_statement_part" ):
                return visitor.visitSubprogram_statement_part(self)
            else:
                return visitor.visitChildren(self)




    def subprogram_statement_part(self):

        localctx = vhdlParser.Subprogram_statement_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 468, self.RULE_subprogram_statement_part)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2428
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & 153263194880902144) != 0 or (((_la - 79)) & ~0x3f) == 0 and ((1 << (_la - 79)) & 4611969143879499779) != 0:
                self.state = 2425
                self.sequential_statement()
                self.state = 2430
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Subtype_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUBTYPE(self):
            return self.getToken(vhdlParser.SUBTYPE, 0)

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def IS(self):
            return self.getToken(vhdlParser.IS, 0)

        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_subtype_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubtype_declaration" ):
                listener.enterSubtype_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubtype_declaration" ):
                listener.exitSubtype_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubtype_declaration" ):
                return visitor.visitSubtype_declaration(self)
            else:
                return visitor.visitChildren(self)




    def subtype_declaration(self):

        localctx = vhdlParser.Subtype_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 470, self.RULE_subtype_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2431
            self.match(vhdlParser.SUBTYPE)
            self.state = 2432
            self.identifier()
            self.state = 2433
            self.match(vhdlParser.IS)
            self.state = 2434
            self.subtype_indication()
            self.state = 2435
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Subtype_indicationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def selected_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Selected_nameContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Selected_nameContext,i)


        def constraint(self):
            return self.getTypedRuleContext(vhdlParser.ConstraintContext,0)


        def tolerance_aspect(self):
            return self.getTypedRuleContext(vhdlParser.Tolerance_aspectContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_subtype_indication

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubtype_indication" ):
                listener.enterSubtype_indication(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubtype_indication" ):
                listener.exitSubtype_indication(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubtype_indication" ):
                return visitor.visitSubtype_indication(self)
            else:
                return visitor.visitChildren(self)




    def subtype_indication(self):

        localctx = vhdlParser.Subtype_indicationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 472, self.RULE_subtype_indication)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2437
            self.selected_name()
            self.state = 2439
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 2438
                self.selected_name()


            self.state = 2442
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==72 or _la==141:
                self.state = 2441
                self.constraint()


            self.state = 2445
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,272,self._ctx)
            if la_ == 1:
                self.state = 2444
                self.tolerance_aspect()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SuffixContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def CHARACTER_LITERAL(self):
            return self.getToken(vhdlParser.CHARACTER_LITERAL, 0)

        def STRING_LITERAL(self):
            return self.getToken(vhdlParser.STRING_LITERAL, 0)

        def ALL(self):
            return self.getToken(vhdlParser.ALL, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_suffix

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSuffix" ):
                listener.enterSuffix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSuffix" ):
                listener.exitSuffix(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSuffix" ):
                return visitor.visitSuffix(self)
            else:
                return visitor.visitChildren(self)




    def suffix(self):

        localctx = vhdlParser.SuffixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 474, self.RULE_suffix)
        try:
            self.state = 2451
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [118, 119]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2447
                self.identifier()
                pass
            elif token in [126]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2448
                self.match(vhdlParser.CHARACTER_LITERAL)
                pass
            elif token in [127]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2449
                self.match(vhdlParser.STRING_LITERAL)
                pass
            elif token in [6]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2450
                self.match(vhdlParser.ALL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TargetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(vhdlParser.NameContext,0)


        def aggregate(self):
            return self.getTypedRuleContext(vhdlParser.AggregateContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_target

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTarget" ):
                listener.enterTarget(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTarget" ):
                listener.exitTarget(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTarget" ):
                return visitor.visitTarget(self)
            else:
                return visitor.visitChildren(self)




    def target(self):

        localctx = vhdlParser.TargetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 476, self.RULE_target)
        try:
            self.state = 2455
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [118, 119, 127]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2453
                self.name()
                pass
            elif token in [141]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2454
                self.aggregate()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def factor(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.FactorContext)
            else:
                return self.getTypedRuleContext(vhdlParser.FactorContext,i)


        def multiplying_operator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Multiplying_operatorContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Multiplying_operatorContext,i)


        def getRuleIndex(self):
            return vhdlParser.RULE_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm" ):
                listener.enterTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm" ):
                listener.exitTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerm" ):
                return visitor.visitTerm(self)
            else:
                return visitor.visitChildren(self)




    def term(self):

        localctx = vhdlParser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 478, self.RULE_term)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2457
            self.factor()
            self.state = 2463
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,275,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2458
                    self.multiplying_operator()
                    self.state = 2459
                    self.factor() 
                self.state = 2465
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,275,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Terminal_aspectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.NameContext)
            else:
                return self.getTypedRuleContext(vhdlParser.NameContext,i)


        def TO(self):
            return self.getToken(vhdlParser.TO, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_terminal_aspect

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerminal_aspect" ):
                listener.enterTerminal_aspect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerminal_aspect" ):
                listener.exitTerminal_aspect(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerminal_aspect" ):
                return visitor.visitTerminal_aspect(self)
            else:
                return visitor.visitChildren(self)




    def terminal_aspect(self):

        localctx = vhdlParser.Terminal_aspectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 480, self.RULE_terminal_aspect)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2466
            self.name()
            self.state = 2469
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==97:
                self.state = 2467
                self.match(vhdlParser.TO)
                self.state = 2468
                self.name()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Terminal_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TERMINAL(self):
            return self.getToken(vhdlParser.TERMINAL, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(vhdlParser.Identifier_listContext,0)


        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def subnature_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subnature_indicationContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_terminal_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerminal_declaration" ):
                listener.enterTerminal_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerminal_declaration" ):
                listener.exitTerminal_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerminal_declaration" ):
                return visitor.visitTerminal_declaration(self)
            else:
                return visitor.visitChildren(self)




    def terminal_declaration(self):

        localctx = vhdlParser.Terminal_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 482, self.RULE_terminal_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2471
            self.match(vhdlParser.TERMINAL)
            self.state = 2472
            self.identifier_list()
            self.state = 2473
            self.match(vhdlParser.COLON)
            self.state = 2474
            self.subnature_indication()
            self.state = 2475
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Through_aspectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier_list(self):
            return self.getTypedRuleContext(vhdlParser.Identifier_listContext,0)


        def THROUGH(self):
            return self.getToken(vhdlParser.THROUGH, 0)

        def tolerance_aspect(self):
            return self.getTypedRuleContext(vhdlParser.Tolerance_aspectContext,0)


        def VARASGN(self):
            return self.getToken(vhdlParser.VARASGN, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_through_aspect

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThrough_aspect" ):
                listener.enterThrough_aspect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThrough_aspect" ):
                listener.exitThrough_aspect(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThrough_aspect" ):
                return visitor.visitThrough_aspect(self)
            else:
                return visitor.visitChildren(self)




    def through_aspect(self):

        localctx = vhdlParser.Through_aspectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 484, self.RULE_through_aspect)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2477
            self.identifier_list()
            self.state = 2479
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==98:
                self.state = 2478
                self.tolerance_aspect()


            self.state = 2483
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==135:
                self.state = 2481
                self.match(vhdlParser.VARASGN)
                self.state = 2482
                self.expression()


            self.state = 2485
            self.match(vhdlParser.THROUGH)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Timeout_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(vhdlParser.FOR, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_timeout_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimeout_clause" ):
                listener.enterTimeout_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimeout_clause" ):
                listener.exitTimeout_clause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTimeout_clause" ):
                return visitor.visitTimeout_clause(self)
            else:
                return visitor.visitChildren(self)




    def timeout_clause(self):

        localctx = vhdlParser.Timeout_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 486, self.RULE_timeout_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2487
            self.match(vhdlParser.FOR)
            self.state = 2488
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tolerance_aspectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TOLERANCE(self):
            return self.getToken(vhdlParser.TOLERANCE, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_tolerance_aspect

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTolerance_aspect" ):
                listener.enterTolerance_aspect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTolerance_aspect" ):
                listener.exitTolerance_aspect(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTolerance_aspect" ):
                return visitor.visitTolerance_aspect(self)
            else:
                return visitor.visitChildren(self)




    def tolerance_aspect(self):

        localctx = vhdlParser.Tolerance_aspectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 488, self.RULE_tolerance_aspect)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2490
            self.match(vhdlParser.TOLERANCE)
            self.state = 2491
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE(self):
            return self.getToken(vhdlParser.TYPE, 0)

        def identifier(self):
            return self.getTypedRuleContext(vhdlParser.IdentifierContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def IS(self):
            return self.getToken(vhdlParser.IS, 0)

        def type_definition(self):
            return self.getTypedRuleContext(vhdlParser.Type_definitionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_type_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_declaration" ):
                listener.enterType_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_declaration" ):
                listener.exitType_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_declaration" ):
                return visitor.visitType_declaration(self)
            else:
                return visitor.visitChildren(self)




    def type_declaration(self):

        localctx = vhdlParser.Type_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 490, self.RULE_type_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2493
            self.match(vhdlParser.TYPE)
            self.state = 2494
            self.identifier()
            self.state = 2497
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41:
                self.state = 2495
                self.match(vhdlParser.IS)
                self.state = 2496
                self.type_definition()


            self.state = 2499
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def scalar_type_definition(self):
            return self.getTypedRuleContext(vhdlParser.Scalar_type_definitionContext,0)


        def composite_type_definition(self):
            return self.getTypedRuleContext(vhdlParser.Composite_type_definitionContext,0)


        def access_type_definition(self):
            return self.getTypedRuleContext(vhdlParser.Access_type_definitionContext,0)


        def file_type_definition(self):
            return self.getTypedRuleContext(vhdlParser.File_type_definitionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_type_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_definition" ):
                listener.enterType_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_definition" ):
                listener.exitType_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_definition" ):
                return visitor.visitType_definition(self)
            else:
                return visitor.visitChildren(self)




    def type_definition(self):

        localctx = vhdlParser.Type_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 492, self.RULE_type_definition)
        try:
            self.state = 2505
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [72, 141]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2501
                self.scalar_type_definition()
                pass
            elif token in [9, 76]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2502
                self.composite_type_definition()
                pass
            elif token in [2]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2503
                self.access_type_definition()
                pass
            elif token in [29]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2504
                self.file_type_definition()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unconstrained_array_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ARRAY(self):
            return self.getToken(vhdlParser.ARRAY, 0)

        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def index_subtype_definition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Index_subtype_definitionContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Index_subtype_definitionContext,i)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def OF(self):
            return self.getToken(vhdlParser.OF, 0)

        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.COMMA)
            else:
                return self.getToken(vhdlParser.COMMA, i)

        def getRuleIndex(self):
            return vhdlParser.RULE_unconstrained_array_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnconstrained_array_definition" ):
                listener.enterUnconstrained_array_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnconstrained_array_definition" ):
                listener.exitUnconstrained_array_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnconstrained_array_definition" ):
                return visitor.visitUnconstrained_array_definition(self)
            else:
                return visitor.visitChildren(self)




    def unconstrained_array_definition(self):

        localctx = vhdlParser.Unconstrained_array_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 494, self.RULE_unconstrained_array_definition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2507
            self.match(vhdlParser.ARRAY)
            self.state = 2508
            self.match(vhdlParser.LPAREN)
            self.state = 2509
            self.index_subtype_definition()
            self.state = 2514
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==139:
                self.state = 2510
                self.match(vhdlParser.COMMA)
                self.state = 2511
                self.index_subtype_definition()
                self.state = 2516
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2517
            self.match(vhdlParser.RPAREN)
            self.state = 2518
            self.match(vhdlParser.OF)
            self.state = 2519
            self.subtype_indication()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unconstrained_nature_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ARRAY(self):
            return self.getToken(vhdlParser.ARRAY, 0)

        def LPAREN(self):
            return self.getToken(vhdlParser.LPAREN, 0)

        def index_subtype_definition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Index_subtype_definitionContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Index_subtype_definitionContext,i)


        def RPAREN(self):
            return self.getToken(vhdlParser.RPAREN, 0)

        def OF(self):
            return self.getToken(vhdlParser.OF, 0)

        def subnature_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subnature_indicationContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.COMMA)
            else:
                return self.getToken(vhdlParser.COMMA, i)

        def getRuleIndex(self):
            return vhdlParser.RULE_unconstrained_nature_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnconstrained_nature_definition" ):
                listener.enterUnconstrained_nature_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnconstrained_nature_definition" ):
                listener.exitUnconstrained_nature_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnconstrained_nature_definition" ):
                return visitor.visitUnconstrained_nature_definition(self)
            else:
                return visitor.visitChildren(self)




    def unconstrained_nature_definition(self):

        localctx = vhdlParser.Unconstrained_nature_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 496, self.RULE_unconstrained_nature_definition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2521
            self.match(vhdlParser.ARRAY)
            self.state = 2522
            self.match(vhdlParser.LPAREN)
            self.state = 2523
            self.index_subtype_definition()
            self.state = 2528
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==139:
                self.state = 2524
                self.match(vhdlParser.COMMA)
                self.state = 2525
                self.index_subtype_definition()
                self.state = 2530
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2531
            self.match(vhdlParser.RPAREN)
            self.state = 2532
            self.match(vhdlParser.OF)
            self.state = 2533
            self.subnature_indication()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Use_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USE(self):
            return self.getToken(vhdlParser.USE, 0)

        def selected_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Selected_nameContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Selected_nameContext,i)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.COMMA)
            else:
                return self.getToken(vhdlParser.COMMA, i)

        def getRuleIndex(self):
            return vhdlParser.RULE_use_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUse_clause" ):
                listener.enterUse_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUse_clause" ):
                listener.exitUse_clause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUse_clause" ):
                return visitor.visitUse_clause(self)
            else:
                return visitor.visitChildren(self)




    def use_clause(self):

        localctx = vhdlParser.Use_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 498, self.RULE_use_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2535
            self.match(vhdlParser.USE)
            self.state = 2536
            self.selected_name()
            self.state = 2541
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==139:
                self.state = 2537
                self.match(vhdlParser.COMMA)
                self.state = 2538
                self.selected_name()
                self.state = 2543
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2544
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Variable_assignment_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def target(self):
            return self.getTypedRuleContext(vhdlParser.TargetContext,0)


        def VARASGN(self):
            return self.getToken(vhdlParser.VARASGN, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_variable_assignment_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable_assignment_statement" ):
                listener.enterVariable_assignment_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable_assignment_statement" ):
                listener.exitVariable_assignment_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable_assignment_statement" ):
                return visitor.visitVariable_assignment_statement(self)
            else:
                return visitor.visitChildren(self)




    def variable_assignment_statement(self):

        localctx = vhdlParser.Variable_assignment_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 500, self.RULE_variable_assignment_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2547
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,284,self._ctx)
            if la_ == 1:
                self.state = 2546
                self.label_colon()


            self.state = 2549
            self.target()
            self.state = 2550
            self.match(vhdlParser.VARASGN)
            self.state = 2551
            self.expression()
            self.state = 2552
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Variable_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VARIABLE(self):
            return self.getToken(vhdlParser.VARIABLE, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(vhdlParser.Identifier_listContext,0)


        def COLON(self):
            return self.getToken(vhdlParser.COLON, 0)

        def subtype_indication(self):
            return self.getTypedRuleContext(vhdlParser.Subtype_indicationContext,0)


        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def SHARED(self):
            return self.getToken(vhdlParser.SHARED, 0)

        def VARASGN(self):
            return self.getToken(vhdlParser.VARASGN, 0)

        def expression(self):
            return self.getTypedRuleContext(vhdlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_variable_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable_declaration" ):
                listener.enterVariable_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable_declaration" ):
                listener.exitVariable_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable_declaration" ):
                return visitor.visitVariable_declaration(self)
            else:
                return visitor.visitChildren(self)




    def variable_declaration(self):

        localctx = vhdlParser.Variable_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 502, self.RULE_variable_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2555
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==85:
                self.state = 2554
                self.match(vhdlParser.SHARED)


            self.state = 2557
            self.match(vhdlParser.VARIABLE)
            self.state = 2558
            self.identifier_list()
            self.state = 2559
            self.match(vhdlParser.COLON)
            self.state = 2560
            self.subtype_indication()
            self.state = 2563
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==135:
                self.state = 2561
                self.match(vhdlParser.VARASGN)
                self.state = 2562
                self.expression()


            self.state = 2565
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Wait_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WAIT(self):
            return self.getToken(vhdlParser.WAIT, 0)

        def SEMI(self):
            return self.getToken(vhdlParser.SEMI, 0)

        def label_colon(self):
            return self.getTypedRuleContext(vhdlParser.Label_colonContext,0)


        def sensitivity_clause(self):
            return self.getTypedRuleContext(vhdlParser.Sensitivity_clauseContext,0)


        def condition_clause(self):
            return self.getTypedRuleContext(vhdlParser.Condition_clauseContext,0)


        def timeout_clause(self):
            return self.getTypedRuleContext(vhdlParser.Timeout_clauseContext,0)


        def getRuleIndex(self):
            return vhdlParser.RULE_wait_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWait_statement" ):
                listener.enterWait_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWait_statement" ):
                listener.exitWait_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWait_statement" ):
                return visitor.visitWait_statement(self)
            else:
                return visitor.visitChildren(self)




    def wait_statement(self):

        localctx = vhdlParser.Wait_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 504, self.RULE_wait_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2568
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==119:
                self.state = 2567
                self.label_colon()


            self.state = 2570
            self.match(vhdlParser.WAIT)
            self.state = 2572
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==59:
                self.state = 2571
                self.sensitivity_clause()


            self.state = 2575
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==103:
                self.state = 2574
                self.condition_clause()


            self.state = 2578
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==30:
                self.state = 2577
                self.timeout_clause()


            self.state = 2580
            self.match(vhdlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WaveformContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def waveform_element(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.Waveform_elementContext)
            else:
                return self.getTypedRuleContext(vhdlParser.Waveform_elementContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(vhdlParser.COMMA)
            else:
                return self.getToken(vhdlParser.COMMA, i)

        def UNAFFECTED(self):
            return self.getToken(vhdlParser.UNAFFECTED, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_waveform

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWaveform" ):
                listener.enterWaveform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWaveform" ):
                listener.exitWaveform(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWaveform" ):
                return visitor.visitWaveform(self)
            else:
                return visitor.visitChildren(self)




    def waveform(self):

        localctx = vhdlParser.WaveformContext(self, self._ctx, self.state)
        self.enterRule(localctx, 506, self.RULE_waveform)
        self._la = 0 # Token type
        try:
            self.state = 2591
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [1, 52, 56, 57, 112, 113, 117, 118, 119, 126, 127, 141, 148, 149, 158]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2582
                self.waveform_element()
                self.state = 2587
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==139:
                    self.state = 2583
                    self.match(vhdlParser.COMMA)
                    self.state = 2584
                    self.waveform_element()
                    self.state = 2589
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [101]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2590
                self.match(vhdlParser.UNAFFECTED)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Waveform_elementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(vhdlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(vhdlParser.ExpressionContext,i)


        def AFTER(self):
            return self.getToken(vhdlParser.AFTER, 0)

        def getRuleIndex(self):
            return vhdlParser.RULE_waveform_element

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWaveform_element" ):
                listener.enterWaveform_element(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWaveform_element" ):
                listener.exitWaveform_element(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWaveform_element" ):
                return visitor.visitWaveform_element(self)
            else:
                return visitor.visitChildren(self)




    def waveform_element(self):

        localctx = vhdlParser.Waveform_elementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 508, self.RULE_waveform_element)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2593
            self.expression()
            self.state = 2596
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==4:
                self.state = 2594
                self.match(vhdlParser.AFTER)
                self.state = 2595
                self.expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





